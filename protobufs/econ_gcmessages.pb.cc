// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: econ_gcmessages.proto

#include "econ_gcmessages.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR CMsgGCGiftedItems::CMsgGCGiftedItems(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.recipients_accountids_)*/{}
  , /*decltype(_impl_.accountid_)*/0u
  , /*decltype(_impl_.giftdefindex_)*/0u
  , /*decltype(_impl_.max_gifts_possible_)*/0u
  , /*decltype(_impl_.num_eligible_recipients_)*/0u} {}
struct CMsgGCGiftedItemsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCGiftedItemsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCGiftedItemsDefaultTypeInternal() {}
  union {
    CMsgGCGiftedItems _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCGiftedItemsDefaultTypeInternal _CMsgGCGiftedItems_default_instance_;
PROTOBUF_CONSTEXPR CMsgCasketItem::CMsgCasketItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.casket_item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.item_item_id_)*/uint64_t{0u}} {}
struct CMsgCasketItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgCasketItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgCasketItemDefaultTypeInternal() {}
  union {
    CMsgCasketItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgCasketItemDefaultTypeInternal _CMsgCasketItem_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCUserTrackTimePlayedConsecutively::CMsgGCUserTrackTimePlayedConsecutively(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.state_)*/0u} {}
struct CMsgGCUserTrackTimePlayedConsecutivelyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCUserTrackTimePlayedConsecutivelyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCUserTrackTimePlayedConsecutivelyDefaultTypeInternal() {}
  union {
    CMsgGCUserTrackTimePlayedConsecutively _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCUserTrackTimePlayedConsecutivelyDefaultTypeInternal _CMsgGCUserTrackTimePlayedConsecutively_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCItemCustomizationNotification::CMsgGCItemCustomizationNotification(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.item_id_)*/{}
  , /*decltype(_impl_.request_)*/0u} {}
struct CMsgGCItemCustomizationNotificationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCItemCustomizationNotificationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCItemCustomizationNotificationDefaultTypeInternal() {}
  union {
    CMsgGCItemCustomizationNotification _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCItemCustomizationNotificationDefaultTypeInternal _CMsgGCItemCustomizationNotification_default_instance_;
bool EGCItemMsg_IsValid(int value) {
  switch (value) {
    case 1000:
    case 1001:
    case 1002:
    case 1003:
    case 1004:
    case 1005:
    case 1006:
    case 1007:
    case 1008:
    case 1009:
    case 1010:
    case 1011:
    case 1012:
    case 1013:
    case 1014:
    case 1015:
    case 1016:
    case 1017:
    case 1018:
    case 1019:
    case 1020:
    case 1021:
    case 1022:
    case 1023:
    case 1024:
    case 1025:
    case 1026:
    case 1027:
    case 1030:
    case 1031:
    case 1032:
    case 1033:
    case 1034:
    case 1035:
    case 1036:
    case 1037:
    case 1038:
    case 1039:
    case 1040:
    case 1041:
    case 1042:
    case 1043:
    case 1044:
    case 1045:
    case 1046:
    case 1049:
    case 1051:
    case 1052:
    case 1053:
    case 1054:
    case 1055:
    case 1056:
    case 1057:
    case 1058:
    case 1059:
    case 1061:
    case 1062:
    case 1065:
    case 1066:
    case 1068:
    case 1069:
    case 1070:
    case 1071:
    case 1072:
    case 1073:
    case 1074:
    case 1075:
    case 1076:
    case 1077:
    case 1078:
    case 1079:
    case 1080:
    case 1081:
    case 1082:
    case 1083:
    case 1084:
    case 1085:
    case 1086:
    case 1087:
    case 1088:
    case 1089:
    case 1090:
    case 1091:
    case 1092:
    case 1093:
    case 1094:
    case 1500:
    case 1501:
    case 1502:
    case 1503:
    case 1504:
    case 1505:
    case 1506:
    case 1507:
    case 1508:
    case 1509:
    case 1510:
    case 1511:
    case 1512:
    case 1513:
    case 1601:
    case 1602:
    case 1700:
    case 1701:
    case 1702:
    case 1703:
    case 1704:
    case 1705:
    case 1706:
    case 1707:
    case 2001:
    case 2002:
    case 2003:
    case 2500:
    case 2501:
    case 2502:
    case 2503:
    case 2504:
    case 2505:
    case 2506:
    case 2507:
    case 2508:
    case 2509:
    case 2510:
    case 2511:
    case 2512:
    case 2513:
    case 2514:
    case 2515:
    case 2516:
    case 2517:
    case 2518:
    case 2519:
    case 2520:
    case 2521:
    case 2522:
    case 2524:
    case 2525:
    case 2526:
    case 2527:
    case 2528:
    case 2529:
    case 2530:
    case 2531:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EGCItemMsg_strings[144] = {};

static const char EGCItemMsg_names[] =
  "k_EMsgGCAddItemToSocketResponse_DEPRECATED"
  "k_EMsgGCAddItemToSocket_DEPRECATED"
  "k_EMsgGCAddSocketToBaseItem_DEPRECATED"
  "k_EMsgGCAddSocketToItemResponse_DEPRECATED"
  "k_EMsgGCAddSocketToItem_DEPRECATED"
  "k_EMsgGCAdjustEquipSlots"
  "k_EMsgGCAdjustItemEquippedState"
  "k_EMsgGCAdjustItemEquippedStateMulti"
  "k_EMsgGCApplyConsumableEffects"
  "k_EMsgGCApplyEggEssence"
  "k_EMsgGCApplyPennantUpgrade"
  "k_EMsgGCApplySticker"
  "k_EMsgGCApplyStrangePart"
  "k_EMsgGCBackpackSortFinished"
  "k_EMsgGCBannedWordListRequest"
  "k_EMsgGCBannedWordListResponse"
  "k_EMsgGCBase"
  "k_EMsgGCCasketItemAdd"
  "k_EMsgGCCasketItemExtract"
  "k_EMsgGCCasketItemLoadContents"
  "k_EMsgGCClientDisplayNotification"
  "k_EMsgGCClientVersionUpdated"
  "k_EMsgGCCollectItem"
  "k_EMsgGCConsumableExhausted"
  "k_EMsgGCCraft"
  "k_EMsgGCCraftResponse"
  "k_EMsgGCCustomizeItemTexture"
  "k_EMsgGCCustomizeItemTextureResponse"
  "k_EMsgGCDelete"
  "k_EMsgGCDeliverGift"
  "k_EMsgGCDeliverGiftResponseGiver"
  "k_EMsgGCDeliverGiftResponseReceiver"
  "k_EMsgGCDev_NewItemRequest"
  "k_EMsgGCDev_NewItemRequestResponse"
  "k_EMsgGCDev_PaintKitDropItem"
  "k_EMsgGCGiftWrapItem"
  "k_EMsgGCGiftWrapItemResponse"
  "k_EMsgGCGiftedItems"
  "k_EMsgGCGiftedItems_DEPRECATED"
  "k_EMsgGCGoldenWrenchBroadcast"
  "k_EMsgGCItemAcknowledged"
  "k_EMsgGCItemAcknowledged__DEPRECATED"
  "k_EMsgGCItemCustomizationNotification"
  "k_EMsgGCItemPreviewCheckStatus"
  "k_EMsgGCItemPreviewExpire"
  "k_EMsgGCItemPreviewExpireNotification"
  "k_EMsgGCItemPreviewItemBoughtNotification"
  "k_EMsgGCItemPreviewRequest"
  "k_EMsgGCItemPreviewRequestResponse"
  "k_EMsgGCItemPreviewStatusResponse"
  "k_EMsgGCLookupAccount"
  "k_EMsgGCLookupAccountName"
  "k_EMsgGCLookupAccountNameResponse"
  "k_EMsgGCLookupAccountResponse"
  "k_EMsgGCMOTDRequest"
  "k_EMsgGCMOTDRequestResponse"
  "k_EMsgGCModifyItemAttribute"
  "k_EMsgGCNameBaseItem"
  "k_EMsgGCNameBaseItemResponse"
  "k_EMsgGCNameEggEssenceResponse"
  "k_EMsgGCNameItem"
  "k_EMsgGCNameItemNotification"
  "k_EMsgGCPaintItem"
  "k_EMsgGCPaintItemResponse"
  "k_EMsgGCPaintKitBaseItem"
  "k_EMsgGCPaintKitItem"
  "k_EMsgGCPaintKitItemResponse"
  "k_EMsgGCRecurringSubscriptionStatus"
  "k_EMsgGCRemoveCustomTexture"
  "k_EMsgGCRemoveCustomTextureResponse"
  "k_EMsgGCRemoveItemName"
  "k_EMsgGCRemoveItemPaint"
  "k_EMsgGCRemoveMakersMark"
  "k_EMsgGCRemoveMakersMarkResponse"
  "k_EMsgGCRemoveSocketItemResponse_DEPRECATED"
  "k_EMsgGCRemoveSocketItem_DEPRECATED"
  "k_EMsgGCRemoveUniqueCraftIndex"
  "k_EMsgGCRemoveUniqueCraftIndexResponse"
  "k_EMsgGCRequestAnnouncements"
  "k_EMsgGCRequestAnnouncementsResponse"
  "k_EMsgGCRequestPassportItemGrant"
  "k_EMsgGCSaxxyBroadcast"
  "k_EMsgGCServerBrowser_BlacklistServer"
  "k_EMsgGCServerBrowser_FavoriteServer"
  "k_EMsgGCServerRentalsBase"
  "k_EMsgGCServerVersionUpdated"
  "k_EMsgGCSetItemPosition"
  "k_EMsgGCSetItemPositions"
  "k_EMsgGCSetItemStyle"
  "k_EMsgGCShowItemsPickedUp"
  "k_EMsgGCSortItems"
  "k_EMsgGCStatTrakSwap"
  "k_EMsgGCStoreGetUserData"
  "k_EMsgGCStoreGetUserDataResponse"
  "k_EMsgGCStorePurchaseCancel"
  "k_EMsgGCStorePurchaseCancelResponse"
  "k_EMsgGCStorePurchaseFinalize"
  "k_EMsgGCStorePurchaseFinalizeResponse"
  "k_EMsgGCStorePurchaseInit"
  "k_EMsgGCStorePurchaseInitResponse"
  "k_EMsgGCStorePurchaseInitResponse_DEPRECATED"
  "k_EMsgGCStorePurchaseInit_DEPRECATED"
  "k_EMsgGCStorePurchaseQueryTxn"
  "k_EMsgGCStorePurchaseQueryTxnResponse"
  "k_EMsgGCToGCBannedWordListBroadcast"
  "k_EMsgGCToGCBannedWordListUpdated"
  "k_EMsgGCToGCBroadcastConsoleCommand"
  "k_EMsgGCToGCDirtyMultipleSDOCache"
  "k_EMsgGCToGCDirtySDOCache"
  "k_EMsgGCToGCIsTrustedServer"
  "k_EMsgGCToGCIsTrustedServerResponse"
  "k_EMsgGCToGCUpdateSQLKeyValue"
  "k_EMsgGCToGCWebAPIAccountChanged"
  "k_EMsgGCTradingBase"
  "k_EMsgGCTrading_CancelSession"
  "k_EMsgGCTrading_ConfirmOffer"
  "k_EMsgGCTrading_InitiateTradeRequest"
  "k_EMsgGCTrading_InitiateTradeResponse"
  "k_EMsgGCTrading_ReadinessResponse"
  "k_EMsgGCTrading_RemoveItem"
  "k_EMsgGCTrading_SessionClosed"
  "k_EMsgGCTrading_SetItem"
  "k_EMsgGCTrading_SetReadiness"
  "k_EMsgGCTrading_StartSession"
  "k_EMsgGCTrading_TradeChatMsg"
  "k_EMsgGCTrading_TradeTypingChatMsg"
  "k_EMsgGCTrading_UpdateTradeInfo"
  "k_EMsgGCUnlockCrate"
  "k_EMsgGCUnlockCrateResponse"
  "k_EMsgGCUnlockItemStyle"
  "k_EMsgGCUnlockItemStyleResponse"
  "k_EMsgGCUnwrapGiftRequest"
  "k_EMsgGCUnwrapGiftResponse"
  "k_EMsgGCUpdateItemSchema"
  "k_EMsgGCUseItemRequest"
  "k_EMsgGCUseItemResponse"
  "k_EMsgGCUsedClaimCodeItem"
  "k_EMsgGCUserTrackTimePlayedConsecutively"
  "k_EMsgGCVerifyCacheSubscription"
  "k_EMsgGC_IncrementKillCountAttribute"
  "k_EMsgGC_IncrementKillCountResponse"
  "k_EMsgGC_ReportAbuse"
  "k_EMsgGC_ReportAbuseResponse"
  "k_EMsgGC_RevolvingLootList_DEPRECATED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EGCItemMsg_entries[] = {
  { {EGCItemMsg_names + 0, 42}, 1015 },
  { {EGCItemMsg_names + 42, 34}, 1014 },
  { {EGCItemMsg_names + 76, 38}, 1016 },
  { {EGCItemMsg_names + 114, 42}, 1018 },
  { {EGCItemMsg_names + 156, 34}, 1017 },
  { {EGCItemMsg_names + 190, 24}, 2531 },
  { {EGCItemMsg_names + 214, 31}, 1059 },
  { {EGCItemMsg_names + 245, 36}, 2529 },
  { {EGCItemMsg_names + 281, 30}, 1069 },
  { {EGCItemMsg_names + 311, 23}, 1078 },
  { {EGCItemMsg_names + 334, 27}, 1076 },
  { {EGCItemMsg_names + 361, 20}, 1086 },
  { {EGCItemMsg_names + 381, 24}, 1073 },
  { {EGCItemMsg_names + 405, 28}, 1058 },
  { {EGCItemMsg_names + 433, 29}, 2512 },
  { {EGCItemMsg_names + 462, 30}, 2513 },
  { {EGCItemMsg_names + 492, 12}, 1000 },
  { {EGCItemMsg_names + 504, 21}, 1092 },
  { {EGCItemMsg_names + 525, 25}, 1093 },
  { {EGCItemMsg_names + 550, 30}, 1094 },
  { {EGCItemMsg_names + 580, 33}, 1072 },
  { {EGCItemMsg_names + 613, 28}, 2528 },
  { {EGCItemMsg_names + 641, 19}, 1061 },
  { {EGCItemMsg_names + 660, 27}, 1070 },
  { {EGCItemMsg_names + 687, 13}, 1002 },
  { {EGCItemMsg_names + 700, 21}, 1003 },
  { {EGCItemMsg_names + 721, 28}, 1023 },
  { {EGCItemMsg_names + 749, 36}, 1024 },
  { {EGCItemMsg_names + 785, 14}, 1004 },
  { {EGCItemMsg_names + 799, 19}, 1034 },
  { {EGCItemMsg_names + 818, 32}, 1035 },
  { {EGCItemMsg_names + 850, 35}, 1036 },
  { {EGCItemMsg_names + 885, 26}, 2001 },
  { {EGCItemMsg_names + 911, 34}, 2002 },
  { {EGCItemMsg_names + 945, 28}, 2003 },
  { {EGCItemMsg_names + 973, 20}, 1032 },
  { {EGCItemMsg_names + 993, 28}, 1033 },
  { {EGCItemMsg_names + 1021, 19}, 1083 },
  { {EGCItemMsg_names + 1040, 30}, 1027 },
  { {EGCItemMsg_names + 1070, 29}, 1011 },
  { {EGCItemMsg_names + 1099, 24}, 1087 },
  { {EGCItemMsg_names + 1123, 36}, 1062 },
  { {EGCItemMsg_names + 1159, 37}, 1090 },
  { {EGCItemMsg_names + 1196, 30}, 1701 },
  { {EGCItemMsg_names + 1226, 25}, 1705 },
  { {EGCItemMsg_names + 1251, 37}, 1706 },
  { {EGCItemMsg_names + 1288, 41}, 1707 },
  { {EGCItemMsg_names + 1329, 26}, 1703 },
  { {EGCItemMsg_names + 1355, 34}, 1704 },
  { {EGCItemMsg_names + 1389, 33}, 1702 },
  { {EGCItemMsg_names + 1422, 21}, 1043 },
  { {EGCItemMsg_names + 1443, 25}, 1045 },
  { {EGCItemMsg_names + 1468, 33}, 1046 },
  { {EGCItemMsg_names + 1501, 29}, 1044 },
  { {EGCItemMsg_names + 1530, 19}, 1012 },
  { {EGCItemMsg_names + 1549, 27}, 1013 },
  { {EGCItemMsg_names + 1576, 27}, 1091 },
  { {EGCItemMsg_names + 1603, 20}, 1019 },
  { {EGCItemMsg_names + 1623, 28}, 1020 },
  { {EGCItemMsg_names + 1651, 30}, 1079 },
  { {EGCItemMsg_names + 1681, 16}, 1006 },
  { {EGCItemMsg_names + 1697, 28}, 1068 },
  { {EGCItemMsg_names + 1725, 17}, 1009 },
  { {EGCItemMsg_names + 1742, 25}, 1010 },
  { {EGCItemMsg_names + 1767, 24}, 1081 },
  { {EGCItemMsg_names + 1791, 20}, 1080 },
  { {EGCItemMsg_names + 1811, 28}, 1082 },
  { {EGCItemMsg_names + 1839, 35}, 2530 },
  { {EGCItemMsg_names + 1874, 27}, 1051 },
  { {EGCItemMsg_names + 1901, 35}, 1052 },
  { {EGCItemMsg_names + 1936, 22}, 1030 },
  { {EGCItemMsg_names + 1958, 23}, 1031 },
  { {EGCItemMsg_names + 1981, 24}, 1053 },
  { {EGCItemMsg_names + 2005, 32}, 1054 },
  { {EGCItemMsg_names + 2037, 43}, 1022 },
  { {EGCItemMsg_names + 2080, 35}, 1021 },
  { {EGCItemMsg_names + 2115, 30}, 1055 },
  { {EGCItemMsg_names + 2145, 38}, 1056 },
  { {EGCItemMsg_names + 2183, 28}, 2525 },
  { {EGCItemMsg_names + 2211, 36}, 2526 },
  { {EGCItemMsg_names + 2247, 32}, 2527 },
  { {EGCItemMsg_names + 2279, 22}, 1057 },
  { {EGCItemMsg_names + 2301, 37}, 1602 },
  { {EGCItemMsg_names + 2338, 36}, 1601 },
  { {EGCItemMsg_names + 2374, 25}, 1700 },
  { {EGCItemMsg_names + 2399, 28}, 2522 },
  { {EGCItemMsg_names + 2427, 23}, 1001 },
  { {EGCItemMsg_names + 2450, 24}, 1077 },
  { {EGCItemMsg_names + 2474, 20}, 1039 },
  { {EGCItemMsg_names + 2494, 25}, 1071 },
  { {EGCItemMsg_names + 2519, 17}, 1041 },
  { {EGCItemMsg_names + 2536, 20}, 1088 },
  { {EGCItemMsg_names + 2556, 24}, 2500 },
  { {EGCItemMsg_names + 2580, 32}, 2501 },
  { {EGCItemMsg_names + 2612, 27}, 2506 },
  { {EGCItemMsg_names + 2639, 35}, 2507 },
  { {EGCItemMsg_names + 2674, 29}, 2504 },
  { {EGCItemMsg_names + 2703, 37}, 2505 },
  { {EGCItemMsg_names + 2740, 25}, 2510 },
  { {EGCItemMsg_names + 2765, 33}, 2511 },
  { {EGCItemMsg_names + 2798, 44}, 2503 },
  { {EGCItemMsg_names + 2842, 36}, 2502 },
  { {EGCItemMsg_names + 2878, 29}, 2508 },
  { {EGCItemMsg_names + 2907, 37}, 2509 },
  { {EGCItemMsg_names + 2944, 35}, 2514 },
  { {EGCItemMsg_names + 2979, 33}, 2515 },
  { {EGCItemMsg_names + 3012, 35}, 2521 },
  { {EGCItemMsg_names + 3047, 33}, 2517 },
  { {EGCItemMsg_names + 3080, 25}, 2516 },
  { {EGCItemMsg_names + 3105, 27}, 2519 },
  { {EGCItemMsg_names + 3132, 35}, 2520 },
  { {EGCItemMsg_names + 3167, 29}, 2518 },
  { {EGCItemMsg_names + 3196, 32}, 2524 },
  { {EGCItemMsg_names + 3228, 19}, 1500 },
  { {EGCItemMsg_names + 3247, 29}, 1510 },
  { {EGCItemMsg_names + 3276, 28}, 1512 },
  { {EGCItemMsg_names + 3304, 36}, 1501 },
  { {EGCItemMsg_names + 3340, 37}, 1502 },
  { {EGCItemMsg_names + 3377, 33}, 1508 },
  { {EGCItemMsg_names + 3410, 26}, 1505 },
  { {EGCItemMsg_names + 3436, 29}, 1509 },
  { {EGCItemMsg_names + 3465, 23}, 1504 },
  { {EGCItemMsg_names + 3488, 28}, 1507 },
  { {EGCItemMsg_names + 3516, 28}, 1503 },
  { {EGCItemMsg_names + 3544, 28}, 1511 },
  { {EGCItemMsg_names + 3572, 34}, 1513 },
  { {EGCItemMsg_names + 3606, 31}, 1506 },
  { {EGCItemMsg_names + 3637, 19}, 1007 },
  { {EGCItemMsg_names + 3656, 27}, 1008 },
  { {EGCItemMsg_names + 3683, 23}, 1084 },
  { {EGCItemMsg_names + 3706, 31}, 1085 },
  { {EGCItemMsg_names + 3737, 25}, 1037 },
  { {EGCItemMsg_names + 3762, 26}, 1038 },
  { {EGCItemMsg_names + 3788, 24}, 1049 },
  { {EGCItemMsg_names + 3812, 22}, 1025 },
  { {EGCItemMsg_names + 3834, 23}, 1026 },
  { {EGCItemMsg_names + 3857, 25}, 1040 },
  { {EGCItemMsg_names + 3882, 40}, 1089 },
  { {EGCItemMsg_names + 3922, 31}, 1005 },
  { {EGCItemMsg_names + 3953, 36}, 1074 },
  { {EGCItemMsg_names + 3989, 35}, 1075 },
  { {EGCItemMsg_names + 4024, 20}, 1065 },
  { {EGCItemMsg_names + 4044, 28}, 1066 },
  { {EGCItemMsg_names + 4072, 37}, 1042 },
};

static const int EGCItemMsg_entries_by_number[] = {
  16, // 1000 -> k_EMsgGCBase
  86, // 1001 -> k_EMsgGCSetItemPosition
  24, // 1002 -> k_EMsgGCCraft
  25, // 1003 -> k_EMsgGCCraftResponse
  28, // 1004 -> k_EMsgGCDelete
  138, // 1005 -> k_EMsgGCVerifyCacheSubscription
  60, // 1006 -> k_EMsgGCNameItem
  127, // 1007 -> k_EMsgGCUnlockCrate
  128, // 1008 -> k_EMsgGCUnlockCrateResponse
  62, // 1009 -> k_EMsgGCPaintItem
  63, // 1010 -> k_EMsgGCPaintItemResponse
  39, // 1011 -> k_EMsgGCGoldenWrenchBroadcast
  54, // 1012 -> k_EMsgGCMOTDRequest
  55, // 1013 -> k_EMsgGCMOTDRequestResponse
  1, // 1014 -> k_EMsgGCAddItemToSocket_DEPRECATED
  0, // 1015 -> k_EMsgGCAddItemToSocketResponse_DEPRECATED
  2, // 1016 -> k_EMsgGCAddSocketToBaseItem_DEPRECATED
  4, // 1017 -> k_EMsgGCAddSocketToItem_DEPRECATED
  3, // 1018 -> k_EMsgGCAddSocketToItemResponse_DEPRECATED
  57, // 1019 -> k_EMsgGCNameBaseItem
  58, // 1020 -> k_EMsgGCNameBaseItemResponse
  75, // 1021 -> k_EMsgGCRemoveSocketItem_DEPRECATED
  74, // 1022 -> k_EMsgGCRemoveSocketItemResponse_DEPRECATED
  26, // 1023 -> k_EMsgGCCustomizeItemTexture
  27, // 1024 -> k_EMsgGCCustomizeItemTextureResponse
  134, // 1025 -> k_EMsgGCUseItemRequest
  135, // 1026 -> k_EMsgGCUseItemResponse
  38, // 1027 -> k_EMsgGCGiftedItems_DEPRECATED
  70, // 1030 -> k_EMsgGCRemoveItemName
  71, // 1031 -> k_EMsgGCRemoveItemPaint
  35, // 1032 -> k_EMsgGCGiftWrapItem
  36, // 1033 -> k_EMsgGCGiftWrapItemResponse
  29, // 1034 -> k_EMsgGCDeliverGift
  30, // 1035 -> k_EMsgGCDeliverGiftResponseGiver
  31, // 1036 -> k_EMsgGCDeliverGiftResponseReceiver
  131, // 1037 -> k_EMsgGCUnwrapGiftRequest
  132, // 1038 -> k_EMsgGCUnwrapGiftResponse
  88, // 1039 -> k_EMsgGCSetItemStyle
  136, // 1040 -> k_EMsgGCUsedClaimCodeItem
  90, // 1041 -> k_EMsgGCSortItems
  143, // 1042 -> k_EMsgGC_RevolvingLootList_DEPRECATED
  50, // 1043 -> k_EMsgGCLookupAccount
  53, // 1044 -> k_EMsgGCLookupAccountResponse
  51, // 1045 -> k_EMsgGCLookupAccountName
  52, // 1046 -> k_EMsgGCLookupAccountNameResponse
  133, // 1049 -> k_EMsgGCUpdateItemSchema
  68, // 1051 -> k_EMsgGCRemoveCustomTexture
  69, // 1052 -> k_EMsgGCRemoveCustomTextureResponse
  72, // 1053 -> k_EMsgGCRemoveMakersMark
  73, // 1054 -> k_EMsgGCRemoveMakersMarkResponse
  76, // 1055 -> k_EMsgGCRemoveUniqueCraftIndex
  77, // 1056 -> k_EMsgGCRemoveUniqueCraftIndexResponse
  81, // 1057 -> k_EMsgGCSaxxyBroadcast
  13, // 1058 -> k_EMsgGCBackpackSortFinished
  6, // 1059 -> k_EMsgGCAdjustItemEquippedState
  22, // 1061 -> k_EMsgGCCollectItem
  41, // 1062 -> k_EMsgGCItemAcknowledged__DEPRECATED
  141, // 1065 -> k_EMsgGC_ReportAbuse
  142, // 1066 -> k_EMsgGC_ReportAbuseResponse
  61, // 1068 -> k_EMsgGCNameItemNotification
  8, // 1069 -> k_EMsgGCApplyConsumableEffects
  23, // 1070 -> k_EMsgGCConsumableExhausted
  89, // 1071 -> k_EMsgGCShowItemsPickedUp
  20, // 1072 -> k_EMsgGCClientDisplayNotification
  12, // 1073 -> k_EMsgGCApplyStrangePart
  139, // 1074 -> k_EMsgGC_IncrementKillCountAttribute
  140, // 1075 -> k_EMsgGC_IncrementKillCountResponse
  10, // 1076 -> k_EMsgGCApplyPennantUpgrade
  87, // 1077 -> k_EMsgGCSetItemPositions
  9, // 1078 -> k_EMsgGCApplyEggEssence
  59, // 1079 -> k_EMsgGCNameEggEssenceResponse
  65, // 1080 -> k_EMsgGCPaintKitItem
  64, // 1081 -> k_EMsgGCPaintKitBaseItem
  66, // 1082 -> k_EMsgGCPaintKitItemResponse
  37, // 1083 -> k_EMsgGCGiftedItems
  129, // 1084 -> k_EMsgGCUnlockItemStyle
  130, // 1085 -> k_EMsgGCUnlockItemStyleResponse
  11, // 1086 -> k_EMsgGCApplySticker
  40, // 1087 -> k_EMsgGCItemAcknowledged
  91, // 1088 -> k_EMsgGCStatTrakSwap
  137, // 1089 -> k_EMsgGCUserTrackTimePlayedConsecutively
  42, // 1090 -> k_EMsgGCItemCustomizationNotification
  56, // 1091 -> k_EMsgGCModifyItemAttribute
  17, // 1092 -> k_EMsgGCCasketItemAdd
  18, // 1093 -> k_EMsgGCCasketItemExtract
  19, // 1094 -> k_EMsgGCCasketItemLoadContents
  113, // 1500 -> k_EMsgGCTradingBase
  116, // 1501 -> k_EMsgGCTrading_InitiateTradeRequest
  117, // 1502 -> k_EMsgGCTrading_InitiateTradeResponse
  123, // 1503 -> k_EMsgGCTrading_StartSession
  121, // 1504 -> k_EMsgGCTrading_SetItem
  119, // 1505 -> k_EMsgGCTrading_RemoveItem
  126, // 1506 -> k_EMsgGCTrading_UpdateTradeInfo
  122, // 1507 -> k_EMsgGCTrading_SetReadiness
  118, // 1508 -> k_EMsgGCTrading_ReadinessResponse
  120, // 1509 -> k_EMsgGCTrading_SessionClosed
  114, // 1510 -> k_EMsgGCTrading_CancelSession
  124, // 1511 -> k_EMsgGCTrading_TradeChatMsg
  115, // 1512 -> k_EMsgGCTrading_ConfirmOffer
  125, // 1513 -> k_EMsgGCTrading_TradeTypingChatMsg
  83, // 1601 -> k_EMsgGCServerBrowser_FavoriteServer
  82, // 1602 -> k_EMsgGCServerBrowser_BlacklistServer
  84, // 1700 -> k_EMsgGCServerRentalsBase
  43, // 1701 -> k_EMsgGCItemPreviewCheckStatus
  49, // 1702 -> k_EMsgGCItemPreviewStatusResponse
  47, // 1703 -> k_EMsgGCItemPreviewRequest
  48, // 1704 -> k_EMsgGCItemPreviewRequestResponse
  44, // 1705 -> k_EMsgGCItemPreviewExpire
  45, // 1706 -> k_EMsgGCItemPreviewExpireNotification
  46, // 1707 -> k_EMsgGCItemPreviewItemBoughtNotification
  32, // 2001 -> k_EMsgGCDev_NewItemRequest
  33, // 2002 -> k_EMsgGCDev_NewItemRequestResponse
  34, // 2003 -> k_EMsgGCDev_PaintKitDropItem
  92, // 2500 -> k_EMsgGCStoreGetUserData
  93, // 2501 -> k_EMsgGCStoreGetUserDataResponse
  101, // 2502 -> k_EMsgGCStorePurchaseInit_DEPRECATED
  100, // 2503 -> k_EMsgGCStorePurchaseInitResponse_DEPRECATED
  96, // 2504 -> k_EMsgGCStorePurchaseFinalize
  97, // 2505 -> k_EMsgGCStorePurchaseFinalizeResponse
  94, // 2506 -> k_EMsgGCStorePurchaseCancel
  95, // 2507 -> k_EMsgGCStorePurchaseCancelResponse
  102, // 2508 -> k_EMsgGCStorePurchaseQueryTxn
  103, // 2509 -> k_EMsgGCStorePurchaseQueryTxnResponse
  98, // 2510 -> k_EMsgGCStorePurchaseInit
  99, // 2511 -> k_EMsgGCStorePurchaseInitResponse
  14, // 2512 -> k_EMsgGCBannedWordListRequest
  15, // 2513 -> k_EMsgGCBannedWordListResponse
  104, // 2514 -> k_EMsgGCToGCBannedWordListBroadcast
  105, // 2515 -> k_EMsgGCToGCBannedWordListUpdated
  108, // 2516 -> k_EMsgGCToGCDirtySDOCache
  107, // 2517 -> k_EMsgGCToGCDirtyMultipleSDOCache
  111, // 2518 -> k_EMsgGCToGCUpdateSQLKeyValue
  109, // 2519 -> k_EMsgGCToGCIsTrustedServer
  110, // 2520 -> k_EMsgGCToGCIsTrustedServerResponse
  106, // 2521 -> k_EMsgGCToGCBroadcastConsoleCommand
  85, // 2522 -> k_EMsgGCServerVersionUpdated
  112, // 2524 -> k_EMsgGCToGCWebAPIAccountChanged
  78, // 2525 -> k_EMsgGCRequestAnnouncements
  79, // 2526 -> k_EMsgGCRequestAnnouncementsResponse
  80, // 2527 -> k_EMsgGCRequestPassportItemGrant
  21, // 2528 -> k_EMsgGCClientVersionUpdated
  7, // 2529 -> k_EMsgGCAdjustItemEquippedStateMulti
  67, // 2530 -> k_EMsgGCRecurringSubscriptionStatus
  5, // 2531 -> k_EMsgGCAdjustEquipSlots
};

const std::string& EGCItemMsg_Name(
    EGCItemMsg value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EGCItemMsg_entries,
          EGCItemMsg_entries_by_number,
          144, EGCItemMsg_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EGCItemMsg_entries,
      EGCItemMsg_entries_by_number,
      144, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EGCItemMsg_strings[idx].get();
}
bool EGCItemMsg_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EGCItemMsg* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EGCItemMsg_entries, 144, name, &int_value);
  if (success) {
    *value = static_cast<EGCItemMsg>(int_value);
  }
  return success;
}
bool EGCMsgResponse_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EGCMsgResponse_strings[11] = {};

static const char EGCMsgResponse_names[] =
  "k_EGCMsgCommitUnfinalized"
  "k_EGCMsgFailedToCreate"
  "k_EGCMsgLimitExceeded"
  "k_EGCMsgResponseDenied"
  "k_EGCMsgResponseInvalid"
  "k_EGCMsgResponseNoMatch"
  "k_EGCMsgResponseNotLoggedOn"
  "k_EGCMsgResponseOK"
  "k_EGCMsgResponseServerError"
  "k_EGCMsgResponseTimeout"
  "k_EGCMsgResponseUnknownError";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EGCMsgResponse_entries[] = {
  { {EGCMsgResponse_names + 0, 25}, 10 },
  { {EGCMsgResponse_names + 25, 22}, 8 },
  { {EGCMsgResponse_names + 47, 21}, 9 },
  { {EGCMsgResponse_names + 68, 22}, 1 },
  { {EGCMsgResponse_names + 90, 23}, 4 },
  { {EGCMsgResponse_names + 113, 23}, 5 },
  { {EGCMsgResponse_names + 136, 27}, 7 },
  { {EGCMsgResponse_names + 163, 18}, 0 },
  { {EGCMsgResponse_names + 181, 27}, 2 },
  { {EGCMsgResponse_names + 208, 23}, 3 },
  { {EGCMsgResponse_names + 231, 28}, 6 },
};

static const int EGCMsgResponse_entries_by_number[] = {
  7, // 0 -> k_EGCMsgResponseOK
  3, // 1 -> k_EGCMsgResponseDenied
  8, // 2 -> k_EGCMsgResponseServerError
  9, // 3 -> k_EGCMsgResponseTimeout
  4, // 4 -> k_EGCMsgResponseInvalid
  5, // 5 -> k_EGCMsgResponseNoMatch
  10, // 6 -> k_EGCMsgResponseUnknownError
  6, // 7 -> k_EGCMsgResponseNotLoggedOn
  1, // 8 -> k_EGCMsgFailedToCreate
  2, // 9 -> k_EGCMsgLimitExceeded
  0, // 10 -> k_EGCMsgCommitUnfinalized
};

const std::string& EGCMsgResponse_Name(
    EGCMsgResponse value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EGCMsgResponse_entries,
          EGCMsgResponse_entries_by_number,
          11, EGCMsgResponse_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EGCMsgResponse_entries,
      EGCMsgResponse_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EGCMsgResponse_strings[idx].get();
}
bool EGCMsgResponse_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EGCMsgResponse* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EGCMsgResponse_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<EGCMsgResponse>(int_value);
  }
  return success;
}
bool EUnlockStyle_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EUnlockStyle_strings[6] = {};

static const char EUnlockStyle_names[] =
  "k_UnlockStyle_Failed_CantAfford"
  "k_UnlockStyle_Failed_CantAffordAttrib"
  "k_UnlockStyle_Failed_CantCommit"
  "k_UnlockStyle_Failed_CantLockCache"
  "k_UnlockStyle_Failed_PreReq"
  "k_UnlockStyle_Succeeded";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EUnlockStyle_entries[] = {
  { {EUnlockStyle_names + 0, 31}, 2 },
  { {EUnlockStyle_names + 31, 37}, 5 },
  { {EUnlockStyle_names + 68, 31}, 3 },
  { {EUnlockStyle_names + 99, 34}, 4 },
  { {EUnlockStyle_names + 133, 27}, 1 },
  { {EUnlockStyle_names + 160, 23}, 0 },
};

static const int EUnlockStyle_entries_by_number[] = {
  5, // 0 -> k_UnlockStyle_Succeeded
  4, // 1 -> k_UnlockStyle_Failed_PreReq
  0, // 2 -> k_UnlockStyle_Failed_CantAfford
  2, // 3 -> k_UnlockStyle_Failed_CantCommit
  3, // 4 -> k_UnlockStyle_Failed_CantLockCache
  1, // 5 -> k_UnlockStyle_Failed_CantAffordAttrib
};

const std::string& EUnlockStyle_Name(
    EUnlockStyle value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EUnlockStyle_entries,
          EUnlockStyle_entries_by_number,
          6, EUnlockStyle_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EUnlockStyle_entries,
      EUnlockStyle_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EUnlockStyle_strings[idx].get();
}
bool EUnlockStyle_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EUnlockStyle* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EUnlockStyle_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<EUnlockStyle>(int_value);
  }
  return success;
}
bool EGCItemCustomizationNotification_IsValid(int value) {
  switch (value) {
    case 1006:
    case 1007:
    case 1008:
    case 1009:
    case 1011:
    case 1012:
    case 1013:
    case 1014:
    case 1015:
    case 1019:
    case 1030:
    case 1053:
    case 1086:
    case 1088:
    case 1089:
    case 1090:
    case 9178:
    case 9179:
    case 9185:
    case 9204:
    case 9209:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EGCItemCustomizationNotification_strings[21] = {};

static const char EGCItemCustomizationNotification_names[] =
  "k_EGCItemCustomizationNotification_ActivateFanToken"
  "k_EGCItemCustomizationNotification_ActivateOperationCoin"
  "k_EGCItemCustomizationNotification_ApplyPatch"
  "k_EGCItemCustomizationNotification_ApplySticker"
  "k_EGCItemCustomizationNotification_CasketAdded"
  "k_EGCItemCustomizationNotification_CasketContents"
  "k_EGCItemCustomizationNotification_CasketInvFull"
  "k_EGCItemCustomizationNotification_CasketRemoved"
  "k_EGCItemCustomizationNotification_CasketTooFull"
  "k_EGCItemCustomizationNotification_ClientRedeemMissionReward"
  "k_EGCItemCustomizationNotification_GenerateSouvenir"
  "k_EGCItemCustomizationNotification_GraffitiUnseal"
  "k_EGCItemCustomizationNotification_NameBaseItem"
  "k_EGCItemCustomizationNotification_NameItem"
  "k_EGCItemCustomizationNotification_RemoveItemName"
  "k_EGCItemCustomizationNotification_RemovePatch"
  "k_EGCItemCustomizationNotification_RemoveSticker"
  "k_EGCItemCustomizationNotification_StatTrakSwap"
  "k_EGCItemCustomizationNotification_UnlockCrate"
  "k_EGCItemCustomizationNotification_XRayItemClaim"
  "k_EGCItemCustomizationNotification_XRayItemReveal";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EGCItemCustomizationNotification_entries[] = {
  { {EGCItemCustomizationNotification_names + 0, 51}, 9178 },
  { {EGCItemCustomizationNotification_names + 51, 56}, 9179 },
  { {EGCItemCustomizationNotification_names + 107, 45}, 1090 },
  { {EGCItemCustomizationNotification_names + 152, 47}, 1086 },
  { {EGCItemCustomizationNotification_names + 199, 46}, 1013 },
  { {EGCItemCustomizationNotification_names + 245, 49}, 1012 },
  { {EGCItemCustomizationNotification_names + 294, 48}, 1015 },
  { {EGCItemCustomizationNotification_names + 342, 48}, 1014 },
  { {EGCItemCustomizationNotification_names + 390, 48}, 1011 },
  { {EGCItemCustomizationNotification_names + 438, 60}, 9209 },
  { {EGCItemCustomizationNotification_names + 498, 51}, 9204 },
  { {EGCItemCustomizationNotification_names + 549, 49}, 9185 },
  { {EGCItemCustomizationNotification_names + 598, 47}, 1019 },
  { {EGCItemCustomizationNotification_names + 645, 43}, 1006 },
  { {EGCItemCustomizationNotification_names + 688, 49}, 1030 },
  { {EGCItemCustomizationNotification_names + 737, 46}, 1089 },
  { {EGCItemCustomizationNotification_names + 783, 48}, 1053 },
  { {EGCItemCustomizationNotification_names + 831, 47}, 1088 },
  { {EGCItemCustomizationNotification_names + 878, 46}, 1007 },
  { {EGCItemCustomizationNotification_names + 924, 48}, 1009 },
  { {EGCItemCustomizationNotification_names + 972, 49}, 1008 },
};

static const int EGCItemCustomizationNotification_entries_by_number[] = {
  13, // 1006 -> k_EGCItemCustomizationNotification_NameItem
  18, // 1007 -> k_EGCItemCustomizationNotification_UnlockCrate
  20, // 1008 -> k_EGCItemCustomizationNotification_XRayItemReveal
  19, // 1009 -> k_EGCItemCustomizationNotification_XRayItemClaim
  8, // 1011 -> k_EGCItemCustomizationNotification_CasketTooFull
  5, // 1012 -> k_EGCItemCustomizationNotification_CasketContents
  4, // 1013 -> k_EGCItemCustomizationNotification_CasketAdded
  7, // 1014 -> k_EGCItemCustomizationNotification_CasketRemoved
  6, // 1015 -> k_EGCItemCustomizationNotification_CasketInvFull
  12, // 1019 -> k_EGCItemCustomizationNotification_NameBaseItem
  14, // 1030 -> k_EGCItemCustomizationNotification_RemoveItemName
  16, // 1053 -> k_EGCItemCustomizationNotification_RemoveSticker
  3, // 1086 -> k_EGCItemCustomizationNotification_ApplySticker
  17, // 1088 -> k_EGCItemCustomizationNotification_StatTrakSwap
  15, // 1089 -> k_EGCItemCustomizationNotification_RemovePatch
  2, // 1090 -> k_EGCItemCustomizationNotification_ApplyPatch
  0, // 9178 -> k_EGCItemCustomizationNotification_ActivateFanToken
  1, // 9179 -> k_EGCItemCustomizationNotification_ActivateOperationCoin
  11, // 9185 -> k_EGCItemCustomizationNotification_GraffitiUnseal
  10, // 9204 -> k_EGCItemCustomizationNotification_GenerateSouvenir
  9, // 9209 -> k_EGCItemCustomizationNotification_ClientRedeemMissionReward
};

const std::string& EGCItemCustomizationNotification_Name(
    EGCItemCustomizationNotification value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EGCItemCustomizationNotification_entries,
          EGCItemCustomizationNotification_entries_by_number,
          21, EGCItemCustomizationNotification_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EGCItemCustomizationNotification_entries,
      EGCItemCustomizationNotification_entries_by_number,
      21, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EGCItemCustomizationNotification_strings[idx].get();
}
bool EGCItemCustomizationNotification_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EGCItemCustomizationNotification* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EGCItemCustomizationNotification_entries, 21, name, &int_value);
  if (success) {
    *value = static_cast<EGCItemCustomizationNotification>(int_value);
  }
  return success;
}

// ===================================================================

class CMsgGCGiftedItems::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCGiftedItems>()._impl_._has_bits_);
  static void set_has_accountid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_giftdefindex(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_gifts_possible(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_num_eligible_recipients(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgGCGiftedItems::CMsgGCGiftedItems(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCGiftedItems)
}
CMsgGCGiftedItems::CMsgGCGiftedItems(const CMsgGCGiftedItems& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCGiftedItems* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.recipients_accountids_){from._impl_.recipients_accountids_}
    , decltype(_impl_.accountid_){}
    , decltype(_impl_.giftdefindex_){}
    , decltype(_impl_.max_gifts_possible_){}
    , decltype(_impl_.num_eligible_recipients_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.accountid_, &from._impl_.accountid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_eligible_recipients_) -
    reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.num_eligible_recipients_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCGiftedItems)
}

inline void CMsgGCGiftedItems::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.recipients_accountids_){arena}
    , decltype(_impl_.accountid_){0u}
    , decltype(_impl_.giftdefindex_){0u}
    , decltype(_impl_.max_gifts_possible_){0u}
    , decltype(_impl_.num_eligible_recipients_){0u}
  };
}

CMsgGCGiftedItems::~CMsgGCGiftedItems() {
  // @@protoc_insertion_point(destructor:CMsgGCGiftedItems)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCGiftedItems::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.recipients_accountids_.~RepeatedField();
}

void CMsgGCGiftedItems::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCGiftedItems::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCGiftedItems)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.recipients_accountids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.accountid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.num_eligible_recipients_) -
        reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.num_eligible_recipients_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCGiftedItems::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 accountid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_accountid(&has_bits);
          _impl_.accountid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 giftdefindex = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_giftdefindex(&has_bits);
          _impl_.giftdefindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 max_gifts_possible = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_max_gifts_possible(&has_bits);
          _impl_.max_gifts_possible_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_eligible_recipients = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_num_eligible_recipients(&has_bits);
          _impl_.num_eligible_recipients_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 recipients_accountids = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_recipients_accountids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_recipients_accountids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCGiftedItems::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCGiftedItems)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 accountid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_accountid(), target);
  }

  // optional uint32 giftdefindex = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_giftdefindex(), target);
  }

  // optional uint32 max_gifts_possible = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_max_gifts_possible(), target);
  }

  // optional uint32 num_eligible_recipients = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_num_eligible_recipients(), target);
  }

  // repeated uint32 recipients_accountids = 5;
  for (int i = 0, n = this->_internal_recipients_accountids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_recipients_accountids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCGiftedItems)
  return target;
}

size_t CMsgGCGiftedItems::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCGiftedItems)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 recipients_accountids = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.recipients_accountids_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_recipients_accountids_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 accountid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_accountid());
    }

    // optional uint32 giftdefindex = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_giftdefindex());
    }

    // optional uint32 max_gifts_possible = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_gifts_possible());
    }

    // optional uint32 num_eligible_recipients = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_eligible_recipients());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCGiftedItems::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCGiftedItems*>(
      &from));
}

void CMsgGCGiftedItems::MergeFrom(const CMsgGCGiftedItems& from) {
  CMsgGCGiftedItems* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCGiftedItems)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.recipients_accountids_.MergeFrom(from._impl_.recipients_accountids_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.accountid_ = from._impl_.accountid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.giftdefindex_ = from._impl_.giftdefindex_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.max_gifts_possible_ = from._impl_.max_gifts_possible_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.num_eligible_recipients_ = from._impl_.num_eligible_recipients_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCGiftedItems::CopyFrom(const CMsgGCGiftedItems& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCGiftedItems)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCGiftedItems::IsInitialized() const {
  return true;
}

void CMsgGCGiftedItems::InternalSwap(CMsgGCGiftedItems* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.recipients_accountids_.InternalSwap(&other->_impl_.recipients_accountids_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCGiftedItems, _impl_.num_eligible_recipients_)
      + sizeof(CMsgGCGiftedItems::_impl_.num_eligible_recipients_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCGiftedItems, _impl_.accountid_)>(
          reinterpret_cast<char*>(&_impl_.accountid_),
          reinterpret_cast<char*>(&other->_impl_.accountid_));
}

std::string CMsgGCGiftedItems::GetTypeName() const {
  return "CMsgGCGiftedItems";
}


// ===================================================================

class CMsgCasketItem::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgCasketItem>()._impl_._has_bits_);
  static void set_has_casket_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_item_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgCasketItem::CMsgCasketItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgCasketItem)
}
CMsgCasketItem::CMsgCasketItem(const CMsgCasketItem& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgCasketItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.casket_item_id_){}
    , decltype(_impl_.item_item_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.casket_item_id_, &from._impl_.casket_item_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.item_item_id_) -
    reinterpret_cast<char*>(&_impl_.casket_item_id_)) + sizeof(_impl_.item_item_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgCasketItem)
}

inline void CMsgCasketItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.casket_item_id_){uint64_t{0u}}
    , decltype(_impl_.item_item_id_){uint64_t{0u}}
  };
}

CMsgCasketItem::~CMsgCasketItem() {
  // @@protoc_insertion_point(destructor:CMsgCasketItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgCasketItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgCasketItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgCasketItem::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgCasketItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.casket_item_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.item_item_id_) -
        reinterpret_cast<char*>(&_impl_.casket_item_id_)) + sizeof(_impl_.item_item_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgCasketItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 casket_item_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_casket_item_id(&has_bits);
          _impl_.casket_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 item_item_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_item_item_id(&has_bits);
          _impl_.item_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgCasketItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgCasketItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 casket_item_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_casket_item_id(), target);
  }

  // optional uint64 item_item_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_item_item_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgCasketItem)
  return target;
}

size_t CMsgCasketItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgCasketItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 casket_item_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_casket_item_id());
    }

    // optional uint64 item_item_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_item_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgCasketItem::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgCasketItem*>(
      &from));
}

void CMsgCasketItem::MergeFrom(const CMsgCasketItem& from) {
  CMsgCasketItem* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgCasketItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.casket_item_id_ = from._impl_.casket_item_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.item_item_id_ = from._impl_.item_item_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgCasketItem::CopyFrom(const CMsgCasketItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgCasketItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgCasketItem::IsInitialized() const {
  return true;
}

void CMsgCasketItem::InternalSwap(CMsgCasketItem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgCasketItem, _impl_.item_item_id_)
      + sizeof(CMsgCasketItem::_impl_.item_item_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgCasketItem, _impl_.casket_item_id_)>(
          reinterpret_cast<char*>(&_impl_.casket_item_id_),
          reinterpret_cast<char*>(&other->_impl_.casket_item_id_));
}

std::string CMsgCasketItem::GetTypeName() const {
  return "CMsgCasketItem";
}


// ===================================================================

class CMsgGCUserTrackTimePlayedConsecutively::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCUserTrackTimePlayedConsecutively>()._impl_._has_bits_);
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCUserTrackTimePlayedConsecutively::CMsgGCUserTrackTimePlayedConsecutively(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCUserTrackTimePlayedConsecutively)
}
CMsgGCUserTrackTimePlayedConsecutively::CMsgGCUserTrackTimePlayedConsecutively(const CMsgGCUserTrackTimePlayedConsecutively& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCUserTrackTimePlayedConsecutively* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.state_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.state_ = from._impl_.state_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCUserTrackTimePlayedConsecutively)
}

inline void CMsgGCUserTrackTimePlayedConsecutively::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.state_){0u}
  };
}

CMsgGCUserTrackTimePlayedConsecutively::~CMsgGCUserTrackTimePlayedConsecutively() {
  // @@protoc_insertion_point(destructor:CMsgGCUserTrackTimePlayedConsecutively)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCUserTrackTimePlayedConsecutively::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCUserTrackTimePlayedConsecutively::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCUserTrackTimePlayedConsecutively::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCUserTrackTimePlayedConsecutively)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.state_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCUserTrackTimePlayedConsecutively::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_state(&has_bits);
          _impl_.state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCUserTrackTimePlayedConsecutively::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCUserTrackTimePlayedConsecutively)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 state = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCUserTrackTimePlayedConsecutively)
  return target;
}

size_t CMsgGCUserTrackTimePlayedConsecutively::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCUserTrackTimePlayedConsecutively)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 state = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_state());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCUserTrackTimePlayedConsecutively::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCUserTrackTimePlayedConsecutively*>(
      &from));
}

void CMsgGCUserTrackTimePlayedConsecutively::MergeFrom(const CMsgGCUserTrackTimePlayedConsecutively& from) {
  CMsgGCUserTrackTimePlayedConsecutively* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCUserTrackTimePlayedConsecutively)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_state()) {
    _this->_internal_set_state(from._internal_state());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCUserTrackTimePlayedConsecutively::CopyFrom(const CMsgGCUserTrackTimePlayedConsecutively& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCUserTrackTimePlayedConsecutively)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCUserTrackTimePlayedConsecutively::IsInitialized() const {
  return true;
}

void CMsgGCUserTrackTimePlayedConsecutively::InternalSwap(CMsgGCUserTrackTimePlayedConsecutively* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.state_, other->_impl_.state_);
}

std::string CMsgGCUserTrackTimePlayedConsecutively::GetTypeName() const {
  return "CMsgGCUserTrackTimePlayedConsecutively";
}


// ===================================================================

class CMsgGCItemCustomizationNotification::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCItemCustomizationNotification>()._impl_._has_bits_);
  static void set_has_request(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCItemCustomizationNotification::CMsgGCItemCustomizationNotification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCItemCustomizationNotification)
}
CMsgGCItemCustomizationNotification::CMsgGCItemCustomizationNotification(const CMsgGCItemCustomizationNotification& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCItemCustomizationNotification* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_id_){from._impl_.item_id_}
    , decltype(_impl_.request_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.request_ = from._impl_.request_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCItemCustomizationNotification)
}

inline void CMsgGCItemCustomizationNotification::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_id_){arena}
    , decltype(_impl_.request_){0u}
  };
}

CMsgGCItemCustomizationNotification::~CMsgGCItemCustomizationNotification() {
  // @@protoc_insertion_point(destructor:CMsgGCItemCustomizationNotification)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCItemCustomizationNotification::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.item_id_.~RepeatedField();
}

void CMsgGCItemCustomizationNotification::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCItemCustomizationNotification::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCItemCustomizationNotification)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.item_id_.Clear();
  _impl_.request_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCItemCustomizationNotification::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 item_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_item_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_item_id(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 request = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_request(&has_bits);
          _impl_.request_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCItemCustomizationNotification::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCItemCustomizationNotification)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 item_id = 1;
  for (int i = 0, n = this->_internal_item_id_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_item_id(i), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 request = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_request(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCItemCustomizationNotification)
  return target;
}

size_t CMsgGCItemCustomizationNotification::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCItemCustomizationNotification)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 item_id = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.item_id_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_item_id_size());
    total_size += data_size;
  }

  // optional uint32 request = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_request());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCItemCustomizationNotification::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCItemCustomizationNotification*>(
      &from));
}

void CMsgGCItemCustomizationNotification::MergeFrom(const CMsgGCItemCustomizationNotification& from) {
  CMsgGCItemCustomizationNotification* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCItemCustomizationNotification)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.item_id_.MergeFrom(from._impl_.item_id_);
  if (from._internal_has_request()) {
    _this->_internal_set_request(from._internal_request());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCItemCustomizationNotification::CopyFrom(const CMsgGCItemCustomizationNotification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCItemCustomizationNotification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCItemCustomizationNotification::IsInitialized() const {
  return true;
}

void CMsgGCItemCustomizationNotification::InternalSwap(CMsgGCItemCustomizationNotification* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.item_id_.InternalSwap(&other->_impl_.item_id_);
  swap(_impl_.request_, other->_impl_.request_);
}

std::string CMsgGCItemCustomizationNotification::GetTypeName() const {
  return "CMsgGCItemCustomizationNotification";
}


// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CMsgGCGiftedItems*
Arena::CreateMaybeMessage< ::CMsgGCGiftedItems >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCGiftedItems >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgCasketItem*
Arena::CreateMaybeMessage< ::CMsgCasketItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgCasketItem >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCUserTrackTimePlayedConsecutively*
Arena::CreateMaybeMessage< ::CMsgGCUserTrackTimePlayedConsecutively >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCUserTrackTimePlayedConsecutively >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCItemCustomizationNotification*
Arena::CreateMaybeMessage< ::CMsgGCItemCustomizationNotification >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCItemCustomizationNotification >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
