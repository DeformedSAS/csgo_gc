// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steammessages.proto

#include "steammessages.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR CMsgProtoBufHeader::CMsgProtoBufHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.target_job_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.error_message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.client_steam_id_)*/uint64_t{0u}
  , /*decltype(_impl_.client_session_id_)*/0
  , /*decltype(_impl_.source_app_id_)*/0u
  , /*decltype(_impl_.ip_)*/0u
  , /*decltype(_impl_.gc_msg_src_)*/0
  , /*decltype(_impl_.gc_dir_index_source_)*/0u
  , /*decltype(_impl_.eresult_)*/2
  , /*decltype(_impl_.job_id_source_)*/uint64_t{18446744073709551615u}
  , /*decltype(_impl_.job_id_target_)*/uint64_t{18446744073709551615u}} {}
struct CMsgProtoBufHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgProtoBufHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgProtoBufHeaderDefaultTypeInternal() {}
  union {
    CMsgProtoBufHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgProtoBufHeaderDefaultTypeInternal _CMsgProtoBufHeader_default_instance_;
PROTOBUF_CONSTEXPR CMsgWebAPIKey::CMsgWebAPIKey(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.domain_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.publisher_group_id_)*/0u
  , /*decltype(_impl_.key_id_)*/0u
  , /*decltype(_impl_.status_)*/255u} {}
struct CMsgWebAPIKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgWebAPIKeyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgWebAPIKeyDefaultTypeInternal() {}
  union {
    CMsgWebAPIKey _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgWebAPIKeyDefaultTypeInternal _CMsgWebAPIKey_default_instance_;
PROTOBUF_CONSTEXPR CMsgHttpRequest_RequestHeader::CMsgHttpRequest_RequestHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CMsgHttpRequest_RequestHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgHttpRequest_RequestHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgHttpRequest_RequestHeaderDefaultTypeInternal() {}
  union {
    CMsgHttpRequest_RequestHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgHttpRequest_RequestHeaderDefaultTypeInternal _CMsgHttpRequest_RequestHeader_default_instance_;
PROTOBUF_CONSTEXPR CMsgHttpRequest_QueryParam::CMsgHttpRequest_QueryParam(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CMsgHttpRequest_QueryParamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgHttpRequest_QueryParamDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgHttpRequest_QueryParamDefaultTypeInternal() {}
  union {
    CMsgHttpRequest_QueryParam _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgHttpRequest_QueryParamDefaultTypeInternal _CMsgHttpRequest_QueryParam_default_instance_;
PROTOBUF_CONSTEXPR CMsgHttpRequest::CMsgHttpRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.headers_)*/{}
  , /*decltype(_impl_.get_params_)*/{}
  , /*decltype(_impl_.post_params_)*/{}
  , /*decltype(_impl_.hostname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.body_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.request_method_)*/0u
  , /*decltype(_impl_.absolute_timeout_)*/0u} {}
struct CMsgHttpRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgHttpRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgHttpRequestDefaultTypeInternal() {}
  union {
    CMsgHttpRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgHttpRequestDefaultTypeInternal _CMsgHttpRequest_default_instance_;
PROTOBUF_CONSTEXPR CMsgWebAPIRequest::CMsgWebAPIRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.unused_job_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.interface_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.method_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.api_key_)*/nullptr
  , /*decltype(_impl_.request_)*/nullptr
  , /*decltype(_impl_.version_)*/0u
  , /*decltype(_impl_.routing_app_id_)*/0u} {}
struct CMsgWebAPIRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgWebAPIRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgWebAPIRequestDefaultTypeInternal() {}
  union {
    CMsgWebAPIRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgWebAPIRequestDefaultTypeInternal _CMsgWebAPIRequest_default_instance_;
PROTOBUF_CONSTEXPR CMsgHttpResponse_ResponseHeader::CMsgHttpResponse_ResponseHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CMsgHttpResponse_ResponseHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgHttpResponse_ResponseHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgHttpResponse_ResponseHeaderDefaultTypeInternal() {}
  union {
    CMsgHttpResponse_ResponseHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgHttpResponse_ResponseHeaderDefaultTypeInternal _CMsgHttpResponse_ResponseHeader_default_instance_;
PROTOBUF_CONSTEXPR CMsgHttpResponse::CMsgHttpResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.headers_)*/{}
  , /*decltype(_impl_.body_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_code_)*/0u} {}
struct CMsgHttpResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgHttpResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgHttpResponseDefaultTypeInternal() {}
  union {
    CMsgHttpResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgHttpResponseDefaultTypeInternal _CMsgHttpResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgAMFindAccounts::CMsgAMFindAccounts(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.search_string_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.search_type_)*/0u} {}
struct CMsgAMFindAccountsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgAMFindAccountsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgAMFindAccountsDefaultTypeInternal() {}
  union {
    CMsgAMFindAccounts _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgAMFindAccountsDefaultTypeInternal _CMsgAMFindAccounts_default_instance_;
PROTOBUF_CONSTEXPR CMsgAMFindAccountsResponse::CMsgAMFindAccountsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.steam_id_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgAMFindAccountsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgAMFindAccountsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgAMFindAccountsResponseDefaultTypeInternal() {}
  union {
    CMsgAMFindAccountsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgAMFindAccountsResponseDefaultTypeInternal _CMsgAMFindAccountsResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgNotifyWatchdog::CMsgNotifyWatchdog(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.source_)*/0u
  , /*decltype(_impl_.alert_type_)*/0u
  , /*decltype(_impl_.alert_destination_)*/0u
  , /*decltype(_impl_.critical_)*/false
  , /*decltype(_impl_.time_)*/0u
  , /*decltype(_impl_.appid_)*/0u} {}
struct CMsgNotifyWatchdogDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgNotifyWatchdogDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgNotifyWatchdogDefaultTypeInternal() {}
  union {
    CMsgNotifyWatchdog _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgNotifyWatchdogDefaultTypeInternal _CMsgNotifyWatchdog_default_instance_;
PROTOBUF_CONSTEXPR CMsgAMGetLicenses::CMsgAMGetLicenses(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.steamid_)*/uint64_t{0u}} {}
struct CMsgAMGetLicensesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgAMGetLicensesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgAMGetLicensesDefaultTypeInternal() {}
  union {
    CMsgAMGetLicenses _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgAMGetLicensesDefaultTypeInternal _CMsgAMGetLicenses_default_instance_;
PROTOBUF_CONSTEXPR CMsgPackageLicense::CMsgPackageLicense(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.package_id_)*/0u
  , /*decltype(_impl_.time_created_)*/0u
  , /*decltype(_impl_.owner_id_)*/0u} {}
struct CMsgPackageLicenseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgPackageLicenseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgPackageLicenseDefaultTypeInternal() {}
  union {
    CMsgPackageLicense _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgPackageLicenseDefaultTypeInternal _CMsgPackageLicense_default_instance_;
PROTOBUF_CONSTEXPR CMsgAMGetLicensesResponse::CMsgAMGetLicensesResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.license_)*/{}
  , /*decltype(_impl_.result_)*/0u} {}
struct CMsgAMGetLicensesResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgAMGetLicensesResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgAMGetLicensesResponseDefaultTypeInternal() {}
  union {
    CMsgAMGetLicensesResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgAMGetLicensesResponseDefaultTypeInternal _CMsgAMGetLicensesResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgAMGetUserGameStats::CMsgAMGetUserGameStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stats_)*/{}
  , /*decltype(_impl_.steam_id_)*/uint64_t{0u}
  , /*decltype(_impl_.game_id_)*/uint64_t{0u}} {}
struct CMsgAMGetUserGameStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgAMGetUserGameStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgAMGetUserGameStatsDefaultTypeInternal() {}
  union {
    CMsgAMGetUserGameStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgAMGetUserGameStatsDefaultTypeInternal _CMsgAMGetUserGameStats_default_instance_;
PROTOBUF_CONSTEXPR CMsgAMGetUserGameStatsResponse_Stats::CMsgAMGetUserGameStatsResponse_Stats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stat_id_)*/0u
  , /*decltype(_impl_.stat_value_)*/0u} {}
struct CMsgAMGetUserGameStatsResponse_StatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgAMGetUserGameStatsResponse_StatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgAMGetUserGameStatsResponse_StatsDefaultTypeInternal() {}
  union {
    CMsgAMGetUserGameStatsResponse_Stats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgAMGetUserGameStatsResponse_StatsDefaultTypeInternal _CMsgAMGetUserGameStatsResponse_Stats_default_instance_;
PROTOBUF_CONSTEXPR CMsgAMGetUserGameStatsResponse_Achievement_Blocks::CMsgAMGetUserGameStatsResponse_Achievement_Blocks(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.achievement_id_)*/0u
  , /*decltype(_impl_.achievement_bit_id_)*/0u
  , /*decltype(_impl_.unlock_time_)*/0u} {}
struct CMsgAMGetUserGameStatsResponse_Achievement_BlocksDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgAMGetUserGameStatsResponse_Achievement_BlocksDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgAMGetUserGameStatsResponse_Achievement_BlocksDefaultTypeInternal() {}
  union {
    CMsgAMGetUserGameStatsResponse_Achievement_Blocks _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgAMGetUserGameStatsResponse_Achievement_BlocksDefaultTypeInternal _CMsgAMGetUserGameStatsResponse_Achievement_Blocks_default_instance_;
PROTOBUF_CONSTEXPR CMsgAMGetUserGameStatsResponse::CMsgAMGetUserGameStatsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stats_)*/{}
  , /*decltype(_impl_.achievement_blocks_)*/{}
  , /*decltype(_impl_.steam_id_)*/uint64_t{0u}
  , /*decltype(_impl_.game_id_)*/uint64_t{0u}
  , /*decltype(_impl_.eresult_)*/2} {}
struct CMsgAMGetUserGameStatsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgAMGetUserGameStatsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgAMGetUserGameStatsResponseDefaultTypeInternal() {}
  union {
    CMsgAMGetUserGameStatsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgAMGetUserGameStatsResponseDefaultTypeInternal _CMsgAMGetUserGameStatsResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCGetCommandList::CMsgGCGetCommandList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.command_prefix_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.app_id_)*/0u} {}
struct CMsgGCGetCommandListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCGetCommandListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCGetCommandListDefaultTypeInternal() {}
  union {
    CMsgGCGetCommandList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCGetCommandListDefaultTypeInternal _CMsgGCGetCommandList_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCGetCommandListResponse::CMsgGCGetCommandListResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.command_name_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgGCGetCommandListResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCGetCommandListResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCGetCommandListResponseDefaultTypeInternal() {}
  union {
    CMsgGCGetCommandListResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCGetCommandListResponseDefaultTypeInternal _CMsgGCGetCommandListResponse_default_instance_;
PROTOBUF_CONSTEXPR CGCMsgMemCachedGet::CGCMsgMemCachedGet(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.keys_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CGCMsgMemCachedGetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCMsgMemCachedGetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCMsgMemCachedGetDefaultTypeInternal() {}
  union {
    CGCMsgMemCachedGet _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCMsgMemCachedGetDefaultTypeInternal _CGCMsgMemCachedGet_default_instance_;
PROTOBUF_CONSTEXPR CGCMsgMemCachedGetResponse_ValueTag::CGCMsgMemCachedGetResponse_ValueTag(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.found_)*/false} {}
struct CGCMsgMemCachedGetResponse_ValueTagDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCMsgMemCachedGetResponse_ValueTagDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCMsgMemCachedGetResponse_ValueTagDefaultTypeInternal() {}
  union {
    CGCMsgMemCachedGetResponse_ValueTag _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCMsgMemCachedGetResponse_ValueTagDefaultTypeInternal _CGCMsgMemCachedGetResponse_ValueTag_default_instance_;
PROTOBUF_CONSTEXPR CGCMsgMemCachedGetResponse::CGCMsgMemCachedGetResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.values_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CGCMsgMemCachedGetResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCMsgMemCachedGetResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCMsgMemCachedGetResponseDefaultTypeInternal() {}
  union {
    CGCMsgMemCachedGetResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCMsgMemCachedGetResponseDefaultTypeInternal _CGCMsgMemCachedGetResponse_default_instance_;
PROTOBUF_CONSTEXPR CGCMsgMemCachedSet_KeyPair::CGCMsgMemCachedSet_KeyPair(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CGCMsgMemCachedSet_KeyPairDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCMsgMemCachedSet_KeyPairDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCMsgMemCachedSet_KeyPairDefaultTypeInternal() {}
  union {
    CGCMsgMemCachedSet_KeyPair _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCMsgMemCachedSet_KeyPairDefaultTypeInternal _CGCMsgMemCachedSet_KeyPair_default_instance_;
PROTOBUF_CONSTEXPR CGCMsgMemCachedSet::CGCMsgMemCachedSet(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.keys_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CGCMsgMemCachedSetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCMsgMemCachedSetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCMsgMemCachedSetDefaultTypeInternal() {}
  union {
    CGCMsgMemCachedSet _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCMsgMemCachedSetDefaultTypeInternal _CGCMsgMemCachedSet_default_instance_;
PROTOBUF_CONSTEXPR CGCMsgMemCachedDelete::CGCMsgMemCachedDelete(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.keys_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CGCMsgMemCachedDeleteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCMsgMemCachedDeleteDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCMsgMemCachedDeleteDefaultTypeInternal() {}
  union {
    CGCMsgMemCachedDelete _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCMsgMemCachedDeleteDefaultTypeInternal _CGCMsgMemCachedDelete_default_instance_;
PROTOBUF_CONSTEXPR CGCMsgMemCachedStats::CGCMsgMemCachedStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct CGCMsgMemCachedStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCMsgMemCachedStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCMsgMemCachedStatsDefaultTypeInternal() {}
  union {
    CGCMsgMemCachedStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCMsgMemCachedStatsDefaultTypeInternal _CGCMsgMemCachedStats_default_instance_;
PROTOBUF_CONSTEXPR CGCMsgMemCachedStatsResponse::CGCMsgMemCachedStatsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.curr_connections_)*/uint64_t{0u}
  , /*decltype(_impl_.cmd_get_)*/uint64_t{0u}
  , /*decltype(_impl_.cmd_set_)*/uint64_t{0u}
  , /*decltype(_impl_.cmd_flush_)*/uint64_t{0u}
  , /*decltype(_impl_.get_hits_)*/uint64_t{0u}
  , /*decltype(_impl_.get_misses_)*/uint64_t{0u}
  , /*decltype(_impl_.delete_hits_)*/uint64_t{0u}
  , /*decltype(_impl_.delete_misses_)*/uint64_t{0u}
  , /*decltype(_impl_.bytes_read_)*/uint64_t{0u}
  , /*decltype(_impl_.bytes_written_)*/uint64_t{0u}
  , /*decltype(_impl_.limit_maxbytes_)*/uint64_t{0u}
  , /*decltype(_impl_.curr_items_)*/uint64_t{0u}
  , /*decltype(_impl_.evictions_)*/uint64_t{0u}
  , /*decltype(_impl_.bytes_)*/uint64_t{0u}} {}
struct CGCMsgMemCachedStatsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCMsgMemCachedStatsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCMsgMemCachedStatsResponseDefaultTypeInternal() {}
  union {
    CGCMsgMemCachedStatsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCMsgMemCachedStatsResponseDefaultTypeInternal _CGCMsgMemCachedStatsResponse_default_instance_;
PROTOBUF_CONSTEXPR CGCMsgSQLStats::CGCMsgSQLStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.schema_catalog_)*/0u} {}
struct CGCMsgSQLStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCMsgSQLStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCMsgSQLStatsDefaultTypeInternal() {}
  union {
    CGCMsgSQLStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCMsgSQLStatsDefaultTypeInternal _CGCMsgSQLStats_default_instance_;
PROTOBUF_CONSTEXPR CGCMsgSQLStatsResponse::CGCMsgSQLStatsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.threads_)*/0u
  , /*decltype(_impl_.threads_connected_)*/0u
  , /*decltype(_impl_.threads_active_)*/0u
  , /*decltype(_impl_.operations_submitted_)*/0u
  , /*decltype(_impl_.prepared_statements_executed_)*/0u
  , /*decltype(_impl_.non_prepared_statements_executed_)*/0u
  , /*decltype(_impl_.deadlock_retries_)*/0u
  , /*decltype(_impl_.operations_timed_out_in_queue_)*/0u
  , /*decltype(_impl_.errors_)*/0u} {}
struct CGCMsgSQLStatsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCMsgSQLStatsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCMsgSQLStatsResponseDefaultTypeInternal() {}
  union {
    CGCMsgSQLStatsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCMsgSQLStatsResponseDefaultTypeInternal _CGCMsgSQLStatsResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgAMAddFreeLicense::CMsgAMAddFreeLicense(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.store_country_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.steamid_)*/uint64_t{0u}
  , /*decltype(_impl_.ip_public_)*/0u
  , /*decltype(_impl_.packageid_)*/0u} {}
struct CMsgAMAddFreeLicenseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgAMAddFreeLicenseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgAMAddFreeLicenseDefaultTypeInternal() {}
  union {
    CMsgAMAddFreeLicense _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgAMAddFreeLicenseDefaultTypeInternal _CMsgAMAddFreeLicense_default_instance_;
PROTOBUF_CONSTEXPR CMsgAMAddFreeLicenseResponse::CMsgAMAddFreeLicenseResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.transid_)*/uint64_t{0u}
  , /*decltype(_impl_.purchase_result_detail_)*/0
  , /*decltype(_impl_.eresult_)*/2} {}
struct CMsgAMAddFreeLicenseResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgAMAddFreeLicenseResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgAMAddFreeLicenseResponseDefaultTypeInternal() {}
  union {
    CMsgAMAddFreeLicenseResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgAMAddFreeLicenseResponseDefaultTypeInternal _CMsgAMAddFreeLicenseResponse_default_instance_;
PROTOBUF_CONSTEXPR CGCMsgGetIPLocation::CGCMsgGetIPLocation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ips_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CGCMsgGetIPLocationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCMsgGetIPLocationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCMsgGetIPLocationDefaultTypeInternal() {}
  union {
    CGCMsgGetIPLocation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCMsgGetIPLocationDefaultTypeInternal _CGCMsgGetIPLocation_default_instance_;
PROTOBUF_CONSTEXPR CIPLocationInfo::CIPLocationInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.country_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.state_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.city_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ip_)*/0u
  , /*decltype(_impl_.latitude_)*/0
  , /*decltype(_impl_.longitude_)*/0} {}
struct CIPLocationInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CIPLocationInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CIPLocationInfoDefaultTypeInternal() {}
  union {
    CIPLocationInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CIPLocationInfoDefaultTypeInternal _CIPLocationInfo_default_instance_;
PROTOBUF_CONSTEXPR CGCMsgGetIPLocationResponse::CGCMsgGetIPLocationResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.infos_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CGCMsgGetIPLocationResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCMsgGetIPLocationResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCMsgGetIPLocationResponseDefaultTypeInternal() {}
  union {
    CGCMsgGetIPLocationResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCMsgGetIPLocationResponseDefaultTypeInternal _CGCMsgGetIPLocationResponse_default_instance_;
PROTOBUF_CONSTEXPR CGCMsgSystemStatsSchema::CGCMsgSystemStatsSchema(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.schema_kv_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.gc_app_id_)*/0u} {}
struct CGCMsgSystemStatsSchemaDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCMsgSystemStatsSchemaDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCMsgSystemStatsSchemaDefaultTypeInternal() {}
  union {
    CGCMsgSystemStatsSchema _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCMsgSystemStatsSchemaDefaultTypeInternal _CGCMsgSystemStatsSchema_default_instance_;
PROTOBUF_CONSTEXPR CGCMsgGetSystemStats::CGCMsgGetSystemStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct CGCMsgGetSystemStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCMsgGetSystemStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCMsgGetSystemStatsDefaultTypeInternal() {}
  union {
    CGCMsgGetSystemStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCMsgGetSystemStatsDefaultTypeInternal _CGCMsgGetSystemStats_default_instance_;
PROTOBUF_CONSTEXPR CGCMsgGetSystemStatsResponse::CGCMsgGetSystemStatsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stats_kv_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.gc_app_id_)*/0u
  , /*decltype(_impl_.active_jobs_)*/0u
  , /*decltype(_impl_.yielding_jobs_)*/0u
  , /*decltype(_impl_.user_sessions_)*/0u
  , /*decltype(_impl_.game_server_sessions_)*/0u
  , /*decltype(_impl_.socaches_)*/0u
  , /*decltype(_impl_.socaches_to_unload_)*/0u
  , /*decltype(_impl_.socaches_loading_)*/0u
  , /*decltype(_impl_.writeback_queue_)*/0u
  , /*decltype(_impl_.steamid_locks_)*/0u
  , /*decltype(_impl_.logon_queue_)*/0u
  , /*decltype(_impl_.logon_jobs_)*/0u} {}
struct CGCMsgGetSystemStatsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCMsgGetSystemStatsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCMsgGetSystemStatsResponseDefaultTypeInternal() {}
  union {
    CGCMsgGetSystemStatsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCMsgGetSystemStatsResponseDefaultTypeInternal _CGCMsgGetSystemStatsResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgAMSendEmail_PersonaNameReplacementToken::CMsgAMSendEmail_PersonaNameReplacementToken(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.token_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.steamid_)*/uint64_t{0u}} {}
struct CMsgAMSendEmail_PersonaNameReplacementTokenDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgAMSendEmail_PersonaNameReplacementTokenDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgAMSendEmail_PersonaNameReplacementTokenDefaultTypeInternal() {}
  union {
    CMsgAMSendEmail_PersonaNameReplacementToken _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgAMSendEmail_PersonaNameReplacementTokenDefaultTypeInternal _CMsgAMSendEmail_PersonaNameReplacementToken_default_instance_;
PROTOBUF_CONSTEXPR CMsgAMSendEmail_ReplacementToken::CMsgAMSendEmail_ReplacementToken(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.token_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.token_value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CMsgAMSendEmail_ReplacementTokenDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgAMSendEmail_ReplacementTokenDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgAMSendEmail_ReplacementTokenDefaultTypeInternal() {}
  union {
    CMsgAMSendEmail_ReplacementToken _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgAMSendEmail_ReplacementTokenDefaultTypeInternal _CMsgAMSendEmail_ReplacementToken_default_instance_;
PROTOBUF_CONSTEXPR CMsgAMSendEmail::CMsgAMSendEmail(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.persona_name_tokens_)*/{}
  , /*decltype(_impl_.tokens_)*/{}
  , /*decltype(_impl_.steamid_)*/uint64_t{0u}
  , /*decltype(_impl_.email_msg_type_)*/0u
  , /*decltype(_impl_.email_format_)*/0u
  , /*decltype(_impl_.source_gc_)*/0u} {}
struct CMsgAMSendEmailDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgAMSendEmailDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgAMSendEmailDefaultTypeInternal() {}
  union {
    CMsgAMSendEmail _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgAMSendEmailDefaultTypeInternal _CMsgAMSendEmail_default_instance_;
PROTOBUF_CONSTEXPR CMsgAMSendEmailResponse::CMsgAMSendEmailResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.eresult_)*/2u} {}
struct CMsgAMSendEmailResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgAMSendEmailResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgAMSendEmailResponseDefaultTypeInternal() {}
  union {
    CMsgAMSendEmailResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgAMSendEmailResponseDefaultTypeInternal _CMsgAMSendEmailResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCGetEmailTemplate::CMsgGCGetEmailTemplate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.app_id_)*/0u
  , /*decltype(_impl_.email_msg_type_)*/0u
  , /*decltype(_impl_.email_lang_)*/0
  , /*decltype(_impl_.email_format_)*/0} {}
struct CMsgGCGetEmailTemplateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCGetEmailTemplateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCGetEmailTemplateDefaultTypeInternal() {}
  union {
    CMsgGCGetEmailTemplate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCGetEmailTemplateDefaultTypeInternal _CMsgGCGetEmailTemplate_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCGetEmailTemplateResponse::CMsgGCGetEmailTemplateResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.template__)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.template_exists_)*/false
  , /*decltype(_impl_.eresult_)*/2u} {}
struct CMsgGCGetEmailTemplateResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCGetEmailTemplateResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCGetEmailTemplateResponseDefaultTypeInternal() {}
  union {
    CMsgGCGetEmailTemplateResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCGetEmailTemplateResponseDefaultTypeInternal _CMsgGCGetEmailTemplateResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgAMGrantGuestPasses2::CMsgAMGrantGuestPasses2(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.steam_id_)*/uint64_t{0u}
  , /*decltype(_impl_.package_id_)*/0u
  , /*decltype(_impl_.passes_to_grant_)*/0
  , /*decltype(_impl_.days_to_expiration_)*/0
  , /*decltype(_impl_.action_)*/0} {}
struct CMsgAMGrantGuestPasses2DefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgAMGrantGuestPasses2DefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgAMGrantGuestPasses2DefaultTypeInternal() {}
  union {
    CMsgAMGrantGuestPasses2 _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgAMGrantGuestPasses2DefaultTypeInternal _CMsgAMGrantGuestPasses2_default_instance_;
PROTOBUF_CONSTEXPR CMsgAMGrantGuestPasses2Response::CMsgAMGrantGuestPasses2Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.passes_granted_)*/0
  , /*decltype(_impl_.eresult_)*/2} {}
struct CMsgAMGrantGuestPasses2ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgAMGrantGuestPasses2ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgAMGrantGuestPasses2ResponseDefaultTypeInternal() {}
  union {
    CMsgAMGrantGuestPasses2Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgAMGrantGuestPasses2ResponseDefaultTypeInternal _CMsgAMGrantGuestPasses2Response_default_instance_;
PROTOBUF_CONSTEXPR CGCSystemMsg_GetAccountDetails::CGCSystemMsg_GetAccountDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.steamid_)*/uint64_t{0u}
  , /*decltype(_impl_.appid_)*/0u} {}
struct CGCSystemMsg_GetAccountDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCSystemMsg_GetAccountDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCSystemMsg_GetAccountDetailsDefaultTypeInternal() {}
  union {
    CGCSystemMsg_GetAccountDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCSystemMsg_GetAccountDetailsDefaultTypeInternal _CGCSystemMsg_GetAccountDetails_default_instance_;
PROTOBUF_CONSTEXPR CGCSystemMsg_GetAccountDetails_Response::CGCSystemMsg_GetAccountDetails_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.persona_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.currency_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.txn_country_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.is_profile_public_)*/false
  , /*decltype(_impl_.is_inventory_public_)*/false
  , /*decltype(_impl_.is_vac_banned_)*/false
  , /*decltype(_impl_.is_cyber_cafe_)*/false
  , /*decltype(_impl_.is_school_account_)*/false
  , /*decltype(_impl_.is_limited_)*/false
  , /*decltype(_impl_.is_subscribed_)*/false
  , /*decltype(_impl_.is_free_trial_account_)*/false
  , /*decltype(_impl_.package_)*/0u
  , /*decltype(_impl_.free_trial_expiration_)*/0u
  , /*decltype(_impl_.is_low_violence_)*/false
  , /*decltype(_impl_.is_account_locked_down_)*/false
  , /*decltype(_impl_.is_community_banned_)*/false
  , /*decltype(_impl_.is_trade_banned_)*/false
  , /*decltype(_impl_.trade_ban_expiration_)*/0u
  , /*decltype(_impl_.accountid_)*/0u
  , /*decltype(_impl_.suspension_end_time_)*/0u
  , /*decltype(_impl_.steam_level_)*/0u
  , /*decltype(_impl_.friend_count_)*/0u
  , /*decltype(_impl_.account_creation_time_)*/0u
  , /*decltype(_impl_.is_steamguard_enabled_)*/false
  , /*decltype(_impl_.is_phone_verified_)*/false
  , /*decltype(_impl_.is_two_factor_auth_enabled_)*/false
  , /*decltype(_impl_.is_phone_identifying_)*/false
  , /*decltype(_impl_.two_factor_enabled_time_)*/0u
  , /*decltype(_impl_.phone_verification_time_)*/0u
  , /*decltype(_impl_.phone_id_)*/uint64_t{0u}
  , /*decltype(_impl_.rt_identity_linked_)*/0u
  , /*decltype(_impl_.rt_birth_date_)*/0u
  , /*decltype(_impl_.has_accepted_china_ssa_)*/false
  , /*decltype(_impl_.is_banned_steam_china_)*/false
  , /*decltype(_impl_.eresult_deprecated_)*/2u} {}
struct CGCSystemMsg_GetAccountDetails_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCSystemMsg_GetAccountDetails_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCSystemMsg_GetAccountDetails_ResponseDefaultTypeInternal() {}
  union {
    CGCSystemMsg_GetAccountDetails_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCSystemMsg_GetAccountDetails_ResponseDefaultTypeInternal _CGCSystemMsg_GetAccountDetails_Response_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCGetPersonaNames::CMsgGCGetPersonaNames(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.steamids_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgGCGetPersonaNamesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCGetPersonaNamesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCGetPersonaNamesDefaultTypeInternal() {}
  union {
    CMsgGCGetPersonaNames _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCGetPersonaNamesDefaultTypeInternal _CMsgGCGetPersonaNames_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCGetPersonaNames_Response_PersonaName::CMsgGCGetPersonaNames_Response_PersonaName(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.persona_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.steamid_)*/uint64_t{0u}} {}
struct CMsgGCGetPersonaNames_Response_PersonaNameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCGetPersonaNames_Response_PersonaNameDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCGetPersonaNames_Response_PersonaNameDefaultTypeInternal() {}
  union {
    CMsgGCGetPersonaNames_Response_PersonaName _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCGetPersonaNames_Response_PersonaNameDefaultTypeInternal _CMsgGCGetPersonaNames_Response_PersonaName_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCGetPersonaNames_Response::CMsgGCGetPersonaNames_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.succeeded_lookups_)*/{}
  , /*decltype(_impl_.failed_lookup_steamids_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgGCGetPersonaNames_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCGetPersonaNames_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCGetPersonaNames_ResponseDefaultTypeInternal() {}
  union {
    CMsgGCGetPersonaNames_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCGetPersonaNames_ResponseDefaultTypeInternal _CMsgGCGetPersonaNames_Response_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCCheckFriendship::CMsgGCCheckFriendship(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.steamid_left_)*/uint64_t{0u}
  , /*decltype(_impl_.steamid_right_)*/uint64_t{0u}} {}
struct CMsgGCCheckFriendshipDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCCheckFriendshipDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCCheckFriendshipDefaultTypeInternal() {}
  union {
    CMsgGCCheckFriendship _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCCheckFriendshipDefaultTypeInternal _CMsgGCCheckFriendship_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCCheckFriendship_Response::CMsgGCCheckFriendship_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.success_)*/false
  , /*decltype(_impl_.found_friendship_)*/false} {}
struct CMsgGCCheckFriendship_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCCheckFriendship_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCCheckFriendship_ResponseDefaultTypeInternal() {}
  union {
    CMsgGCCheckFriendship_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCCheckFriendship_ResponseDefaultTypeInternal _CMsgGCCheckFriendship_Response_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCMsgMasterSetDirectory_SubGC::CMsgGCMsgMasterSetDirectory_SubGC(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.box_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.command_line_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.gc_binary_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dir_index_)*/0u} {}
struct CMsgGCMsgMasterSetDirectory_SubGCDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCMsgMasterSetDirectory_SubGCDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCMsgMasterSetDirectory_SubGCDefaultTypeInternal() {}
  union {
    CMsgGCMsgMasterSetDirectory_SubGC _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCMsgMasterSetDirectory_SubGCDefaultTypeInternal _CMsgGCMsgMasterSetDirectory_SubGC_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCMsgMasterSetDirectory::CMsgGCMsgMasterSetDirectory(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dir_)*/{}
  , /*decltype(_impl_.master_dir_index_)*/0u} {}
struct CMsgGCMsgMasterSetDirectoryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCMsgMasterSetDirectoryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCMsgMasterSetDirectoryDefaultTypeInternal() {}
  union {
    CMsgGCMsgMasterSetDirectory _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCMsgMasterSetDirectoryDefaultTypeInternal _CMsgGCMsgMasterSetDirectory_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCMsgMasterSetDirectory_Response::CMsgGCMsgMasterSetDirectory_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.eresult_)*/2} {}
struct CMsgGCMsgMasterSetDirectory_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCMsgMasterSetDirectory_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCMsgMasterSetDirectory_ResponseDefaultTypeInternal() {}
  union {
    CMsgGCMsgMasterSetDirectory_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCMsgMasterSetDirectory_ResponseDefaultTypeInternal _CMsgGCMsgMasterSetDirectory_Response_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCMsgWebAPIJobRequestForwardResponse::CMsgGCMsgWebAPIJobRequestForwardResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dir_index_)*/0u} {}
struct CMsgGCMsgWebAPIJobRequestForwardResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCMsgWebAPIJobRequestForwardResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCMsgWebAPIJobRequestForwardResponseDefaultTypeInternal() {}
  union {
    CMsgGCMsgWebAPIJobRequestForwardResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCMsgWebAPIJobRequestForwardResponseDefaultTypeInternal _CMsgGCMsgWebAPIJobRequestForwardResponse_default_instance_;
PROTOBUF_CONSTEXPR CGCSystemMsg_GetPurchaseTrust_Request::CGCSystemMsg_GetPurchaseTrust_Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.steamid_)*/uint64_t{0u}} {}
struct CGCSystemMsg_GetPurchaseTrust_RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCSystemMsg_GetPurchaseTrust_RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCSystemMsg_GetPurchaseTrust_RequestDefaultTypeInternal() {}
  union {
    CGCSystemMsg_GetPurchaseTrust_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCSystemMsg_GetPurchaseTrust_RequestDefaultTypeInternal _CGCSystemMsg_GetPurchaseTrust_Request_default_instance_;
PROTOBUF_CONSTEXPR CGCSystemMsg_GetPurchaseTrust_Response::CGCSystemMsg_GetPurchaseTrust_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.has_prior_purchase_history_)*/false
  , /*decltype(_impl_.has_no_recent_password_resets_)*/false
  , /*decltype(_impl_.is_wallet_cash_trusted_)*/false
  , /*decltype(_impl_.time_all_trusted_)*/0u} {}
struct CGCSystemMsg_GetPurchaseTrust_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCSystemMsg_GetPurchaseTrust_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCSystemMsg_GetPurchaseTrust_ResponseDefaultTypeInternal() {}
  union {
    CGCSystemMsg_GetPurchaseTrust_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCSystemMsg_GetPurchaseTrust_ResponseDefaultTypeInternal _CGCSystemMsg_GetPurchaseTrust_Response_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCHAccountVacStatusChange::CMsgGCHAccountVacStatusChange(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.steam_id_)*/uint64_t{0u}
  , /*decltype(_impl_.app_id_)*/0u
  , /*decltype(_impl_.rtime_vacban_starts_)*/0u
  , /*decltype(_impl_.is_banned_now_)*/false
  , /*decltype(_impl_.is_banned_future_)*/false} {}
struct CMsgGCHAccountVacStatusChangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCHAccountVacStatusChangeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCHAccountVacStatusChangeDefaultTypeInternal() {}
  union {
    CMsgGCHAccountVacStatusChange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCHAccountVacStatusChangeDefaultTypeInternal _CMsgGCHAccountVacStatusChange_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCGetPartnerAccountLink::CMsgGCGetPartnerAccountLink(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.steamid_)*/uint64_t{0u}} {}
struct CMsgGCGetPartnerAccountLinkDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCGetPartnerAccountLinkDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCGetPartnerAccountLinkDefaultTypeInternal() {}
  union {
    CMsgGCGetPartnerAccountLink _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCGetPartnerAccountLinkDefaultTypeInternal _CMsgGCGetPartnerAccountLink_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCGetPartnerAccountLink_Response::CMsgGCGetPartnerAccountLink_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pwid_)*/0u
  , /*decltype(_impl_.nexonid_)*/0u
  , /*decltype(_impl_.ageclass_)*/0
  , /*decltype(_impl_.is_adult_)*/false
  , /*decltype(_impl_.id_verified_)*/true} {}
struct CMsgGCGetPartnerAccountLink_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCGetPartnerAccountLink_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCGetPartnerAccountLink_ResponseDefaultTypeInternal() {}
  union {
    CMsgGCGetPartnerAccountLink_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCGetPartnerAccountLink_ResponseDefaultTypeInternal _CMsgGCGetPartnerAccountLink_Response_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCAddressMask::CMsgGCAddressMask(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ipv4_)*/0u
  , /*decltype(_impl_.maskbits_)*/32u} {}
struct CMsgGCAddressMaskDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCAddressMaskDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCAddressMaskDefaultTypeInternal() {}
  union {
    CMsgGCAddressMask _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCAddressMaskDefaultTypeInternal _CMsgGCAddressMask_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCAddressMaskGroup::CMsgGCAddressMaskGroup(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.addrs_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgGCAddressMaskGroupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCAddressMaskGroupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCAddressMaskGroupDefaultTypeInternal() {}
  union {
    CMsgGCAddressMaskGroup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCAddressMaskGroupDefaultTypeInternal _CMsgGCAddressMaskGroup_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCRoutingInfo_PolicyRule::CMsgGCRoutingInfo_PolicyRule(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.token_bucket_)*/nullptr
  , /*decltype(_impl_.account_type_)*/0
  , /*decltype(_impl_.address_mask_group_id_)*/0} {}
struct CMsgGCRoutingInfo_PolicyRuleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCRoutingInfo_PolicyRuleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCRoutingInfo_PolicyRuleDefaultTypeInternal() {}
  union {
    CMsgGCRoutingInfo_PolicyRule _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCRoutingInfo_PolicyRuleDefaultTypeInternal _CMsgGCRoutingInfo_PolicyRule_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCRoutingInfo_TokenBucketConfiguration::CMsgGCRoutingInfo_TokenBucketConfiguration(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tokens_start_)*/0
  , /*decltype(_impl_.tokens_grant_)*/0
  , /*decltype(_impl_.grant_seconds_)*/0} {}
struct CMsgGCRoutingInfo_TokenBucketConfigurationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCRoutingInfo_TokenBucketConfigurationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCRoutingInfo_TokenBucketConfigurationDefaultTypeInternal() {}
  union {
    CMsgGCRoutingInfo_TokenBucketConfiguration _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCRoutingInfo_TokenBucketConfigurationDefaultTypeInternal _CMsgGCRoutingInfo_TokenBucketConfiguration_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCRoutingInfo::CMsgGCRoutingInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dir_index_)*/{}
  , /*decltype(_impl_.policy_rules_)*/{}
  , /*decltype(_impl_.webapi_param_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.method_)*/0
  , /*decltype(_impl_.protobuf_field_)*/0u
  , /*decltype(_impl_.fallback_)*/1} {}
struct CMsgGCRoutingInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCRoutingInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCRoutingInfoDefaultTypeInternal() {}
  union {
    CMsgGCRoutingInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCRoutingInfoDefaultTypeInternal _CMsgGCRoutingInfo_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCMsgMasterSetWebAPIRouting_Entry::CMsgGCMsgMasterSetWebAPIRouting_Entry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.interface_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.method_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.routing_)*/nullptr} {}
struct CMsgGCMsgMasterSetWebAPIRouting_EntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCMsgMasterSetWebAPIRouting_EntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCMsgMasterSetWebAPIRouting_EntryDefaultTypeInternal() {}
  union {
    CMsgGCMsgMasterSetWebAPIRouting_Entry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCMsgMasterSetWebAPIRouting_EntryDefaultTypeInternal _CMsgGCMsgMasterSetWebAPIRouting_Entry_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCMsgMasterSetWebAPIRouting::CMsgGCMsgMasterSetWebAPIRouting(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.entries_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgGCMsgMasterSetWebAPIRoutingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCMsgMasterSetWebAPIRoutingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCMsgMasterSetWebAPIRoutingDefaultTypeInternal() {}
  union {
    CMsgGCMsgMasterSetWebAPIRouting _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCMsgMasterSetWebAPIRoutingDefaultTypeInternal _CMsgGCMsgMasterSetWebAPIRouting_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCMsgMasterSetClientMsgRouting_Entry::CMsgGCMsgMasterSetClientMsgRouting_Entry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.routing_)*/nullptr
  , /*decltype(_impl_.msg_type_)*/0u} {}
struct CMsgGCMsgMasterSetClientMsgRouting_EntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCMsgMasterSetClientMsgRouting_EntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCMsgMasterSetClientMsgRouting_EntryDefaultTypeInternal() {}
  union {
    CMsgGCMsgMasterSetClientMsgRouting_Entry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCMsgMasterSetClientMsgRouting_EntryDefaultTypeInternal _CMsgGCMsgMasterSetClientMsgRouting_Entry_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCMsgMasterSetClientMsgRouting::CMsgGCMsgMasterSetClientMsgRouting(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.entries_)*/{}
  , /*decltype(_impl_.address_mask_groups_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgGCMsgMasterSetClientMsgRoutingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCMsgMasterSetClientMsgRoutingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCMsgMasterSetClientMsgRoutingDefaultTypeInternal() {}
  union {
    CMsgGCMsgMasterSetClientMsgRouting _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCMsgMasterSetClientMsgRoutingDefaultTypeInternal _CMsgGCMsgMasterSetClientMsgRouting_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCMsgMasterSetWebAPIRouting_Response::CMsgGCMsgMasterSetWebAPIRouting_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.eresult_)*/2} {}
struct CMsgGCMsgMasterSetWebAPIRouting_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCMsgMasterSetWebAPIRouting_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCMsgMasterSetWebAPIRouting_ResponseDefaultTypeInternal() {}
  union {
    CMsgGCMsgMasterSetWebAPIRouting_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCMsgMasterSetWebAPIRouting_ResponseDefaultTypeInternal _CMsgGCMsgMasterSetWebAPIRouting_Response_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCMsgMasterSetClientMsgRouting_Response::CMsgGCMsgMasterSetClientMsgRouting_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.eresult_)*/2} {}
struct CMsgGCMsgMasterSetClientMsgRouting_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCMsgMasterSetClientMsgRouting_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCMsgMasterSetClientMsgRouting_ResponseDefaultTypeInternal() {}
  union {
    CMsgGCMsgMasterSetClientMsgRouting_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCMsgMasterSetClientMsgRouting_ResponseDefaultTypeInternal _CMsgGCMsgMasterSetClientMsgRouting_Response_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCMsgSetOptions_MessageRange::CMsgGCMsgSetOptions_MessageRange(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.low_)*/0u
  , /*decltype(_impl_.high_)*/0u} {}
struct CMsgGCMsgSetOptions_MessageRangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCMsgSetOptions_MessageRangeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCMsgSetOptions_MessageRangeDefaultTypeInternal() {}
  union {
    CMsgGCMsgSetOptions_MessageRange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCMsgSetOptions_MessageRangeDefaultTypeInternal _CMsgGCMsgSetOptions_MessageRange_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCMsgSetOptions::CMsgGCMsgSetOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.options_)*/{}
  , /*decltype(_impl_.client_msg_ranges_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgGCMsgSetOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCMsgSetOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCMsgSetOptionsDefaultTypeInternal() {}
  union {
    CMsgGCMsgSetOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCMsgSetOptionsDefaultTypeInternal _CMsgGCMsgSetOptions_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCHUpdateSession_ExtraField::CMsgGCHUpdateSession_ExtraField(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CMsgGCHUpdateSession_ExtraFieldDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCHUpdateSession_ExtraFieldDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCHUpdateSession_ExtraFieldDefaultTypeInternal() {}
  union {
    CMsgGCHUpdateSession_ExtraField _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCHUpdateSession_ExtraFieldDefaultTypeInternal _CMsgGCHUpdateSession_ExtraField_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCHUpdateSession::CMsgGCHUpdateSession(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.extra_fields_)*/{}
  , /*decltype(_impl_.depot_ids_)*/{}
  , /*decltype(_impl_.steam_id_)*/uint64_t{0u}
  , /*decltype(_impl_.app_id_)*/0u
  , /*decltype(_impl_.online_)*/false
  , /*decltype(_impl_.server_steam_id_)*/uint64_t{0u}
  , /*decltype(_impl_.server_addr_)*/0u
  , /*decltype(_impl_.server_port_)*/0u
  , /*decltype(_impl_.os_type_)*/0u
  , /*decltype(_impl_.client_addr_)*/0u
  , /*decltype(_impl_.owner_id_)*/uint64_t{0u}
  , /*decltype(_impl_.cm_session_sysid_)*/0u
  , /*decltype(_impl_.cm_session_identifier_)*/0u} {}
struct CMsgGCHUpdateSessionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCHUpdateSessionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCHUpdateSessionDefaultTypeInternal() {}
  union {
    CMsgGCHUpdateSession _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCHUpdateSessionDefaultTypeInternal _CMsgGCHUpdateSession_default_instance_;
PROTOBUF_CONSTEXPR CMsgNotificationOfSuspiciousActivity_MultipleGameInstances::CMsgNotificationOfSuspiciousActivity_MultipleGameInstances(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.other_steamids_)*/{}
  , /*decltype(_impl_.app_instance_count_)*/0u} {}
struct CMsgNotificationOfSuspiciousActivity_MultipleGameInstancesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgNotificationOfSuspiciousActivity_MultipleGameInstancesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgNotificationOfSuspiciousActivity_MultipleGameInstancesDefaultTypeInternal() {}
  union {
    CMsgNotificationOfSuspiciousActivity_MultipleGameInstances _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgNotificationOfSuspiciousActivity_MultipleGameInstancesDefaultTypeInternal _CMsgNotificationOfSuspiciousActivity_MultipleGameInstances_default_instance_;
PROTOBUF_CONSTEXPR CMsgNotificationOfSuspiciousActivity::CMsgNotificationOfSuspiciousActivity(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.multiple_instances_)*/nullptr
  , /*decltype(_impl_.steamid_)*/uint64_t{0u}
  , /*decltype(_impl_.appid_)*/0u} {}
struct CMsgNotificationOfSuspiciousActivityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgNotificationOfSuspiciousActivityDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgNotificationOfSuspiciousActivityDefaultTypeInternal() {}
  union {
    CMsgNotificationOfSuspiciousActivity _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgNotificationOfSuspiciousActivityDefaultTypeInternal _CMsgNotificationOfSuspiciousActivity_default_instance_;
PROTOBUF_CONSTEXPR CMsgDPPartnerMicroTxns_PartnerInfo::CMsgDPPartnerMicroTxns_PartnerInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.partner_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.currency_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.currency_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.partner_id_)*/0u} {}
struct CMsgDPPartnerMicroTxns_PartnerInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDPPartnerMicroTxns_PartnerInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDPPartnerMicroTxns_PartnerInfoDefaultTypeInternal() {}
  union {
    CMsgDPPartnerMicroTxns_PartnerInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDPPartnerMicroTxns_PartnerInfoDefaultTypeInternal _CMsgDPPartnerMicroTxns_PartnerInfo_default_instance_;
PROTOBUF_CONSTEXPR CMsgDPPartnerMicroTxns_PartnerMicroTxn::CMsgDPPartnerMicroTxns_PartnerMicroTxn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.country_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.region_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.init_time_)*/0u
  , /*decltype(_impl_.last_update_time_)*/0u
  , /*decltype(_impl_.txn_id_)*/uint64_t{0u}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.line_item_)*/0u
  , /*decltype(_impl_.item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.price_)*/uint64_t{0u}
  , /*decltype(_impl_.tax_)*/uint64_t{0u}
  , /*decltype(_impl_.def_index_)*/0u
  , /*decltype(_impl_.purchase_type_)*/0u
  , /*decltype(_impl_.price_usd_)*/uint64_t{0u}
  , /*decltype(_impl_.tax_usd_)*/uint64_t{0u}
  , /*decltype(_impl_.steam_txn_type_)*/0u
  , /*decltype(_impl_.quantity_)*/0
  , /*decltype(_impl_.ref_trans_id_)*/uint64_t{0u}} {}
struct CMsgDPPartnerMicroTxns_PartnerMicroTxnDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDPPartnerMicroTxns_PartnerMicroTxnDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDPPartnerMicroTxns_PartnerMicroTxnDefaultTypeInternal() {}
  union {
    CMsgDPPartnerMicroTxns_PartnerMicroTxn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDPPartnerMicroTxns_PartnerMicroTxnDefaultTypeInternal _CMsgDPPartnerMicroTxns_PartnerMicroTxn_default_instance_;
PROTOBUF_CONSTEXPR CMsgDPPartnerMicroTxns::CMsgDPPartnerMicroTxns(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.transactions_)*/{}
  , /*decltype(_impl_.gc_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.partner_)*/nullptr
  , /*decltype(_impl_.appid_)*/0u} {}
struct CMsgDPPartnerMicroTxnsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDPPartnerMicroTxnsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDPPartnerMicroTxnsDefaultTypeInternal() {}
  union {
    CMsgDPPartnerMicroTxns _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDPPartnerMicroTxnsDefaultTypeInternal _CMsgDPPartnerMicroTxns_default_instance_;
PROTOBUF_CONSTEXPR CMsgDPPartnerMicroTxnsResponse::CMsgDPPartnerMicroTxnsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.eerrorcode_)*/0
  , /*decltype(_impl_.eresult_)*/2u} {}
struct CMsgDPPartnerMicroTxnsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDPPartnerMicroTxnsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDPPartnerMicroTxnsResponseDefaultTypeInternal() {}
  union {
    CMsgDPPartnerMicroTxnsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDPPartnerMicroTxnsResponseDefaultTypeInternal _CMsgDPPartnerMicroTxnsResponse_default_instance_;
PROTOBUF_CONSTEXPR CChinaAgreementSessions_StartAgreementSessionInGame_Request::CChinaAgreementSessions_StartAgreementSessionInGame_Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.client_ipaddress_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.steamid_)*/uint64_t{0u}
  , /*decltype(_impl_.appid_)*/0u} {}
struct CChinaAgreementSessions_StartAgreementSessionInGame_RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CChinaAgreementSessions_StartAgreementSessionInGame_RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CChinaAgreementSessions_StartAgreementSessionInGame_RequestDefaultTypeInternal() {}
  union {
    CChinaAgreementSessions_StartAgreementSessionInGame_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CChinaAgreementSessions_StartAgreementSessionInGame_RequestDefaultTypeInternal _CChinaAgreementSessions_StartAgreementSessionInGame_Request_default_instance_;
PROTOBUF_CONSTEXPR CChinaAgreementSessions_StartAgreementSessionInGame_Response::CChinaAgreementSessions_StartAgreementSessionInGame_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.agreement_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CChinaAgreementSessions_StartAgreementSessionInGame_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CChinaAgreementSessions_StartAgreementSessionInGame_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CChinaAgreementSessions_StartAgreementSessionInGame_ResponseDefaultTypeInternal() {}
  union {
    CChinaAgreementSessions_StartAgreementSessionInGame_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CChinaAgreementSessions_StartAgreementSessionInGame_ResponseDefaultTypeInternal _CChinaAgreementSessions_StartAgreementSessionInGame_Response_default_instance_;
bool CMsgGCRoutingInfo_RoutingMethod_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CMsgGCRoutingInfo_RoutingMethod_strings[5] = {};

static const char CMsgGCRoutingInfo_RoutingMethod_names[] =
  "CLIENT_STEAMID"
  "DISCARD"
  "PROTOBUF_FIELD_UINT64"
  "RANDOM"
  "WEBAPI_PARAM_UINT64";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CMsgGCRoutingInfo_RoutingMethod_entries[] = {
  { {CMsgGCRoutingInfo_RoutingMethod_names + 0, 14}, 2 },
  { {CMsgGCRoutingInfo_RoutingMethod_names + 14, 7}, 1 },
  { {CMsgGCRoutingInfo_RoutingMethod_names + 21, 21}, 3 },
  { {CMsgGCRoutingInfo_RoutingMethod_names + 42, 6}, 0 },
  { {CMsgGCRoutingInfo_RoutingMethod_names + 48, 19}, 4 },
};

static const int CMsgGCRoutingInfo_RoutingMethod_entries_by_number[] = {
  3, // 0 -> RANDOM
  1, // 1 -> DISCARD
  0, // 2 -> CLIENT_STEAMID
  2, // 3 -> PROTOBUF_FIELD_UINT64
  4, // 4 -> WEBAPI_PARAM_UINT64
};

const std::string& CMsgGCRoutingInfo_RoutingMethod_Name(
    CMsgGCRoutingInfo_RoutingMethod value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CMsgGCRoutingInfo_RoutingMethod_entries,
          CMsgGCRoutingInfo_RoutingMethod_entries_by_number,
          5, CMsgGCRoutingInfo_RoutingMethod_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CMsgGCRoutingInfo_RoutingMethod_entries,
      CMsgGCRoutingInfo_RoutingMethod_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CMsgGCRoutingInfo_RoutingMethod_strings[idx].get();
}
bool CMsgGCRoutingInfo_RoutingMethod_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMsgGCRoutingInfo_RoutingMethod* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CMsgGCRoutingInfo_RoutingMethod_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<CMsgGCRoutingInfo_RoutingMethod>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgGCRoutingInfo_RoutingMethod CMsgGCRoutingInfo::RANDOM;
constexpr CMsgGCRoutingInfo_RoutingMethod CMsgGCRoutingInfo::DISCARD;
constexpr CMsgGCRoutingInfo_RoutingMethod CMsgGCRoutingInfo::CLIENT_STEAMID;
constexpr CMsgGCRoutingInfo_RoutingMethod CMsgGCRoutingInfo::PROTOBUF_FIELD_UINT64;
constexpr CMsgGCRoutingInfo_RoutingMethod CMsgGCRoutingInfo::WEBAPI_PARAM_UINT64;
constexpr CMsgGCRoutingInfo_RoutingMethod CMsgGCRoutingInfo::RoutingMethod_MIN;
constexpr CMsgGCRoutingInfo_RoutingMethod CMsgGCRoutingInfo::RoutingMethod_MAX;
constexpr int CMsgGCRoutingInfo::RoutingMethod_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CMsgGCMsgSetOptions_Option_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CMsgGCMsgSetOptions_Option_strings[4] = {};

static const char CMsgGCMsgSetOptions_Option_names[] =
  "NOTIFY_ACHIEVEMENTS"
  "NOTIFY_SERVER_SESSIONS"
  "NOTIFY_USER_SESSIONS"
  "NOTIFY_VAC_ACTION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CMsgGCMsgSetOptions_Option_entries[] = {
  { {CMsgGCMsgSetOptions_Option_names + 0, 19}, 2 },
  { {CMsgGCMsgSetOptions_Option_names + 19, 22}, 1 },
  { {CMsgGCMsgSetOptions_Option_names + 41, 20}, 0 },
  { {CMsgGCMsgSetOptions_Option_names + 61, 17}, 3 },
};

static const int CMsgGCMsgSetOptions_Option_entries_by_number[] = {
  2, // 0 -> NOTIFY_USER_SESSIONS
  1, // 1 -> NOTIFY_SERVER_SESSIONS
  0, // 2 -> NOTIFY_ACHIEVEMENTS
  3, // 3 -> NOTIFY_VAC_ACTION
};

const std::string& CMsgGCMsgSetOptions_Option_Name(
    CMsgGCMsgSetOptions_Option value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CMsgGCMsgSetOptions_Option_entries,
          CMsgGCMsgSetOptions_Option_entries_by_number,
          4, CMsgGCMsgSetOptions_Option_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CMsgGCMsgSetOptions_Option_entries,
      CMsgGCMsgSetOptions_Option_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CMsgGCMsgSetOptions_Option_strings[idx].get();
}
bool CMsgGCMsgSetOptions_Option_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMsgGCMsgSetOptions_Option* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CMsgGCMsgSetOptions_Option_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<CMsgGCMsgSetOptions_Option>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgGCMsgSetOptions_Option CMsgGCMsgSetOptions::NOTIFY_USER_SESSIONS;
constexpr CMsgGCMsgSetOptions_Option CMsgGCMsgSetOptions::NOTIFY_SERVER_SESSIONS;
constexpr CMsgGCMsgSetOptions_Option CMsgGCMsgSetOptions::NOTIFY_ACHIEVEMENTS;
constexpr CMsgGCMsgSetOptions_Option CMsgGCMsgSetOptions::NOTIFY_VAC_ACTION;
constexpr CMsgGCMsgSetOptions_Option CMsgGCMsgSetOptions::Option_MIN;
constexpr CMsgGCMsgSetOptions_Option CMsgGCMsgSetOptions::Option_MAX;
constexpr int CMsgGCMsgSetOptions::Option_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CMsgDPPartnerMicroTxnsResponse_EErrorCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CMsgDPPartnerMicroTxnsResponse_EErrorCode_strings[9] = {};

static const char CMsgDPPartnerMicroTxnsResponse_EErrorCode_names[] =
  "k_MsgAlreadyRunning"
  "k_MsgInvalidAppID"
  "k_MsgInvalidPartnerInfo"
  "k_MsgInvalidTransactionData"
  "k_MsgNoTransactions"
  "k_MsgPartnerInfoDiscrepancy"
  "k_MsgSQLFailure"
  "k_MsgTransactionInsertFailed"
  "k_MsgValid";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CMsgDPPartnerMicroTxnsResponse_EErrorCode_entries[] = {
  { {CMsgDPPartnerMicroTxnsResponse_EErrorCode_names + 0, 19}, 8 },
  { {CMsgDPPartnerMicroTxnsResponse_EErrorCode_names + 19, 17}, 1 },
  { {CMsgDPPartnerMicroTxnsResponse_EErrorCode_names + 36, 23}, 2 },
  { {CMsgDPPartnerMicroTxnsResponse_EErrorCode_names + 59, 27}, 9 },
  { {CMsgDPPartnerMicroTxnsResponse_EErrorCode_names + 86, 19}, 3 },
  { {CMsgDPPartnerMicroTxnsResponse_EErrorCode_names + 105, 27}, 5 },
  { {CMsgDPPartnerMicroTxnsResponse_EErrorCode_names + 132, 15}, 4 },
  { {CMsgDPPartnerMicroTxnsResponse_EErrorCode_names + 147, 28}, 7 },
  { {CMsgDPPartnerMicroTxnsResponse_EErrorCode_names + 175, 10}, 0 },
};

static const int CMsgDPPartnerMicroTxnsResponse_EErrorCode_entries_by_number[] = {
  8, // 0 -> k_MsgValid
  1, // 1 -> k_MsgInvalidAppID
  2, // 2 -> k_MsgInvalidPartnerInfo
  4, // 3 -> k_MsgNoTransactions
  6, // 4 -> k_MsgSQLFailure
  5, // 5 -> k_MsgPartnerInfoDiscrepancy
  7, // 7 -> k_MsgTransactionInsertFailed
  0, // 8 -> k_MsgAlreadyRunning
  3, // 9 -> k_MsgInvalidTransactionData
};

const std::string& CMsgDPPartnerMicroTxnsResponse_EErrorCode_Name(
    CMsgDPPartnerMicroTxnsResponse_EErrorCode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CMsgDPPartnerMicroTxnsResponse_EErrorCode_entries,
          CMsgDPPartnerMicroTxnsResponse_EErrorCode_entries_by_number,
          9, CMsgDPPartnerMicroTxnsResponse_EErrorCode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CMsgDPPartnerMicroTxnsResponse_EErrorCode_entries,
      CMsgDPPartnerMicroTxnsResponse_EErrorCode_entries_by_number,
      9, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CMsgDPPartnerMicroTxnsResponse_EErrorCode_strings[idx].get();
}
bool CMsgDPPartnerMicroTxnsResponse_EErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMsgDPPartnerMicroTxnsResponse_EErrorCode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CMsgDPPartnerMicroTxnsResponse_EErrorCode_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<CMsgDPPartnerMicroTxnsResponse_EErrorCode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgDPPartnerMicroTxnsResponse_EErrorCode CMsgDPPartnerMicroTxnsResponse::k_MsgValid;
constexpr CMsgDPPartnerMicroTxnsResponse_EErrorCode CMsgDPPartnerMicroTxnsResponse::k_MsgInvalidAppID;
constexpr CMsgDPPartnerMicroTxnsResponse_EErrorCode CMsgDPPartnerMicroTxnsResponse::k_MsgInvalidPartnerInfo;
constexpr CMsgDPPartnerMicroTxnsResponse_EErrorCode CMsgDPPartnerMicroTxnsResponse::k_MsgNoTransactions;
constexpr CMsgDPPartnerMicroTxnsResponse_EErrorCode CMsgDPPartnerMicroTxnsResponse::k_MsgSQLFailure;
constexpr CMsgDPPartnerMicroTxnsResponse_EErrorCode CMsgDPPartnerMicroTxnsResponse::k_MsgPartnerInfoDiscrepancy;
constexpr CMsgDPPartnerMicroTxnsResponse_EErrorCode CMsgDPPartnerMicroTxnsResponse::k_MsgTransactionInsertFailed;
constexpr CMsgDPPartnerMicroTxnsResponse_EErrorCode CMsgDPPartnerMicroTxnsResponse::k_MsgAlreadyRunning;
constexpr CMsgDPPartnerMicroTxnsResponse_EErrorCode CMsgDPPartnerMicroTxnsResponse::k_MsgInvalidTransactionData;
constexpr CMsgDPPartnerMicroTxnsResponse_EErrorCode CMsgDPPartnerMicroTxnsResponse::EErrorCode_MIN;
constexpr CMsgDPPartnerMicroTxnsResponse_EErrorCode CMsgDPPartnerMicroTxnsResponse::EErrorCode_MAX;
constexpr int CMsgDPPartnerMicroTxnsResponse::EErrorCode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool GCProtoBufMsgSrc_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GCProtoBufMsgSrc_strings[5] = {};

static const char GCProtoBufMsgSrc_names[] =
  "GCProtoBufMsgSrc_FromGC"
  "GCProtoBufMsgSrc_FromSteamID"
  "GCProtoBufMsgSrc_FromSystem"
  "GCProtoBufMsgSrc_ReplySystem"
  "GCProtoBufMsgSrc_Unspecified";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GCProtoBufMsgSrc_entries[] = {
  { {GCProtoBufMsgSrc_names + 0, 23}, 3 },
  { {GCProtoBufMsgSrc_names + 23, 28}, 2 },
  { {GCProtoBufMsgSrc_names + 51, 27}, 1 },
  { {GCProtoBufMsgSrc_names + 78, 28}, 4 },
  { {GCProtoBufMsgSrc_names + 106, 28}, 0 },
};

static const int GCProtoBufMsgSrc_entries_by_number[] = {
  4, // 0 -> GCProtoBufMsgSrc_Unspecified
  2, // 1 -> GCProtoBufMsgSrc_FromSystem
  1, // 2 -> GCProtoBufMsgSrc_FromSteamID
  0, // 3 -> GCProtoBufMsgSrc_FromGC
  3, // 4 -> GCProtoBufMsgSrc_ReplySystem
};

const std::string& GCProtoBufMsgSrc_Name(
    GCProtoBufMsgSrc value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GCProtoBufMsgSrc_entries,
          GCProtoBufMsgSrc_entries_by_number,
          5, GCProtoBufMsgSrc_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GCProtoBufMsgSrc_entries,
      GCProtoBufMsgSrc_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GCProtoBufMsgSrc_strings[idx].get();
}
bool GCProtoBufMsgSrc_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GCProtoBufMsgSrc* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GCProtoBufMsgSrc_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<GCProtoBufMsgSrc>(int_value);
  }
  return success;
}

// ===================================================================

class CMsgProtoBufHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgProtoBufHeader>()._impl_._has_bits_);
  static void set_has_client_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_client_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_source_app_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_job_id_source(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_job_id_target(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_target_job_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_eresult(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_error_message(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_gc_msg_src(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_gc_dir_index_source(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

CMsgProtoBufHeader::CMsgProtoBufHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgProtoBufHeader)
}
CMsgProtoBufHeader::CMsgProtoBufHeader(const CMsgProtoBufHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgProtoBufHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_job_name_){}
    , decltype(_impl_.error_message_){}
    , decltype(_impl_.client_steam_id_){}
    , decltype(_impl_.client_session_id_){}
    , decltype(_impl_.source_app_id_){}
    , decltype(_impl_.ip_){}
    , decltype(_impl_.gc_msg_src_){}
    , decltype(_impl_.gc_dir_index_source_){}
    , decltype(_impl_.eresult_){}
    , decltype(_impl_.job_id_source_){}
    , decltype(_impl_.job_id_target_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.target_job_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_job_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_target_job_name()) {
    _this->_impl_.target_job_name_.Set(from._internal_target_job_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error_message()) {
    _this->_impl_.error_message_.Set(from._internal_error_message(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.client_steam_id_, &from._impl_.client_steam_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.job_id_target_) -
    reinterpret_cast<char*>(&_impl_.client_steam_id_)) + sizeof(_impl_.job_id_target_));
  // @@protoc_insertion_point(copy_constructor:CMsgProtoBufHeader)
}

inline void CMsgProtoBufHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_job_name_){}
    , decltype(_impl_.error_message_){}
    , decltype(_impl_.client_steam_id_){uint64_t{0u}}
    , decltype(_impl_.client_session_id_){0}
    , decltype(_impl_.source_app_id_){0u}
    , decltype(_impl_.ip_){0u}
    , decltype(_impl_.gc_msg_src_){0}
    , decltype(_impl_.gc_dir_index_source_){0u}
    , decltype(_impl_.eresult_){2}
    , decltype(_impl_.job_id_source_){uint64_t{18446744073709551615u}}
    , decltype(_impl_.job_id_target_){uint64_t{18446744073709551615u}}
  };
  _impl_.target_job_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_job_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgProtoBufHeader::~CMsgProtoBufHeader() {
  // @@protoc_insertion_point(destructor:CMsgProtoBufHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgProtoBufHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.target_job_name_.Destroy();
  _impl_.error_message_.Destroy();
}

void CMsgProtoBufHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgProtoBufHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgProtoBufHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.target_job_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.error_message_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.client_steam_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.gc_dir_index_source_) -
        reinterpret_cast<char*>(&_impl_.client_steam_id_)) + sizeof(_impl_.gc_dir_index_source_));
  }
  if (cached_has_bits & 0x00000700u) {
    _impl_.eresult_ = 2;
    _impl_.job_id_source_ = uint64_t{18446744073709551615u};
    _impl_.job_id_target_ = uint64_t{18446744073709551615u};
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgProtoBufHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 client_steam_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_client_steam_id(&has_bits);
          _impl_.client_steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional int32 client_session_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_client_session_id(&has_bits);
          _impl_.client_session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 source_app_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_source_app_id(&has_bits);
          _impl_.source_app_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 job_id_source = 10 [default = 18446744073709551615];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has_job_id_source(&has_bits);
          _impl_.job_id_source_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 job_id_target = 11 [default = 18446744073709551615];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _Internal::set_has_job_id_target(&has_bits);
          _impl_.job_id_target_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional string target_job_name = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_target_job_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 eresult = 13 [default = 2];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_eresult(&has_bits);
          _impl_.eresult_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string error_message = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_error_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ip = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_ip(&has_bits);
          _impl_.ip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .GCProtoBufMsgSrc gc_msg_src = 200;
      case 200:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::GCProtoBufMsgSrc_IsValid(val))) {
            _internal_set_gc_msg_src(static_cast<::GCProtoBufMsgSrc>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(200, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gc_dir_index_source = 201;
      case 201:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_gc_dir_index_source(&has_bits);
          _impl_.gc_dir_index_source_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgProtoBufHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgProtoBufHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 client_steam_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_client_steam_id(), target);
  }

  // optional int32 client_session_id = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_client_session_id(), target);
  }

  // optional uint32 source_app_id = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_source_app_id(), target);
  }

  // optional fixed64 job_id_source = 10 [default = 18446744073709551615];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(10, this->_internal_job_id_source(), target);
  }

  // optional fixed64 job_id_target = 11 [default = 18446744073709551615];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(11, this->_internal_job_id_target(), target);
  }

  // optional string target_job_name = 12;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_target_job_name(), target);
  }

  // optional int32 eresult = 13 [default = 2];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(13, this->_internal_eresult(), target);
  }

  // optional string error_message = 14;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_error_message(), target);
  }

  // optional uint32 ip = 15;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_ip(), target);
  }

  // optional .GCProtoBufMsgSrc gc_msg_src = 200;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      200, this->_internal_gc_msg_src(), target);
  }

  // optional uint32 gc_dir_index_source = 201;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(201, this->_internal_gc_dir_index_source(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgProtoBufHeader)
  return target;
}

size_t CMsgProtoBufHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgProtoBufHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string target_job_name = 12;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_target_job_name());
    }

    // optional string error_message = 14;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_error_message());
    }

    // optional fixed64 client_steam_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional int32 client_session_id = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_client_session_id());
    }

    // optional uint32 source_app_id = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_source_app_id());
    }

    // optional uint32 ip = 15;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ip());
    }

    // optional .GCProtoBufMsgSrc gc_msg_src = 200;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_gc_msg_src());
    }

    // optional uint32 gc_dir_index_source = 201;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_gc_dir_index_source());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional int32 eresult = 13 [default = 2];
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_eresult());
    }

    // optional fixed64 job_id_source = 10 [default = 18446744073709551615];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional fixed64 job_id_target = 11 [default = 18446744073709551615];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 8;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgProtoBufHeader::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgProtoBufHeader*>(
      &from));
}

void CMsgProtoBufHeader::MergeFrom(const CMsgProtoBufHeader& from) {
  CMsgProtoBufHeader* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgProtoBufHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_target_job_name(from._internal_target_job_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_error_message(from._internal_error_message());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.client_steam_id_ = from._impl_.client_steam_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.client_session_id_ = from._impl_.client_session_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.source_app_id_ = from._impl_.source_app_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ip_ = from._impl_.ip_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.gc_msg_src_ = from._impl_.gc_msg_src_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.gc_dir_index_source_ = from._impl_.gc_dir_index_source_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.eresult_ = from._impl_.eresult_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.job_id_source_ = from._impl_.job_id_source_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.job_id_target_ = from._impl_.job_id_target_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgProtoBufHeader::CopyFrom(const CMsgProtoBufHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgProtoBufHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgProtoBufHeader::IsInitialized() const {
  return true;
}

void CMsgProtoBufHeader::InternalSwap(CMsgProtoBufHeader* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.target_job_name_, lhs_arena,
      &other->_impl_.target_job_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_message_, lhs_arena,
      &other->_impl_.error_message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgProtoBufHeader, _impl_.gc_dir_index_source_)
      + sizeof(CMsgProtoBufHeader::_impl_.gc_dir_index_source_)
      - PROTOBUF_FIELD_OFFSET(CMsgProtoBufHeader, _impl_.client_steam_id_)>(
          reinterpret_cast<char*>(&_impl_.client_steam_id_),
          reinterpret_cast<char*>(&other->_impl_.client_steam_id_));
  swap(_impl_.eresult_, other->_impl_.eresult_);
  swap(_impl_.job_id_source_, other->_impl_.job_id_source_);
  swap(_impl_.job_id_target_, other->_impl_.job_id_target_);
}

std::string CMsgProtoBufHeader::GetTypeName() const {
  return "CMsgProtoBufHeader";
}


// ===================================================================

class CMsgWebAPIKey::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgWebAPIKey>()._impl_._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_publisher_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_key_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_domain(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgWebAPIKey::CMsgWebAPIKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgWebAPIKey)
}
CMsgWebAPIKey::CMsgWebAPIKey(const CMsgWebAPIKey& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgWebAPIKey* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.domain_){}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.publisher_group_id_){}
    , decltype(_impl_.key_id_){}
    , decltype(_impl_.status_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.domain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.domain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_domain()) {
    _this->_impl_.domain_.Set(from._internal_domain(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.status_));
  // @@protoc_insertion_point(copy_constructor:CMsgWebAPIKey)
}

inline void CMsgWebAPIKey::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.domain_){}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.publisher_group_id_){0u}
    , decltype(_impl_.key_id_){0u}
    , decltype(_impl_.status_){255u}
  };
  _impl_.domain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.domain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgWebAPIKey::~CMsgWebAPIKey() {
  // @@protoc_insertion_point(destructor:CMsgWebAPIKey)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgWebAPIKey::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.domain_.Destroy();
}

void CMsgWebAPIKey::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgWebAPIKey::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgWebAPIKey)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.domain_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.key_id_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.key_id_));
    _impl_.status_ = 255u;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgWebAPIKey::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 status = 1 [default = 255];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_status(&has_bits);
          _impl_.status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 account_id = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 publisher_group_id = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_publisher_group_id(&has_bits);
          _impl_.publisher_group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 key_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_key_id(&has_bits);
          _impl_.key_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string domain = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_domain();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgWebAPIKey::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgWebAPIKey)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 status = 1 [default = 255];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_status(), target);
  }

  // optional uint32 account_id = 2 [default = 0];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_account_id(), target);
  }

  // optional uint32 publisher_group_id = 3 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_publisher_group_id(), target);
  }

  // optional uint32 key_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_key_id(), target);
  }

  // optional string domain = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_domain(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgWebAPIKey)
  return target;
}

size_t CMsgWebAPIKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgWebAPIKey)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string domain = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_domain());
    }

    // optional uint32 account_id = 2 [default = 0];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 publisher_group_id = 3 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_publisher_group_id());
    }

    // optional uint32 key_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_key_id());
    }

    // optional uint32 status = 1 [default = 255];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_status());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgWebAPIKey::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgWebAPIKey*>(
      &from));
}

void CMsgWebAPIKey::MergeFrom(const CMsgWebAPIKey& from) {
  CMsgWebAPIKey* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgWebAPIKey)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_domain(from._internal_domain());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.publisher_group_id_ = from._impl_.publisher_group_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.key_id_ = from._impl_.key_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgWebAPIKey::CopyFrom(const CMsgWebAPIKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgWebAPIKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgWebAPIKey::IsInitialized() const {
  return true;
}

void CMsgWebAPIKey::InternalSwap(CMsgWebAPIKey* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.domain_, lhs_arena,
      &other->_impl_.domain_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgWebAPIKey, _impl_.key_id_)
      + sizeof(CMsgWebAPIKey::_impl_.key_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgWebAPIKey, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
  swap(_impl_.status_, other->_impl_.status_);
}

std::string CMsgWebAPIKey::GetTypeName() const {
  return "CMsgWebAPIKey";
}


// ===================================================================

class CMsgHttpRequest_RequestHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgHttpRequest_RequestHeader>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgHttpRequest_RequestHeader::CMsgHttpRequest_RequestHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgHttpRequest.RequestHeader)
}
CMsgHttpRequest_RequestHeader::CMsgHttpRequest_RequestHeader(const CMsgHttpRequest_RequestHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgHttpRequest_RequestHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgHttpRequest.RequestHeader)
}

inline void CMsgHttpRequest_RequestHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgHttpRequest_RequestHeader::~CMsgHttpRequest_RequestHeader() {
  // @@protoc_insertion_point(destructor:CMsgHttpRequest.RequestHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgHttpRequest_RequestHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.value_.Destroy();
}

void CMsgHttpRequest_RequestHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgHttpRequest_RequestHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgHttpRequest.RequestHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgHttpRequest_RequestHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgHttpRequest_RequestHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgHttpRequest.RequestHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgHttpRequest.RequestHeader)
  return target;
}

size_t CMsgHttpRequest_RequestHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgHttpRequest.RequestHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgHttpRequest_RequestHeader::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgHttpRequest_RequestHeader*>(
      &from));
}

void CMsgHttpRequest_RequestHeader::MergeFrom(const CMsgHttpRequest_RequestHeader& from) {
  CMsgHttpRequest_RequestHeader* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgHttpRequest.RequestHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgHttpRequest_RequestHeader::CopyFrom(const CMsgHttpRequest_RequestHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgHttpRequest.RequestHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgHttpRequest_RequestHeader::IsInitialized() const {
  return true;
}

void CMsgHttpRequest_RequestHeader::InternalSwap(CMsgHttpRequest_RequestHeader* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

std::string CMsgHttpRequest_RequestHeader::GetTypeName() const {
  return "CMsgHttpRequest.RequestHeader";
}


// ===================================================================

class CMsgHttpRequest_QueryParam::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgHttpRequest_QueryParam>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgHttpRequest_QueryParam::CMsgHttpRequest_QueryParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgHttpRequest.QueryParam)
}
CMsgHttpRequest_QueryParam::CMsgHttpRequest_QueryParam(const CMsgHttpRequest_QueryParam& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgHttpRequest_QueryParam* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgHttpRequest.QueryParam)
}

inline void CMsgHttpRequest_QueryParam::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgHttpRequest_QueryParam::~CMsgHttpRequest_QueryParam() {
  // @@protoc_insertion_point(destructor:CMsgHttpRequest.QueryParam)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgHttpRequest_QueryParam::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.value_.Destroy();
}

void CMsgHttpRequest_QueryParam::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgHttpRequest_QueryParam::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgHttpRequest.QueryParam)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgHttpRequest_QueryParam::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgHttpRequest_QueryParam::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgHttpRequest.QueryParam)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional bytes value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgHttpRequest.QueryParam)
  return target;
}

size_t CMsgHttpRequest_QueryParam::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgHttpRequest.QueryParam)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional bytes value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_value());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgHttpRequest_QueryParam::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgHttpRequest_QueryParam*>(
      &from));
}

void CMsgHttpRequest_QueryParam::MergeFrom(const CMsgHttpRequest_QueryParam& from) {
  CMsgHttpRequest_QueryParam* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgHttpRequest.QueryParam)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgHttpRequest_QueryParam::CopyFrom(const CMsgHttpRequest_QueryParam& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgHttpRequest.QueryParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgHttpRequest_QueryParam::IsInitialized() const {
  return true;
}

void CMsgHttpRequest_QueryParam::InternalSwap(CMsgHttpRequest_QueryParam* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

std::string CMsgHttpRequest_QueryParam::GetTypeName() const {
  return "CMsgHttpRequest.QueryParam";
}


// ===================================================================

class CMsgHttpRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgHttpRequest>()._impl_._has_bits_);
  static void set_has_request_method(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_hostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_body(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_absolute_timeout(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CMsgHttpRequest::CMsgHttpRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgHttpRequest)
}
CMsgHttpRequest::CMsgHttpRequest(const CMsgHttpRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgHttpRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.headers_){from._impl_.headers_}
    , decltype(_impl_.get_params_){from._impl_.get_params_}
    , decltype(_impl_.post_params_){from._impl_.post_params_}
    , decltype(_impl_.hostname_){}
    , decltype(_impl_.url_){}
    , decltype(_impl_.body_){}
    , decltype(_impl_.request_method_){}
    , decltype(_impl_.absolute_timeout_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.hostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hostname()) {
    _this->_impl_.hostname_.Set(from._internal_hostname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_body()) {
    _this->_impl_.body_.Set(from._internal_body(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.request_method_, &from._impl_.request_method_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.absolute_timeout_) -
    reinterpret_cast<char*>(&_impl_.request_method_)) + sizeof(_impl_.absolute_timeout_));
  // @@protoc_insertion_point(copy_constructor:CMsgHttpRequest)
}

inline void CMsgHttpRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.headers_){arena}
    , decltype(_impl_.get_params_){arena}
    , decltype(_impl_.post_params_){arena}
    , decltype(_impl_.hostname_){}
    , decltype(_impl_.url_){}
    , decltype(_impl_.body_){}
    , decltype(_impl_.request_method_){0u}
    , decltype(_impl_.absolute_timeout_){0u}
  };
  _impl_.hostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgHttpRequest::~CMsgHttpRequest() {
  // @@protoc_insertion_point(destructor:CMsgHttpRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgHttpRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.headers_.~RepeatedPtrField();
  _impl_.get_params_.~RepeatedPtrField();
  _impl_.post_params_.~RepeatedPtrField();
  _impl_.hostname_.Destroy();
  _impl_.url_.Destroy();
  _impl_.body_.Destroy();
}

void CMsgHttpRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgHttpRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgHttpRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.headers_.Clear();
  _impl_.get_params_.Clear();
  _impl_.post_params_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.hostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.body_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.request_method_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.absolute_timeout_) -
        reinterpret_cast<char*>(&_impl_.request_method_)) + sizeof(_impl_.absolute_timeout_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgHttpRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 request_method = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_request_method(&has_bits);
          _impl_.request_method_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string hostname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_hostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string url = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgHttpRequest.RequestHeader headers = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_headers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgHttpRequest.QueryParam get_params = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_get_params(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgHttpRequest.QueryParam post_params = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_post_params(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes body = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_body();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 absolute_timeout = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_absolute_timeout(&has_bits);
          _impl_.absolute_timeout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgHttpRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgHttpRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 request_method = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_request_method(), target);
  }

  // optional string hostname = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_hostname(), target);
  }

  // optional string url = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_url(), target);
  }

  // repeated .CMsgHttpRequest.RequestHeader headers = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_headers_size()); i < n; i++) {
    const auto& repfield = this->_internal_headers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgHttpRequest.QueryParam get_params = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_get_params_size()); i < n; i++) {
    const auto& repfield = this->_internal_get_params(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgHttpRequest.QueryParam post_params = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_post_params_size()); i < n; i++) {
    const auto& repfield = this->_internal_post_params(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes body = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_body(), target);
  }

  // optional uint32 absolute_timeout = 8;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_absolute_timeout(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgHttpRequest)
  return target;
}

size_t CMsgHttpRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgHttpRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgHttpRequest.RequestHeader headers = 4;
  total_size += 1UL * this->_internal_headers_size();
  for (const auto& msg : this->_impl_.headers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgHttpRequest.QueryParam get_params = 5;
  total_size += 1UL * this->_internal_get_params_size();
  for (const auto& msg : this->_impl_.get_params_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgHttpRequest.QueryParam post_params = 6;
  total_size += 1UL * this->_internal_post_params_size();
  for (const auto& msg : this->_impl_.post_params_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string hostname = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_hostname());
    }

    // optional string url = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional bytes body = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_body());
    }

    // optional uint32 request_method = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_request_method());
    }

    // optional uint32 absolute_timeout = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_absolute_timeout());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgHttpRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgHttpRequest*>(
      &from));
}

void CMsgHttpRequest::MergeFrom(const CMsgHttpRequest& from) {
  CMsgHttpRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgHttpRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.headers_.MergeFrom(from._impl_.headers_);
  _this->_impl_.get_params_.MergeFrom(from._impl_.get_params_);
  _this->_impl_.post_params_.MergeFrom(from._impl_.post_params_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_hostname(from._internal_hostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_body(from._internal_body());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.request_method_ = from._impl_.request_method_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.absolute_timeout_ = from._impl_.absolute_timeout_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgHttpRequest::CopyFrom(const CMsgHttpRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgHttpRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgHttpRequest::IsInitialized() const {
  return true;
}

void CMsgHttpRequest::InternalSwap(CMsgHttpRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.headers_.InternalSwap(&other->_impl_.headers_);
  _impl_.get_params_.InternalSwap(&other->_impl_.get_params_);
  _impl_.post_params_.InternalSwap(&other->_impl_.post_params_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hostname_, lhs_arena,
      &other->_impl_.hostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.body_, lhs_arena,
      &other->_impl_.body_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgHttpRequest, _impl_.absolute_timeout_)
      + sizeof(CMsgHttpRequest::_impl_.absolute_timeout_)
      - PROTOBUF_FIELD_OFFSET(CMsgHttpRequest, _impl_.request_method_)>(
          reinterpret_cast<char*>(&_impl_.request_method_),
          reinterpret_cast<char*>(&other->_impl_.request_method_));
}

std::string CMsgHttpRequest::GetTypeName() const {
  return "CMsgHttpRequest";
}


// ===================================================================

class CMsgWebAPIRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgWebAPIRequest>()._impl_._has_bits_);
  static void set_has_unused_job_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_interface_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_method_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::CMsgWebAPIKey& api_key(const CMsgWebAPIRequest* msg);
  static void set_has_api_key(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CMsgHttpRequest& request(const CMsgWebAPIRequest* msg);
  static void set_has_request(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_routing_app_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::CMsgWebAPIKey&
CMsgWebAPIRequest::_Internal::api_key(const CMsgWebAPIRequest* msg) {
  return *msg->_impl_.api_key_;
}
const ::CMsgHttpRequest&
CMsgWebAPIRequest::_Internal::request(const CMsgWebAPIRequest* msg) {
  return *msg->_impl_.request_;
}
CMsgWebAPIRequest::CMsgWebAPIRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgWebAPIRequest)
}
CMsgWebAPIRequest::CMsgWebAPIRequest(const CMsgWebAPIRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgWebAPIRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.unused_job_name_){}
    , decltype(_impl_.interface_name_){}
    , decltype(_impl_.method_name_){}
    , decltype(_impl_.api_key_){nullptr}
    , decltype(_impl_.request_){nullptr}
    , decltype(_impl_.version_){}
    , decltype(_impl_.routing_app_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.unused_job_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.unused_job_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_unused_job_name()) {
    _this->_impl_.unused_job_name_.Set(from._internal_unused_job_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.interface_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.interface_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_interface_name()) {
    _this->_impl_.interface_name_.Set(from._internal_interface_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.method_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.method_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_method_name()) {
    _this->_impl_.method_name_.Set(from._internal_method_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_api_key()) {
    _this->_impl_.api_key_ = new ::CMsgWebAPIKey(*from._impl_.api_key_);
  }
  if (from._internal_has_request()) {
    _this->_impl_.request_ = new ::CMsgHttpRequest(*from._impl_.request_);
  }
  ::memcpy(&_impl_.version_, &from._impl_.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.routing_app_id_) -
    reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.routing_app_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgWebAPIRequest)
}

inline void CMsgWebAPIRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.unused_job_name_){}
    , decltype(_impl_.interface_name_){}
    , decltype(_impl_.method_name_){}
    , decltype(_impl_.api_key_){nullptr}
    , decltype(_impl_.request_){nullptr}
    , decltype(_impl_.version_){0u}
    , decltype(_impl_.routing_app_id_){0u}
  };
  _impl_.unused_job_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.unused_job_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.interface_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.interface_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.method_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.method_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgWebAPIRequest::~CMsgWebAPIRequest() {
  // @@protoc_insertion_point(destructor:CMsgWebAPIRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgWebAPIRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.unused_job_name_.Destroy();
  _impl_.interface_name_.Destroy();
  _impl_.method_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.api_key_;
  if (this != internal_default_instance()) delete _impl_.request_;
}

void CMsgWebAPIRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgWebAPIRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgWebAPIRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.unused_job_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.interface_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.method_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.api_key_ != nullptr);
      _impl_.api_key_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.request_ != nullptr);
      _impl_.request_->Clear();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&_impl_.version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.routing_app_id_) -
        reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.routing_app_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgWebAPIRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string UNUSED_job_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_unused_job_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string interface_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_interface_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string method_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_method_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 version = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgWebAPIKey api_key = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_api_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgHttpRequest request = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 routing_app_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_routing_app_id(&has_bits);
          _impl_.routing_app_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgWebAPIRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgWebAPIRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string UNUSED_job_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_unused_job_name(), target);
  }

  // optional string interface_name = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_interface_name(), target);
  }

  // optional string method_name = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_method_name(), target);
  }

  // optional uint32 version = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_version(), target);
  }

  // optional .CMsgWebAPIKey api_key = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::api_key(this),
        _Internal::api_key(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgHttpRequest request = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::request(this),
        _Internal::request(this).GetCachedSize(), target, stream);
  }

  // optional uint32 routing_app_id = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_routing_app_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgWebAPIRequest)
  return target;
}

size_t CMsgWebAPIRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgWebAPIRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string UNUSED_job_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_unused_job_name());
    }

    // optional string interface_name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_interface_name());
    }

    // optional string method_name = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_method_name());
    }

    // optional .CMsgWebAPIKey api_key = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.api_key_);
    }

    // optional .CMsgHttpRequest request = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_);
    }

    // optional uint32 version = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
    }

    // optional uint32 routing_app_id = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_routing_app_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgWebAPIRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgWebAPIRequest*>(
      &from));
}

void CMsgWebAPIRequest::MergeFrom(const CMsgWebAPIRequest& from) {
  CMsgWebAPIRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgWebAPIRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_unused_job_name(from._internal_unused_job_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_interface_name(from._internal_interface_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_method_name(from._internal_method_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_api_key()->::CMsgWebAPIKey::MergeFrom(
          from._internal_api_key());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_request()->::CMsgHttpRequest::MergeFrom(
          from._internal_request());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.routing_app_id_ = from._impl_.routing_app_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgWebAPIRequest::CopyFrom(const CMsgWebAPIRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgWebAPIRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgWebAPIRequest::IsInitialized() const {
  return true;
}

void CMsgWebAPIRequest::InternalSwap(CMsgWebAPIRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.unused_job_name_, lhs_arena,
      &other->_impl_.unused_job_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.interface_name_, lhs_arena,
      &other->_impl_.interface_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.method_name_, lhs_arena,
      &other->_impl_.method_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgWebAPIRequest, _impl_.routing_app_id_)
      + sizeof(CMsgWebAPIRequest::_impl_.routing_app_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgWebAPIRequest, _impl_.api_key_)>(
          reinterpret_cast<char*>(&_impl_.api_key_),
          reinterpret_cast<char*>(&other->_impl_.api_key_));
}

std::string CMsgWebAPIRequest::GetTypeName() const {
  return "CMsgWebAPIRequest";
}


// ===================================================================

class CMsgHttpResponse_ResponseHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgHttpResponse_ResponseHeader>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgHttpResponse_ResponseHeader::CMsgHttpResponse_ResponseHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgHttpResponse.ResponseHeader)
}
CMsgHttpResponse_ResponseHeader::CMsgHttpResponse_ResponseHeader(const CMsgHttpResponse_ResponseHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgHttpResponse_ResponseHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgHttpResponse.ResponseHeader)
}

inline void CMsgHttpResponse_ResponseHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgHttpResponse_ResponseHeader::~CMsgHttpResponse_ResponseHeader() {
  // @@protoc_insertion_point(destructor:CMsgHttpResponse.ResponseHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgHttpResponse_ResponseHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.value_.Destroy();
}

void CMsgHttpResponse_ResponseHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgHttpResponse_ResponseHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgHttpResponse.ResponseHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgHttpResponse_ResponseHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgHttpResponse_ResponseHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgHttpResponse.ResponseHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgHttpResponse.ResponseHeader)
  return target;
}

size_t CMsgHttpResponse_ResponseHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgHttpResponse.ResponseHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgHttpResponse_ResponseHeader::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgHttpResponse_ResponseHeader*>(
      &from));
}

void CMsgHttpResponse_ResponseHeader::MergeFrom(const CMsgHttpResponse_ResponseHeader& from) {
  CMsgHttpResponse_ResponseHeader* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgHttpResponse.ResponseHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgHttpResponse_ResponseHeader::CopyFrom(const CMsgHttpResponse_ResponseHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgHttpResponse.ResponseHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgHttpResponse_ResponseHeader::IsInitialized() const {
  return true;
}

void CMsgHttpResponse_ResponseHeader::InternalSwap(CMsgHttpResponse_ResponseHeader* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

std::string CMsgHttpResponse_ResponseHeader::GetTypeName() const {
  return "CMsgHttpResponse.ResponseHeader";
}


// ===================================================================

class CMsgHttpResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgHttpResponse>()._impl_._has_bits_);
  static void set_has_status_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_body(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgHttpResponse::CMsgHttpResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgHttpResponse)
}
CMsgHttpResponse::CMsgHttpResponse(const CMsgHttpResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgHttpResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.headers_){from._impl_.headers_}
    , decltype(_impl_.body_){}
    , decltype(_impl_.status_code_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_body()) {
    _this->_impl_.body_.Set(from._internal_body(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.status_code_ = from._impl_.status_code_;
  // @@protoc_insertion_point(copy_constructor:CMsgHttpResponse)
}

inline void CMsgHttpResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.headers_){arena}
    , decltype(_impl_.body_){}
    , decltype(_impl_.status_code_){0u}
  };
  _impl_.body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgHttpResponse::~CMsgHttpResponse() {
  // @@protoc_insertion_point(destructor:CMsgHttpResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgHttpResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.headers_.~RepeatedPtrField();
  _impl_.body_.Destroy();
}

void CMsgHttpResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgHttpResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgHttpResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.headers_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.body_.ClearNonDefaultToEmpty();
  }
  _impl_.status_code_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgHttpResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 status_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_status_code(&has_bits);
          _impl_.status_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgHttpResponse.ResponseHeader headers = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_headers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes body = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_body();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgHttpResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgHttpResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 status_code = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_status_code(), target);
  }

  // repeated .CMsgHttpResponse.ResponseHeader headers = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_headers_size()); i < n; i++) {
    const auto& repfield = this->_internal_headers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes body = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_body(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgHttpResponse)
  return target;
}

size_t CMsgHttpResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgHttpResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgHttpResponse.ResponseHeader headers = 2;
  total_size += 1UL * this->_internal_headers_size();
  for (const auto& msg : this->_impl_.headers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes body = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_body());
    }

    // optional uint32 status_code = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_status_code());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgHttpResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgHttpResponse*>(
      &from));
}

void CMsgHttpResponse::MergeFrom(const CMsgHttpResponse& from) {
  CMsgHttpResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgHttpResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.headers_.MergeFrom(from._impl_.headers_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_body(from._internal_body());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.status_code_ = from._impl_.status_code_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgHttpResponse::CopyFrom(const CMsgHttpResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgHttpResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgHttpResponse::IsInitialized() const {
  return true;
}

void CMsgHttpResponse::InternalSwap(CMsgHttpResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.headers_.InternalSwap(&other->_impl_.headers_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.body_, lhs_arena,
      &other->_impl_.body_, rhs_arena
  );
  swap(_impl_.status_code_, other->_impl_.status_code_);
}

std::string CMsgHttpResponse::GetTypeName() const {
  return "CMsgHttpResponse";
}


// ===================================================================

class CMsgAMFindAccounts::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgAMFindAccounts>()._impl_._has_bits_);
  static void set_has_search_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_search_string(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgAMFindAccounts::CMsgAMFindAccounts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgAMFindAccounts)
}
CMsgAMFindAccounts::CMsgAMFindAccounts(const CMsgAMFindAccounts& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgAMFindAccounts* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.search_string_){}
    , decltype(_impl_.search_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.search_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.search_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_search_string()) {
    _this->_impl_.search_string_.Set(from._internal_search_string(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.search_type_ = from._impl_.search_type_;
  // @@protoc_insertion_point(copy_constructor:CMsgAMFindAccounts)
}

inline void CMsgAMFindAccounts::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.search_string_){}
    , decltype(_impl_.search_type_){0u}
  };
  _impl_.search_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.search_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgAMFindAccounts::~CMsgAMFindAccounts() {
  // @@protoc_insertion_point(destructor:CMsgAMFindAccounts)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgAMFindAccounts::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.search_string_.Destroy();
}

void CMsgAMFindAccounts::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgAMFindAccounts::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgAMFindAccounts)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.search_string_.ClearNonDefaultToEmpty();
  }
  _impl_.search_type_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgAMFindAccounts::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 search_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_search_type(&has_bits);
          _impl_.search_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string search_string = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_search_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgAMFindAccounts::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgAMFindAccounts)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 search_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_search_type(), target);
  }

  // optional string search_string = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_search_string(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgAMFindAccounts)
  return target;
}

size_t CMsgAMFindAccounts::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgAMFindAccounts)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string search_string = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_search_string());
    }

    // optional uint32 search_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_search_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgAMFindAccounts::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgAMFindAccounts*>(
      &from));
}

void CMsgAMFindAccounts::MergeFrom(const CMsgAMFindAccounts& from) {
  CMsgAMFindAccounts* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgAMFindAccounts)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_search_string(from._internal_search_string());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.search_type_ = from._impl_.search_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgAMFindAccounts::CopyFrom(const CMsgAMFindAccounts& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgAMFindAccounts)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgAMFindAccounts::IsInitialized() const {
  return true;
}

void CMsgAMFindAccounts::InternalSwap(CMsgAMFindAccounts* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.search_string_, lhs_arena,
      &other->_impl_.search_string_, rhs_arena
  );
  swap(_impl_.search_type_, other->_impl_.search_type_);
}

std::string CMsgAMFindAccounts::GetTypeName() const {
  return "CMsgAMFindAccounts";
}


// ===================================================================

class CMsgAMFindAccountsResponse::_Internal {
 public:
};

CMsgAMFindAccountsResponse::CMsgAMFindAccountsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgAMFindAccountsResponse)
}
CMsgAMFindAccountsResponse::CMsgAMFindAccountsResponse(const CMsgAMFindAccountsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgAMFindAccountsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.steam_id_){from._impl_.steam_id_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgAMFindAccountsResponse)
}

inline void CMsgAMFindAccountsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.steam_id_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgAMFindAccountsResponse::~CMsgAMFindAccountsResponse() {
  // @@protoc_insertion_point(destructor:CMsgAMFindAccountsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgAMFindAccountsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.steam_id_.~RepeatedField();
}

void CMsgAMFindAccountsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgAMFindAccountsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgAMFindAccountsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.steam_id_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgAMFindAccountsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated fixed64 steam_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_steam_id(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr));
            ptr += sizeof(uint64_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<9>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed64Parser(_internal_mutable_steam_id(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgAMFindAccountsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgAMFindAccountsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated fixed64 steam_id = 1;
  for (int i = 0, n = this->_internal_steam_id_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steam_id(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgAMFindAccountsResponse)
  return target;
}

size_t CMsgAMFindAccountsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgAMFindAccountsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed64 steam_id = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_steam_id_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_steam_id_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgAMFindAccountsResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgAMFindAccountsResponse*>(
      &from));
}

void CMsgAMFindAccountsResponse::MergeFrom(const CMsgAMFindAccountsResponse& from) {
  CMsgAMFindAccountsResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgAMFindAccountsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.steam_id_.MergeFrom(from._impl_.steam_id_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgAMFindAccountsResponse::CopyFrom(const CMsgAMFindAccountsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgAMFindAccountsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgAMFindAccountsResponse::IsInitialized() const {
  return true;
}

void CMsgAMFindAccountsResponse::InternalSwap(CMsgAMFindAccountsResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.steam_id_.InternalSwap(&other->_impl_.steam_id_);
}

std::string CMsgAMFindAccountsResponse::GetTypeName() const {
  return "CMsgAMFindAccountsResponse";
}


// ===================================================================

class CMsgNotifyWatchdog::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgNotifyWatchdog>()._impl_._has_bits_);
  static void set_has_source(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_alert_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_alert_destination(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_critical(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgNotifyWatchdog::CMsgNotifyWatchdog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgNotifyWatchdog)
}
CMsgNotifyWatchdog::CMsgNotifyWatchdog(const CMsgNotifyWatchdog& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgNotifyWatchdog* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.text_){}
    , decltype(_impl_.source_){}
    , decltype(_impl_.alert_type_){}
    , decltype(_impl_.alert_destination_){}
    , decltype(_impl_.critical_){}
    , decltype(_impl_.time_){}
    , decltype(_impl_.appid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_text()) {
    _this->_impl_.text_.Set(from._internal_text(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.source_, &from._impl_.source_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.appid_) -
    reinterpret_cast<char*>(&_impl_.source_)) + sizeof(_impl_.appid_));
  // @@protoc_insertion_point(copy_constructor:CMsgNotifyWatchdog)
}

inline void CMsgNotifyWatchdog::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.text_){}
    , decltype(_impl_.source_){0u}
    , decltype(_impl_.alert_type_){0u}
    , decltype(_impl_.alert_destination_){0u}
    , decltype(_impl_.critical_){false}
    , decltype(_impl_.time_){0u}
    , decltype(_impl_.appid_){0u}
  };
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgNotifyWatchdog::~CMsgNotifyWatchdog() {
  // @@protoc_insertion_point(destructor:CMsgNotifyWatchdog)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgNotifyWatchdog::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.text_.Destroy();
}

void CMsgNotifyWatchdog::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgNotifyWatchdog::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgNotifyWatchdog)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.text_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&_impl_.source_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.appid_) -
        reinterpret_cast<char*>(&_impl_.source_)) + sizeof(_impl_.appid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgNotifyWatchdog::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 source = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_source(&has_bits);
          _impl_.source_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 alert_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_alert_type(&has_bits);
          _impl_.alert_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 alert_destination = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_alert_destination(&has_bits);
          _impl_.alert_destination_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool critical = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_critical(&has_bits);
          _impl_.critical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_time(&has_bits);
          _impl_.time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 appid = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_appid(&has_bits);
          _impl_.appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string text = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgNotifyWatchdog::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgNotifyWatchdog)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 source = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_source(), target);
  }

  // optional uint32 alert_type = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_alert_type(), target);
  }

  // optional uint32 alert_destination = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_alert_destination(), target);
  }

  // optional bool critical = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_critical(), target);
  }

  // optional uint32 time = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_time(), target);
  }

  // optional uint32 appid = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_appid(), target);
  }

  // optional string text = 7;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgNotifyWatchdog)
  return target;
}

size_t CMsgNotifyWatchdog::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgNotifyWatchdog)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string text = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_text());
    }

    // optional uint32 source = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_source());
    }

    // optional uint32 alert_type = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_alert_type());
    }

    // optional uint32 alert_destination = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_alert_destination());
    }

    // optional bool critical = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional uint32 time = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_time());
    }

    // optional uint32 appid = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgNotifyWatchdog::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgNotifyWatchdog*>(
      &from));
}

void CMsgNotifyWatchdog::MergeFrom(const CMsgNotifyWatchdog& from) {
  CMsgNotifyWatchdog* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgNotifyWatchdog)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_text(from._internal_text());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.source_ = from._impl_.source_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.alert_type_ = from._impl_.alert_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.alert_destination_ = from._impl_.alert_destination_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.critical_ = from._impl_.critical_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.time_ = from._impl_.time_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.appid_ = from._impl_.appid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgNotifyWatchdog::CopyFrom(const CMsgNotifyWatchdog& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgNotifyWatchdog)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgNotifyWatchdog::IsInitialized() const {
  return true;
}

void CMsgNotifyWatchdog::InternalSwap(CMsgNotifyWatchdog* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.text_, lhs_arena,
      &other->_impl_.text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgNotifyWatchdog, _impl_.appid_)
      + sizeof(CMsgNotifyWatchdog::_impl_.appid_)
      - PROTOBUF_FIELD_OFFSET(CMsgNotifyWatchdog, _impl_.source_)>(
          reinterpret_cast<char*>(&_impl_.source_),
          reinterpret_cast<char*>(&other->_impl_.source_));
}

std::string CMsgNotifyWatchdog::GetTypeName() const {
  return "CMsgNotifyWatchdog";
}


// ===================================================================

class CMsgAMGetLicenses::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgAMGetLicenses>()._impl_._has_bits_);
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgAMGetLicenses::CMsgAMGetLicenses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgAMGetLicenses)
}
CMsgAMGetLicenses::CMsgAMGetLicenses(const CMsgAMGetLicenses& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgAMGetLicenses* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steamid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.steamid_ = from._impl_.steamid_;
  // @@protoc_insertion_point(copy_constructor:CMsgAMGetLicenses)
}

inline void CMsgAMGetLicenses::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steamid_){uint64_t{0u}}
  };
}

CMsgAMGetLicenses::~CMsgAMGetLicenses() {
  // @@protoc_insertion_point(destructor:CMsgAMGetLicenses)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgAMGetLicenses::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgAMGetLicenses::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgAMGetLicenses::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgAMGetLicenses)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.steamid_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgAMGetLicenses::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steamid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steamid(&has_bits);
          _impl_.steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgAMGetLicenses::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgAMGetLicenses)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steamid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steamid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgAMGetLicenses)
  return target;
}

size_t CMsgAMGetLicenses::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgAMGetLicenses)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional fixed64 steamid = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 8;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgAMGetLicenses::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgAMGetLicenses*>(
      &from));
}

void CMsgAMGetLicenses::MergeFrom(const CMsgAMGetLicenses& from) {
  CMsgAMGetLicenses* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgAMGetLicenses)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_steamid()) {
    _this->_internal_set_steamid(from._internal_steamid());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgAMGetLicenses::CopyFrom(const CMsgAMGetLicenses& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgAMGetLicenses)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgAMGetLicenses::IsInitialized() const {
  return true;
}

void CMsgAMGetLicenses::InternalSwap(CMsgAMGetLicenses* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.steamid_, other->_impl_.steamid_);
}

std::string CMsgAMGetLicenses::GetTypeName() const {
  return "CMsgAMGetLicenses";
}


// ===================================================================

class CMsgPackageLicense::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgPackageLicense>()._impl_._has_bits_);
  static void set_has_package_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_time_created(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_owner_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgPackageLicense::CMsgPackageLicense(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgPackageLicense)
}
CMsgPackageLicense::CMsgPackageLicense(const CMsgPackageLicense& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgPackageLicense* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.package_id_){}
    , decltype(_impl_.time_created_){}
    , decltype(_impl_.owner_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.package_id_, &from._impl_.package_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.owner_id_) -
    reinterpret_cast<char*>(&_impl_.package_id_)) + sizeof(_impl_.owner_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgPackageLicense)
}

inline void CMsgPackageLicense::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.package_id_){0u}
    , decltype(_impl_.time_created_){0u}
    , decltype(_impl_.owner_id_){0u}
  };
}

CMsgPackageLicense::~CMsgPackageLicense() {
  // @@protoc_insertion_point(destructor:CMsgPackageLicense)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgPackageLicense::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgPackageLicense::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgPackageLicense::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgPackageLicense)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.package_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.owner_id_) -
        reinterpret_cast<char*>(&_impl_.package_id_)) + sizeof(_impl_.owner_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgPackageLicense::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 package_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_package_id(&has_bits);
          _impl_.package_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 time_created = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_time_created(&has_bits);
          _impl_.time_created_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 owner_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_owner_id(&has_bits);
          _impl_.owner_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgPackageLicense::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgPackageLicense)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 package_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_package_id(), target);
  }

  // optional uint32 time_created = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_time_created(), target);
  }

  // optional uint32 owner_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_owner_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgPackageLicense)
  return target;
}

size_t CMsgPackageLicense::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgPackageLicense)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 package_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_package_id());
    }

    // optional uint32 time_created = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_time_created());
    }

    // optional uint32 owner_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_owner_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgPackageLicense::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgPackageLicense*>(
      &from));
}

void CMsgPackageLicense::MergeFrom(const CMsgPackageLicense& from) {
  CMsgPackageLicense* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgPackageLicense)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.package_id_ = from._impl_.package_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.time_created_ = from._impl_.time_created_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.owner_id_ = from._impl_.owner_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgPackageLicense::CopyFrom(const CMsgPackageLicense& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgPackageLicense)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgPackageLicense::IsInitialized() const {
  return true;
}

void CMsgPackageLicense::InternalSwap(CMsgPackageLicense* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgPackageLicense, _impl_.owner_id_)
      + sizeof(CMsgPackageLicense::_impl_.owner_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgPackageLicense, _impl_.package_id_)>(
          reinterpret_cast<char*>(&_impl_.package_id_),
          reinterpret_cast<char*>(&other->_impl_.package_id_));
}

std::string CMsgPackageLicense::GetTypeName() const {
  return "CMsgPackageLicense";
}


// ===================================================================

class CMsgAMGetLicensesResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgAMGetLicensesResponse>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgAMGetLicensesResponse::CMsgAMGetLicensesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgAMGetLicensesResponse)
}
CMsgAMGetLicensesResponse::CMsgAMGetLicensesResponse(const CMsgAMGetLicensesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgAMGetLicensesResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.license_){from._impl_.license_}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:CMsgAMGetLicensesResponse)
}

inline void CMsgAMGetLicensesResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.license_){arena}
    , decltype(_impl_.result_){0u}
  };
}

CMsgAMGetLicensesResponse::~CMsgAMGetLicensesResponse() {
  // @@protoc_insertion_point(destructor:CMsgAMGetLicensesResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgAMGetLicensesResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.license_.~RepeatedPtrField();
}

void CMsgAMGetLicensesResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgAMGetLicensesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgAMGetLicensesResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.license_.Clear();
  _impl_.result_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgAMGetLicensesResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgPackageLicense license = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_license(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 result = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_result(&has_bits);
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgAMGetLicensesResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgAMGetLicensesResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgPackageLicense license = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_license_size()); i < n; i++) {
    const auto& repfield = this->_internal_license(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 result = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgAMGetLicensesResponse)
  return target;
}

size_t CMsgAMGetLicensesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgAMGetLicensesResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgPackageLicense license = 1;
  total_size += 1UL * this->_internal_license_size();
  for (const auto& msg : this->_impl_.license_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint32 result = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_result());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgAMGetLicensesResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgAMGetLicensesResponse*>(
      &from));
}

void CMsgAMGetLicensesResponse::MergeFrom(const CMsgAMGetLicensesResponse& from) {
  CMsgAMGetLicensesResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgAMGetLicensesResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.license_.MergeFrom(from._impl_.license_);
  if (from._internal_has_result()) {
    _this->_internal_set_result(from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgAMGetLicensesResponse::CopyFrom(const CMsgAMGetLicensesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgAMGetLicensesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgAMGetLicensesResponse::IsInitialized() const {
  return true;
}

void CMsgAMGetLicensesResponse::InternalSwap(CMsgAMGetLicensesResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.license_.InternalSwap(&other->_impl_.license_);
  swap(_impl_.result_, other->_impl_.result_);
}

std::string CMsgAMGetLicensesResponse::GetTypeName() const {
  return "CMsgAMGetLicensesResponse";
}


// ===================================================================

class CMsgAMGetUserGameStats::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgAMGetUserGameStats>()._impl_._has_bits_);
  static void set_has_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_game_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgAMGetUserGameStats::CMsgAMGetUserGameStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgAMGetUserGameStats)
}
CMsgAMGetUserGameStats::CMsgAMGetUserGameStats(const CMsgAMGetUserGameStats& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgAMGetUserGameStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stats_){from._impl_.stats_}
    , decltype(_impl_.steam_id_){}
    , decltype(_impl_.game_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.steam_id_, &from._impl_.steam_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.game_id_) -
    reinterpret_cast<char*>(&_impl_.steam_id_)) + sizeof(_impl_.game_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgAMGetUserGameStats)
}

inline void CMsgAMGetUserGameStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stats_){arena}
    , decltype(_impl_.steam_id_){uint64_t{0u}}
    , decltype(_impl_.game_id_){uint64_t{0u}}
  };
}

CMsgAMGetUserGameStats::~CMsgAMGetUserGameStats() {
  // @@protoc_insertion_point(destructor:CMsgAMGetUserGameStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgAMGetUserGameStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stats_.~RepeatedField();
}

void CMsgAMGetUserGameStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgAMGetUserGameStats::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgAMGetUserGameStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stats_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.steam_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.game_id_) -
        reinterpret_cast<char*>(&_impl_.steam_id_)) + sizeof(_impl_.game_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgAMGetUserGameStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steam_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steam_id(&has_bits);
          _impl_.steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 game_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_game_id(&has_bits);
          _impl_.game_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 stats = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_stats(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_stats(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgAMGetUserGameStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgAMGetUserGameStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steam_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steam_id(), target);
  }

  // optional fixed64 game_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_game_id(), target);
  }

  // repeated uint32 stats = 3;
  for (int i = 0, n = this->_internal_stats_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_stats(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgAMGetUserGameStats)
  return target;
}

size_t CMsgAMGetUserGameStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgAMGetUserGameStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 stats = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.stats_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_stats_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional fixed64 steam_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional fixed64 game_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgAMGetUserGameStats::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgAMGetUserGameStats*>(
      &from));
}

void CMsgAMGetUserGameStats::MergeFrom(const CMsgAMGetUserGameStats& from) {
  CMsgAMGetUserGameStats* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgAMGetUserGameStats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.stats_.MergeFrom(from._impl_.stats_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.steam_id_ = from._impl_.steam_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.game_id_ = from._impl_.game_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgAMGetUserGameStats::CopyFrom(const CMsgAMGetUserGameStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgAMGetUserGameStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgAMGetUserGameStats::IsInitialized() const {
  return true;
}

void CMsgAMGetUserGameStats::InternalSwap(CMsgAMGetUserGameStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.stats_.InternalSwap(&other->_impl_.stats_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgAMGetUserGameStats, _impl_.game_id_)
      + sizeof(CMsgAMGetUserGameStats::_impl_.game_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgAMGetUserGameStats, _impl_.steam_id_)>(
          reinterpret_cast<char*>(&_impl_.steam_id_),
          reinterpret_cast<char*>(&other->_impl_.steam_id_));
}

std::string CMsgAMGetUserGameStats::GetTypeName() const {
  return "CMsgAMGetUserGameStats";
}


// ===================================================================

class CMsgAMGetUserGameStatsResponse_Stats::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgAMGetUserGameStatsResponse_Stats>()._impl_._has_bits_);
  static void set_has_stat_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_stat_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgAMGetUserGameStatsResponse_Stats::CMsgAMGetUserGameStatsResponse_Stats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgAMGetUserGameStatsResponse.Stats)
}
CMsgAMGetUserGameStatsResponse_Stats::CMsgAMGetUserGameStatsResponse_Stats(const CMsgAMGetUserGameStatsResponse_Stats& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgAMGetUserGameStatsResponse_Stats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stat_id_){}
    , decltype(_impl_.stat_value_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.stat_id_, &from._impl_.stat_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.stat_value_) -
    reinterpret_cast<char*>(&_impl_.stat_id_)) + sizeof(_impl_.stat_value_));
  // @@protoc_insertion_point(copy_constructor:CMsgAMGetUserGameStatsResponse.Stats)
}

inline void CMsgAMGetUserGameStatsResponse_Stats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stat_id_){0u}
    , decltype(_impl_.stat_value_){0u}
  };
}

CMsgAMGetUserGameStatsResponse_Stats::~CMsgAMGetUserGameStatsResponse_Stats() {
  // @@protoc_insertion_point(destructor:CMsgAMGetUserGameStatsResponse.Stats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgAMGetUserGameStatsResponse_Stats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgAMGetUserGameStatsResponse_Stats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgAMGetUserGameStatsResponse_Stats::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgAMGetUserGameStatsResponse.Stats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.stat_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.stat_value_) -
        reinterpret_cast<char*>(&_impl_.stat_id_)) + sizeof(_impl_.stat_value_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgAMGetUserGameStatsResponse_Stats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 stat_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_stat_id(&has_bits);
          _impl_.stat_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 stat_value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_stat_value(&has_bits);
          _impl_.stat_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgAMGetUserGameStatsResponse_Stats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgAMGetUserGameStatsResponse.Stats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 stat_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_stat_id(), target);
  }

  // optional uint32 stat_value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_stat_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgAMGetUserGameStatsResponse.Stats)
  return target;
}

size_t CMsgAMGetUserGameStatsResponse_Stats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgAMGetUserGameStatsResponse.Stats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 stat_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_stat_id());
    }

    // optional uint32 stat_value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_stat_value());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgAMGetUserGameStatsResponse_Stats::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgAMGetUserGameStatsResponse_Stats*>(
      &from));
}

void CMsgAMGetUserGameStatsResponse_Stats::MergeFrom(const CMsgAMGetUserGameStatsResponse_Stats& from) {
  CMsgAMGetUserGameStatsResponse_Stats* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgAMGetUserGameStatsResponse.Stats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.stat_id_ = from._impl_.stat_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.stat_value_ = from._impl_.stat_value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgAMGetUserGameStatsResponse_Stats::CopyFrom(const CMsgAMGetUserGameStatsResponse_Stats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgAMGetUserGameStatsResponse.Stats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgAMGetUserGameStatsResponse_Stats::IsInitialized() const {
  return true;
}

void CMsgAMGetUserGameStatsResponse_Stats::InternalSwap(CMsgAMGetUserGameStatsResponse_Stats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgAMGetUserGameStatsResponse_Stats, _impl_.stat_value_)
      + sizeof(CMsgAMGetUserGameStatsResponse_Stats::_impl_.stat_value_)
      - PROTOBUF_FIELD_OFFSET(CMsgAMGetUserGameStatsResponse_Stats, _impl_.stat_id_)>(
          reinterpret_cast<char*>(&_impl_.stat_id_),
          reinterpret_cast<char*>(&other->_impl_.stat_id_));
}

std::string CMsgAMGetUserGameStatsResponse_Stats::GetTypeName() const {
  return "CMsgAMGetUserGameStatsResponse.Stats";
}


// ===================================================================

class CMsgAMGetUserGameStatsResponse_Achievement_Blocks::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgAMGetUserGameStatsResponse_Achievement_Blocks>()._impl_._has_bits_);
  static void set_has_achievement_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_achievement_bit_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_unlock_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgAMGetUserGameStatsResponse_Achievement_Blocks::CMsgAMGetUserGameStatsResponse_Achievement_Blocks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgAMGetUserGameStatsResponse.Achievement_Blocks)
}
CMsgAMGetUserGameStatsResponse_Achievement_Blocks::CMsgAMGetUserGameStatsResponse_Achievement_Blocks(const CMsgAMGetUserGameStatsResponse_Achievement_Blocks& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgAMGetUserGameStatsResponse_Achievement_Blocks* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.achievement_id_){}
    , decltype(_impl_.achievement_bit_id_){}
    , decltype(_impl_.unlock_time_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.achievement_id_, &from._impl_.achievement_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.unlock_time_) -
    reinterpret_cast<char*>(&_impl_.achievement_id_)) + sizeof(_impl_.unlock_time_));
  // @@protoc_insertion_point(copy_constructor:CMsgAMGetUserGameStatsResponse.Achievement_Blocks)
}

inline void CMsgAMGetUserGameStatsResponse_Achievement_Blocks::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.achievement_id_){0u}
    , decltype(_impl_.achievement_bit_id_){0u}
    , decltype(_impl_.unlock_time_){0u}
  };
}

CMsgAMGetUserGameStatsResponse_Achievement_Blocks::~CMsgAMGetUserGameStatsResponse_Achievement_Blocks() {
  // @@protoc_insertion_point(destructor:CMsgAMGetUserGameStatsResponse.Achievement_Blocks)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgAMGetUserGameStatsResponse_Achievement_Blocks::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgAMGetUserGameStatsResponse_Achievement_Blocks::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgAMGetUserGameStatsResponse_Achievement_Blocks::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgAMGetUserGameStatsResponse.Achievement_Blocks)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.achievement_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.unlock_time_) -
        reinterpret_cast<char*>(&_impl_.achievement_id_)) + sizeof(_impl_.unlock_time_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgAMGetUserGameStatsResponse_Achievement_Blocks::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 achievement_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_achievement_id(&has_bits);
          _impl_.achievement_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 achievement_bit_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_achievement_bit_id(&has_bits);
          _impl_.achievement_bit_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 unlock_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_unlock_time(&has_bits);
          _impl_.unlock_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgAMGetUserGameStatsResponse_Achievement_Blocks::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgAMGetUserGameStatsResponse.Achievement_Blocks)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 achievement_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_achievement_id(), target);
  }

  // optional uint32 achievement_bit_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_achievement_bit_id(), target);
  }

  // optional fixed32 unlock_time = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(3, this->_internal_unlock_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgAMGetUserGameStatsResponse.Achievement_Blocks)
  return target;
}

size_t CMsgAMGetUserGameStatsResponse_Achievement_Blocks::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgAMGetUserGameStatsResponse.Achievement_Blocks)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 achievement_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_achievement_id());
    }

    // optional uint32 achievement_bit_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_achievement_bit_id());
    }

    // optional fixed32 unlock_time = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgAMGetUserGameStatsResponse_Achievement_Blocks::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgAMGetUserGameStatsResponse_Achievement_Blocks*>(
      &from));
}

void CMsgAMGetUserGameStatsResponse_Achievement_Blocks::MergeFrom(const CMsgAMGetUserGameStatsResponse_Achievement_Blocks& from) {
  CMsgAMGetUserGameStatsResponse_Achievement_Blocks* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgAMGetUserGameStatsResponse.Achievement_Blocks)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.achievement_id_ = from._impl_.achievement_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.achievement_bit_id_ = from._impl_.achievement_bit_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.unlock_time_ = from._impl_.unlock_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgAMGetUserGameStatsResponse_Achievement_Blocks::CopyFrom(const CMsgAMGetUserGameStatsResponse_Achievement_Blocks& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgAMGetUserGameStatsResponse.Achievement_Blocks)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgAMGetUserGameStatsResponse_Achievement_Blocks::IsInitialized() const {
  return true;
}

void CMsgAMGetUserGameStatsResponse_Achievement_Blocks::InternalSwap(CMsgAMGetUserGameStatsResponse_Achievement_Blocks* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgAMGetUserGameStatsResponse_Achievement_Blocks, _impl_.unlock_time_)
      + sizeof(CMsgAMGetUserGameStatsResponse_Achievement_Blocks::_impl_.unlock_time_)
      - PROTOBUF_FIELD_OFFSET(CMsgAMGetUserGameStatsResponse_Achievement_Blocks, _impl_.achievement_id_)>(
          reinterpret_cast<char*>(&_impl_.achievement_id_),
          reinterpret_cast<char*>(&other->_impl_.achievement_id_));
}

std::string CMsgAMGetUserGameStatsResponse_Achievement_Blocks::GetTypeName() const {
  return "CMsgAMGetUserGameStatsResponse.Achievement_Blocks";
}


// ===================================================================

class CMsgAMGetUserGameStatsResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgAMGetUserGameStatsResponse>()._impl_._has_bits_);
  static void set_has_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_game_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_eresult(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgAMGetUserGameStatsResponse::CMsgAMGetUserGameStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgAMGetUserGameStatsResponse)
}
CMsgAMGetUserGameStatsResponse::CMsgAMGetUserGameStatsResponse(const CMsgAMGetUserGameStatsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgAMGetUserGameStatsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stats_){from._impl_.stats_}
    , decltype(_impl_.achievement_blocks_){from._impl_.achievement_blocks_}
    , decltype(_impl_.steam_id_){}
    , decltype(_impl_.game_id_){}
    , decltype(_impl_.eresult_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.steam_id_, &from._impl_.steam_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.eresult_) -
    reinterpret_cast<char*>(&_impl_.steam_id_)) + sizeof(_impl_.eresult_));
  // @@protoc_insertion_point(copy_constructor:CMsgAMGetUserGameStatsResponse)
}

inline void CMsgAMGetUserGameStatsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stats_){arena}
    , decltype(_impl_.achievement_blocks_){arena}
    , decltype(_impl_.steam_id_){uint64_t{0u}}
    , decltype(_impl_.game_id_){uint64_t{0u}}
    , decltype(_impl_.eresult_){2}
  };
}

CMsgAMGetUserGameStatsResponse::~CMsgAMGetUserGameStatsResponse() {
  // @@protoc_insertion_point(destructor:CMsgAMGetUserGameStatsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgAMGetUserGameStatsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stats_.~RepeatedPtrField();
  _impl_.achievement_blocks_.~RepeatedPtrField();
}

void CMsgAMGetUserGameStatsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgAMGetUserGameStatsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgAMGetUserGameStatsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stats_.Clear();
  _impl_.achievement_blocks_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.steam_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.game_id_) -
        reinterpret_cast<char*>(&_impl_.steam_id_)) + sizeof(_impl_.game_id_));
    _impl_.eresult_ = 2;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgAMGetUserGameStatsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steam_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steam_id(&has_bits);
          _impl_.steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 game_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_game_id(&has_bits);
          _impl_.game_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional int32 eresult = 3 [default = 2];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_eresult(&has_bits);
          _impl_.eresult_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgAMGetUserGameStatsResponse.Stats stats = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_stats(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgAMGetUserGameStatsResponse.Achievement_Blocks achievement_blocks = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_achievement_blocks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgAMGetUserGameStatsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgAMGetUserGameStatsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steam_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steam_id(), target);
  }

  // optional fixed64 game_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_game_id(), target);
  }

  // optional int32 eresult = 3 [default = 2];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_eresult(), target);
  }

  // repeated .CMsgAMGetUserGameStatsResponse.Stats stats = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_stats_size()); i < n; i++) {
    const auto& repfield = this->_internal_stats(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgAMGetUserGameStatsResponse.Achievement_Blocks achievement_blocks = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_achievement_blocks_size()); i < n; i++) {
    const auto& repfield = this->_internal_achievement_blocks(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgAMGetUserGameStatsResponse)
  return target;
}

size_t CMsgAMGetUserGameStatsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgAMGetUserGameStatsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgAMGetUserGameStatsResponse.Stats stats = 4;
  total_size += 1UL * this->_internal_stats_size();
  for (const auto& msg : this->_impl_.stats_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgAMGetUserGameStatsResponse.Achievement_Blocks achievement_blocks = 5;
  total_size += 1UL * this->_internal_achievement_blocks_size();
  for (const auto& msg : this->_impl_.achievement_blocks_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional fixed64 steam_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional fixed64 game_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional int32 eresult = 3 [default = 2];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_eresult());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgAMGetUserGameStatsResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgAMGetUserGameStatsResponse*>(
      &from));
}

void CMsgAMGetUserGameStatsResponse::MergeFrom(const CMsgAMGetUserGameStatsResponse& from) {
  CMsgAMGetUserGameStatsResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgAMGetUserGameStatsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.stats_.MergeFrom(from._impl_.stats_);
  _this->_impl_.achievement_blocks_.MergeFrom(from._impl_.achievement_blocks_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.steam_id_ = from._impl_.steam_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.game_id_ = from._impl_.game_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.eresult_ = from._impl_.eresult_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgAMGetUserGameStatsResponse::CopyFrom(const CMsgAMGetUserGameStatsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgAMGetUserGameStatsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgAMGetUserGameStatsResponse::IsInitialized() const {
  return true;
}

void CMsgAMGetUserGameStatsResponse::InternalSwap(CMsgAMGetUserGameStatsResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.stats_.InternalSwap(&other->_impl_.stats_);
  _impl_.achievement_blocks_.InternalSwap(&other->_impl_.achievement_blocks_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgAMGetUserGameStatsResponse, _impl_.game_id_)
      + sizeof(CMsgAMGetUserGameStatsResponse::_impl_.game_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgAMGetUserGameStatsResponse, _impl_.steam_id_)>(
          reinterpret_cast<char*>(&_impl_.steam_id_),
          reinterpret_cast<char*>(&other->_impl_.steam_id_));
  swap(_impl_.eresult_, other->_impl_.eresult_);
}

std::string CMsgAMGetUserGameStatsResponse::GetTypeName() const {
  return "CMsgAMGetUserGameStatsResponse";
}


// ===================================================================

class CMsgGCGetCommandList::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCGetCommandList>()._impl_._has_bits_);
  static void set_has_app_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_command_prefix(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCGetCommandList::CMsgGCGetCommandList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCGetCommandList)
}
CMsgGCGetCommandList::CMsgGCGetCommandList(const CMsgGCGetCommandList& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCGetCommandList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.command_prefix_){}
    , decltype(_impl_.app_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.command_prefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.command_prefix_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_command_prefix()) {
    _this->_impl_.command_prefix_.Set(from._internal_command_prefix(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.app_id_ = from._impl_.app_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCGetCommandList)
}

inline void CMsgGCGetCommandList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.command_prefix_){}
    , decltype(_impl_.app_id_){0u}
  };
  _impl_.command_prefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.command_prefix_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCGetCommandList::~CMsgGCGetCommandList() {
  // @@protoc_insertion_point(destructor:CMsgGCGetCommandList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCGetCommandList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.command_prefix_.Destroy();
}

void CMsgGCGetCommandList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCGetCommandList::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCGetCommandList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.command_prefix_.ClearNonDefaultToEmpty();
  }
  _impl_.app_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCGetCommandList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 app_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_app_id(&has_bits);
          _impl_.app_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string command_prefix = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_command_prefix();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCGetCommandList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCGetCommandList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 app_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_app_id(), target);
  }

  // optional string command_prefix = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_command_prefix(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCGetCommandList)
  return target;
}

size_t CMsgGCGetCommandList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCGetCommandList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string command_prefix = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_command_prefix());
    }

    // optional uint32 app_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_app_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCGetCommandList::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCGetCommandList*>(
      &from));
}

void CMsgGCGetCommandList::MergeFrom(const CMsgGCGetCommandList& from) {
  CMsgGCGetCommandList* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCGetCommandList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_command_prefix(from._internal_command_prefix());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.app_id_ = from._impl_.app_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCGetCommandList::CopyFrom(const CMsgGCGetCommandList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCGetCommandList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCGetCommandList::IsInitialized() const {
  return true;
}

void CMsgGCGetCommandList::InternalSwap(CMsgGCGetCommandList* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.command_prefix_, lhs_arena,
      &other->_impl_.command_prefix_, rhs_arena
  );
  swap(_impl_.app_id_, other->_impl_.app_id_);
}

std::string CMsgGCGetCommandList::GetTypeName() const {
  return "CMsgGCGetCommandList";
}


// ===================================================================

class CMsgGCGetCommandListResponse::_Internal {
 public:
};

CMsgGCGetCommandListResponse::CMsgGCGetCommandListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCGetCommandListResponse)
}
CMsgGCGetCommandListResponse::CMsgGCGetCommandListResponse(const CMsgGCGetCommandListResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCGetCommandListResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.command_name_){from._impl_.command_name_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgGCGetCommandListResponse)
}

inline void CMsgGCGetCommandListResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.command_name_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgGCGetCommandListResponse::~CMsgGCGetCommandListResponse() {
  // @@protoc_insertion_point(destructor:CMsgGCGetCommandListResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCGetCommandListResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.command_name_.~RepeatedPtrField();
}

void CMsgGCGetCommandListResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCGetCommandListResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCGetCommandListResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.command_name_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCGetCommandListResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string command_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_command_name();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCGetCommandListResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCGetCommandListResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string command_name = 1;
  for (int i = 0, n = this->_internal_command_name_size(); i < n; i++) {
    const auto& s = this->_internal_command_name(i);
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCGetCommandListResponse)
  return target;
}

size_t CMsgGCGetCommandListResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCGetCommandListResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string command_name = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.command_name_.size());
  for (int i = 0, n = _impl_.command_name_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.command_name_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCGetCommandListResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCGetCommandListResponse*>(
      &from));
}

void CMsgGCGetCommandListResponse::MergeFrom(const CMsgGCGetCommandListResponse& from) {
  CMsgGCGetCommandListResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCGetCommandListResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.command_name_.MergeFrom(from._impl_.command_name_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCGetCommandListResponse::CopyFrom(const CMsgGCGetCommandListResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCGetCommandListResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCGetCommandListResponse::IsInitialized() const {
  return true;
}

void CMsgGCGetCommandListResponse::InternalSwap(CMsgGCGetCommandListResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.command_name_.InternalSwap(&other->_impl_.command_name_);
}

std::string CMsgGCGetCommandListResponse::GetTypeName() const {
  return "CMsgGCGetCommandListResponse";
}


// ===================================================================

class CGCMsgMemCachedGet::_Internal {
 public:
};

CGCMsgMemCachedGet::CGCMsgMemCachedGet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCMsgMemCachedGet)
}
CGCMsgMemCachedGet::CGCMsgMemCachedGet(const CGCMsgMemCachedGet& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGCMsgMemCachedGet* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.keys_){from._impl_.keys_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CGCMsgMemCachedGet)
}

inline void CGCMsgMemCachedGet::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.keys_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CGCMsgMemCachedGet::~CGCMsgMemCachedGet() {
  // @@protoc_insertion_point(destructor:CGCMsgMemCachedGet)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCMsgMemCachedGet::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.keys_.~RepeatedPtrField();
}

void CGCMsgMemCachedGet::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCMsgMemCachedGet::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCMsgMemCachedGet)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.keys_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CGCMsgMemCachedGet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string keys = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_keys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCMsgMemCachedGet::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCMsgMemCachedGet)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string keys = 1;
  for (int i = 0, n = this->_internal_keys_size(); i < n; i++) {
    const auto& s = this->_internal_keys(i);
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCMsgMemCachedGet)
  return target;
}

size_t CGCMsgMemCachedGet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCMsgMemCachedGet)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string keys = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.keys_.size());
  for (int i = 0, n = _impl_.keys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.keys_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGCMsgMemCachedGet::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGCMsgMemCachedGet*>(
      &from));
}

void CGCMsgMemCachedGet::MergeFrom(const CGCMsgMemCachedGet& from) {
  CGCMsgMemCachedGet* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCMsgMemCachedGet)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.keys_.MergeFrom(from._impl_.keys_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGCMsgMemCachedGet::CopyFrom(const CGCMsgMemCachedGet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCMsgMemCachedGet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCMsgMemCachedGet::IsInitialized() const {
  return true;
}

void CGCMsgMemCachedGet::InternalSwap(CGCMsgMemCachedGet* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.keys_.InternalSwap(&other->_impl_.keys_);
}

std::string CGCMsgMemCachedGet::GetTypeName() const {
  return "CGCMsgMemCachedGet";
}


// ===================================================================

class CGCMsgMemCachedGetResponse_ValueTag::_Internal {
 public:
  using HasBits = decltype(std::declval<CGCMsgMemCachedGetResponse_ValueTag>()._impl_._has_bits_);
  static void set_has_found(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CGCMsgMemCachedGetResponse_ValueTag::CGCMsgMemCachedGetResponse_ValueTag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCMsgMemCachedGetResponse.ValueTag)
}
CGCMsgMemCachedGetResponse_ValueTag::CGCMsgMemCachedGetResponse_ValueTag(const CGCMsgMemCachedGetResponse_ValueTag& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGCMsgMemCachedGetResponse_ValueTag* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){}
    , decltype(_impl_.found_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.found_ = from._impl_.found_;
  // @@protoc_insertion_point(copy_constructor:CGCMsgMemCachedGetResponse.ValueTag)
}

inline void CGCMsgMemCachedGetResponse_ValueTag::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){}
    , decltype(_impl_.found_){false}
  };
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CGCMsgMemCachedGetResponse_ValueTag::~CGCMsgMemCachedGetResponse_ValueTag() {
  // @@protoc_insertion_point(destructor:CGCMsgMemCachedGetResponse.ValueTag)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCMsgMemCachedGetResponse_ValueTag::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.value_.Destroy();
}

void CGCMsgMemCachedGetResponse_ValueTag::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCMsgMemCachedGetResponse_ValueTag::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCMsgMemCachedGetResponse.ValueTag)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.value_.ClearNonDefaultToEmpty();
  }
  _impl_.found_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CGCMsgMemCachedGetResponse_ValueTag::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool found = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_found(&has_bits);
          _impl_.found_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCMsgMemCachedGetResponse_ValueTag::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCMsgMemCachedGetResponse.ValueTag)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool found = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_found(), target);
  }

  // optional bytes value = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCMsgMemCachedGetResponse.ValueTag)
  return target;
}

size_t CGCMsgMemCachedGetResponse_ValueTag::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCMsgMemCachedGetResponse.ValueTag)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes value = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_value());
    }

    // optional bool found = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGCMsgMemCachedGetResponse_ValueTag::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGCMsgMemCachedGetResponse_ValueTag*>(
      &from));
}

void CGCMsgMemCachedGetResponse_ValueTag::MergeFrom(const CGCMsgMemCachedGetResponse_ValueTag& from) {
  CGCMsgMemCachedGetResponse_ValueTag* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCMsgMemCachedGetResponse.ValueTag)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_value(from._internal_value());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.found_ = from._impl_.found_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGCMsgMemCachedGetResponse_ValueTag::CopyFrom(const CGCMsgMemCachedGetResponse_ValueTag& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCMsgMemCachedGetResponse.ValueTag)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCMsgMemCachedGetResponse_ValueTag::IsInitialized() const {
  return true;
}

void CGCMsgMemCachedGetResponse_ValueTag::InternalSwap(CGCMsgMemCachedGetResponse_ValueTag* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  swap(_impl_.found_, other->_impl_.found_);
}

std::string CGCMsgMemCachedGetResponse_ValueTag::GetTypeName() const {
  return "CGCMsgMemCachedGetResponse.ValueTag";
}


// ===================================================================

class CGCMsgMemCachedGetResponse::_Internal {
 public:
};

CGCMsgMemCachedGetResponse::CGCMsgMemCachedGetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCMsgMemCachedGetResponse)
}
CGCMsgMemCachedGetResponse::CGCMsgMemCachedGetResponse(const CGCMsgMemCachedGetResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGCMsgMemCachedGetResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.values_){from._impl_.values_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CGCMsgMemCachedGetResponse)
}

inline void CGCMsgMemCachedGetResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.values_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CGCMsgMemCachedGetResponse::~CGCMsgMemCachedGetResponse() {
  // @@protoc_insertion_point(destructor:CGCMsgMemCachedGetResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCMsgMemCachedGetResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.values_.~RepeatedPtrField();
}

void CGCMsgMemCachedGetResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCMsgMemCachedGetResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCMsgMemCachedGetResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CGCMsgMemCachedGetResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CGCMsgMemCachedGetResponse.ValueTag values = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCMsgMemCachedGetResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCMsgMemCachedGetResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CGCMsgMemCachedGetResponse.ValueTag values = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_values_size()); i < n; i++) {
    const auto& repfield = this->_internal_values(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCMsgMemCachedGetResponse)
  return target;
}

size_t CGCMsgMemCachedGetResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCMsgMemCachedGetResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CGCMsgMemCachedGetResponse.ValueTag values = 1;
  total_size += 1UL * this->_internal_values_size();
  for (const auto& msg : this->_impl_.values_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGCMsgMemCachedGetResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGCMsgMemCachedGetResponse*>(
      &from));
}

void CGCMsgMemCachedGetResponse::MergeFrom(const CGCMsgMemCachedGetResponse& from) {
  CGCMsgMemCachedGetResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCMsgMemCachedGetResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.values_.MergeFrom(from._impl_.values_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGCMsgMemCachedGetResponse::CopyFrom(const CGCMsgMemCachedGetResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCMsgMemCachedGetResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCMsgMemCachedGetResponse::IsInitialized() const {
  return true;
}

void CGCMsgMemCachedGetResponse::InternalSwap(CGCMsgMemCachedGetResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.values_.InternalSwap(&other->_impl_.values_);
}

std::string CGCMsgMemCachedGetResponse::GetTypeName() const {
  return "CGCMsgMemCachedGetResponse";
}


// ===================================================================

class CGCMsgMemCachedSet_KeyPair::_Internal {
 public:
  using HasBits = decltype(std::declval<CGCMsgMemCachedSet_KeyPair>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CGCMsgMemCachedSet_KeyPair::CGCMsgMemCachedSet_KeyPair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCMsgMemCachedSet.KeyPair)
}
CGCMsgMemCachedSet_KeyPair::CGCMsgMemCachedSet_KeyPair(const CGCMsgMemCachedSet_KeyPair& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGCMsgMemCachedSet_KeyPair* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CGCMsgMemCachedSet.KeyPair)
}

inline void CGCMsgMemCachedSet_KeyPair::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CGCMsgMemCachedSet_KeyPair::~CGCMsgMemCachedSet_KeyPair() {
  // @@protoc_insertion_point(destructor:CGCMsgMemCachedSet.KeyPair)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCMsgMemCachedSet_KeyPair::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.value_.Destroy();
}

void CGCMsgMemCachedSet_KeyPair::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCMsgMemCachedSet_KeyPair::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCMsgMemCachedSet.KeyPair)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CGCMsgMemCachedSet_KeyPair::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCMsgMemCachedSet_KeyPair::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCMsgMemCachedSet.KeyPair)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional bytes value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCMsgMemCachedSet.KeyPair)
  return target;
}

size_t CGCMsgMemCachedSet_KeyPair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCMsgMemCachedSet.KeyPair)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional bytes value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_value());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGCMsgMemCachedSet_KeyPair::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGCMsgMemCachedSet_KeyPair*>(
      &from));
}

void CGCMsgMemCachedSet_KeyPair::MergeFrom(const CGCMsgMemCachedSet_KeyPair& from) {
  CGCMsgMemCachedSet_KeyPair* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCMsgMemCachedSet.KeyPair)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGCMsgMemCachedSet_KeyPair::CopyFrom(const CGCMsgMemCachedSet_KeyPair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCMsgMemCachedSet.KeyPair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCMsgMemCachedSet_KeyPair::IsInitialized() const {
  return true;
}

void CGCMsgMemCachedSet_KeyPair::InternalSwap(CGCMsgMemCachedSet_KeyPair* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

std::string CGCMsgMemCachedSet_KeyPair::GetTypeName() const {
  return "CGCMsgMemCachedSet.KeyPair";
}


// ===================================================================

class CGCMsgMemCachedSet::_Internal {
 public:
};

CGCMsgMemCachedSet::CGCMsgMemCachedSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCMsgMemCachedSet)
}
CGCMsgMemCachedSet::CGCMsgMemCachedSet(const CGCMsgMemCachedSet& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGCMsgMemCachedSet* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.keys_){from._impl_.keys_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CGCMsgMemCachedSet)
}

inline void CGCMsgMemCachedSet::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.keys_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CGCMsgMemCachedSet::~CGCMsgMemCachedSet() {
  // @@protoc_insertion_point(destructor:CGCMsgMemCachedSet)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCMsgMemCachedSet::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.keys_.~RepeatedPtrField();
}

void CGCMsgMemCachedSet::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCMsgMemCachedSet::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCMsgMemCachedSet)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.keys_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CGCMsgMemCachedSet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CGCMsgMemCachedSet.KeyPair keys = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_keys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCMsgMemCachedSet::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCMsgMemCachedSet)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CGCMsgMemCachedSet.KeyPair keys = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_keys_size()); i < n; i++) {
    const auto& repfield = this->_internal_keys(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCMsgMemCachedSet)
  return target;
}

size_t CGCMsgMemCachedSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCMsgMemCachedSet)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CGCMsgMemCachedSet.KeyPair keys = 1;
  total_size += 1UL * this->_internal_keys_size();
  for (const auto& msg : this->_impl_.keys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGCMsgMemCachedSet::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGCMsgMemCachedSet*>(
      &from));
}

void CGCMsgMemCachedSet::MergeFrom(const CGCMsgMemCachedSet& from) {
  CGCMsgMemCachedSet* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCMsgMemCachedSet)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.keys_.MergeFrom(from._impl_.keys_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGCMsgMemCachedSet::CopyFrom(const CGCMsgMemCachedSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCMsgMemCachedSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCMsgMemCachedSet::IsInitialized() const {
  return true;
}

void CGCMsgMemCachedSet::InternalSwap(CGCMsgMemCachedSet* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.keys_.InternalSwap(&other->_impl_.keys_);
}

std::string CGCMsgMemCachedSet::GetTypeName() const {
  return "CGCMsgMemCachedSet";
}


// ===================================================================

class CGCMsgMemCachedDelete::_Internal {
 public:
};

CGCMsgMemCachedDelete::CGCMsgMemCachedDelete(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCMsgMemCachedDelete)
}
CGCMsgMemCachedDelete::CGCMsgMemCachedDelete(const CGCMsgMemCachedDelete& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGCMsgMemCachedDelete* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.keys_){from._impl_.keys_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CGCMsgMemCachedDelete)
}

inline void CGCMsgMemCachedDelete::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.keys_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CGCMsgMemCachedDelete::~CGCMsgMemCachedDelete() {
  // @@protoc_insertion_point(destructor:CGCMsgMemCachedDelete)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCMsgMemCachedDelete::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.keys_.~RepeatedPtrField();
}

void CGCMsgMemCachedDelete::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCMsgMemCachedDelete::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCMsgMemCachedDelete)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.keys_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CGCMsgMemCachedDelete::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string keys = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_keys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCMsgMemCachedDelete::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCMsgMemCachedDelete)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string keys = 1;
  for (int i = 0, n = this->_internal_keys_size(); i < n; i++) {
    const auto& s = this->_internal_keys(i);
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCMsgMemCachedDelete)
  return target;
}

size_t CGCMsgMemCachedDelete::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCMsgMemCachedDelete)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string keys = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.keys_.size());
  for (int i = 0, n = _impl_.keys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.keys_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGCMsgMemCachedDelete::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGCMsgMemCachedDelete*>(
      &from));
}

void CGCMsgMemCachedDelete::MergeFrom(const CGCMsgMemCachedDelete& from) {
  CGCMsgMemCachedDelete* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCMsgMemCachedDelete)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.keys_.MergeFrom(from._impl_.keys_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGCMsgMemCachedDelete::CopyFrom(const CGCMsgMemCachedDelete& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCMsgMemCachedDelete)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCMsgMemCachedDelete::IsInitialized() const {
  return true;
}

void CGCMsgMemCachedDelete::InternalSwap(CGCMsgMemCachedDelete* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.keys_.InternalSwap(&other->_impl_.keys_);
}

std::string CGCMsgMemCachedDelete::GetTypeName() const {
  return "CGCMsgMemCachedDelete";
}


// ===================================================================

class CGCMsgMemCachedStats::_Internal {
 public:
};

CGCMsgMemCachedStats::CGCMsgMemCachedStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCMsgMemCachedStats)
}
CGCMsgMemCachedStats::CGCMsgMemCachedStats(const CGCMsgMemCachedStats& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGCMsgMemCachedStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CGCMsgMemCachedStats)
}

inline void CGCMsgMemCachedStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

CGCMsgMemCachedStats::~CGCMsgMemCachedStats() {
  // @@protoc_insertion_point(destructor:CGCMsgMemCachedStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCMsgMemCachedStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CGCMsgMemCachedStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCMsgMemCachedStats::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCMsgMemCachedStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* CGCMsgMemCachedStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCMsgMemCachedStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCMsgMemCachedStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCMsgMemCachedStats)
  return target;
}

size_t CGCMsgMemCachedStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCMsgMemCachedStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGCMsgMemCachedStats::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGCMsgMemCachedStats*>(
      &from));
}

void CGCMsgMemCachedStats::MergeFrom(const CGCMsgMemCachedStats& from) {
  CGCMsgMemCachedStats* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCMsgMemCachedStats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGCMsgMemCachedStats::CopyFrom(const CGCMsgMemCachedStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCMsgMemCachedStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCMsgMemCachedStats::IsInitialized() const {
  return true;
}

void CGCMsgMemCachedStats::InternalSwap(CGCMsgMemCachedStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string CGCMsgMemCachedStats::GetTypeName() const {
  return "CGCMsgMemCachedStats";
}


// ===================================================================

class CGCMsgMemCachedStatsResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CGCMsgMemCachedStatsResponse>()._impl_._has_bits_);
  static void set_has_curr_connections(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cmd_get(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cmd_set(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_cmd_flush(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_get_hits(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_get_misses(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_delete_hits(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_delete_misses(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_bytes_read(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_bytes_written(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_limit_maxbytes(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_curr_items(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_evictions(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

CGCMsgMemCachedStatsResponse::CGCMsgMemCachedStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCMsgMemCachedStatsResponse)
}
CGCMsgMemCachedStatsResponse::CGCMsgMemCachedStatsResponse(const CGCMsgMemCachedStatsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGCMsgMemCachedStatsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.curr_connections_){}
    , decltype(_impl_.cmd_get_){}
    , decltype(_impl_.cmd_set_){}
    , decltype(_impl_.cmd_flush_){}
    , decltype(_impl_.get_hits_){}
    , decltype(_impl_.get_misses_){}
    , decltype(_impl_.delete_hits_){}
    , decltype(_impl_.delete_misses_){}
    , decltype(_impl_.bytes_read_){}
    , decltype(_impl_.bytes_written_){}
    , decltype(_impl_.limit_maxbytes_){}
    , decltype(_impl_.curr_items_){}
    , decltype(_impl_.evictions_){}
    , decltype(_impl_.bytes_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.curr_connections_, &from._impl_.curr_connections_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.bytes_) -
    reinterpret_cast<char*>(&_impl_.curr_connections_)) + sizeof(_impl_.bytes_));
  // @@protoc_insertion_point(copy_constructor:CGCMsgMemCachedStatsResponse)
}

inline void CGCMsgMemCachedStatsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.curr_connections_){uint64_t{0u}}
    , decltype(_impl_.cmd_get_){uint64_t{0u}}
    , decltype(_impl_.cmd_set_){uint64_t{0u}}
    , decltype(_impl_.cmd_flush_){uint64_t{0u}}
    , decltype(_impl_.get_hits_){uint64_t{0u}}
    , decltype(_impl_.get_misses_){uint64_t{0u}}
    , decltype(_impl_.delete_hits_){uint64_t{0u}}
    , decltype(_impl_.delete_misses_){uint64_t{0u}}
    , decltype(_impl_.bytes_read_){uint64_t{0u}}
    , decltype(_impl_.bytes_written_){uint64_t{0u}}
    , decltype(_impl_.limit_maxbytes_){uint64_t{0u}}
    , decltype(_impl_.curr_items_){uint64_t{0u}}
    , decltype(_impl_.evictions_){uint64_t{0u}}
    , decltype(_impl_.bytes_){uint64_t{0u}}
  };
}

CGCMsgMemCachedStatsResponse::~CGCMsgMemCachedStatsResponse() {
  // @@protoc_insertion_point(destructor:CGCMsgMemCachedStatsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCMsgMemCachedStatsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CGCMsgMemCachedStatsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCMsgMemCachedStatsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCMsgMemCachedStatsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.curr_connections_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.delete_misses_) -
        reinterpret_cast<char*>(&_impl_.curr_connections_)) + sizeof(_impl_.delete_misses_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&_impl_.bytes_read_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.bytes_) -
        reinterpret_cast<char*>(&_impl_.bytes_read_)) + sizeof(_impl_.bytes_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CGCMsgMemCachedStatsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 curr_connections = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_curr_connections(&has_bits);
          _impl_.curr_connections_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 cmd_get = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_cmd_get(&has_bits);
          _impl_.cmd_get_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 cmd_set = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_cmd_set(&has_bits);
          _impl_.cmd_set_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 cmd_flush = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_cmd_flush(&has_bits);
          _impl_.cmd_flush_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 get_hits = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_get_hits(&has_bits);
          _impl_.get_hits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 get_misses = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_get_misses(&has_bits);
          _impl_.get_misses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 delete_hits = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_delete_hits(&has_bits);
          _impl_.delete_hits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 delete_misses = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_delete_misses(&has_bits);
          _impl_.delete_misses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 bytes_read = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_bytes_read(&has_bits);
          _impl_.bytes_read_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 bytes_written = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_bytes_written(&has_bits);
          _impl_.bytes_written_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 limit_maxbytes = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_limit_maxbytes(&has_bits);
          _impl_.limit_maxbytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 curr_items = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_curr_items(&has_bits);
          _impl_.curr_items_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 evictions = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_evictions(&has_bits);
          _impl_.evictions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 bytes = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_bytes(&has_bits);
          _impl_.bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCMsgMemCachedStatsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCMsgMemCachedStatsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 curr_connections = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_curr_connections(), target);
  }

  // optional uint64 cmd_get = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_cmd_get(), target);
  }

  // optional uint64 cmd_set = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_cmd_set(), target);
  }

  // optional uint64 cmd_flush = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_cmd_flush(), target);
  }

  // optional uint64 get_hits = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_get_hits(), target);
  }

  // optional uint64 get_misses = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_get_misses(), target);
  }

  // optional uint64 delete_hits = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_delete_hits(), target);
  }

  // optional uint64 delete_misses = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_delete_misses(), target);
  }

  // optional uint64 bytes_read = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal_bytes_read(), target);
  }

  // optional uint64 bytes_written = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(10, this->_internal_bytes_written(), target);
  }

  // optional uint64 limit_maxbytes = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(11, this->_internal_limit_maxbytes(), target);
  }

  // optional uint64 curr_items = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(12, this->_internal_curr_items(), target);
  }

  // optional uint64 evictions = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(13, this->_internal_evictions(), target);
  }

  // optional uint64 bytes = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(14, this->_internal_bytes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCMsgMemCachedStatsResponse)
  return target;
}

size_t CGCMsgMemCachedStatsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCMsgMemCachedStatsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 curr_connections = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_curr_connections());
    }

    // optional uint64 cmd_get = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_cmd_get());
    }

    // optional uint64 cmd_set = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_cmd_set());
    }

    // optional uint64 cmd_flush = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_cmd_flush());
    }

    // optional uint64 get_hits = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_get_hits());
    }

    // optional uint64 get_misses = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_get_misses());
    }

    // optional uint64 delete_hits = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_delete_hits());
    }

    // optional uint64 delete_misses = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_delete_misses());
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional uint64 bytes_read = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_bytes_read());
    }

    // optional uint64 bytes_written = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_bytes_written());
    }

    // optional uint64 limit_maxbytes = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_limit_maxbytes());
    }

    // optional uint64 curr_items = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_curr_items());
    }

    // optional uint64 evictions = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_evictions());
    }

    // optional uint64 bytes = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_bytes());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGCMsgMemCachedStatsResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGCMsgMemCachedStatsResponse*>(
      &from));
}

void CGCMsgMemCachedStatsResponse::MergeFrom(const CGCMsgMemCachedStatsResponse& from) {
  CGCMsgMemCachedStatsResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCMsgMemCachedStatsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.curr_connections_ = from._impl_.curr_connections_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.cmd_get_ = from._impl_.cmd_get_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.cmd_set_ = from._impl_.cmd_set_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.cmd_flush_ = from._impl_.cmd_flush_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.get_hits_ = from._impl_.get_hits_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.get_misses_ = from._impl_.get_misses_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.delete_hits_ = from._impl_.delete_hits_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.delete_misses_ = from._impl_.delete_misses_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.bytes_read_ = from._impl_.bytes_read_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.bytes_written_ = from._impl_.bytes_written_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.limit_maxbytes_ = from._impl_.limit_maxbytes_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.curr_items_ = from._impl_.curr_items_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.evictions_ = from._impl_.evictions_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.bytes_ = from._impl_.bytes_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGCMsgMemCachedStatsResponse::CopyFrom(const CGCMsgMemCachedStatsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCMsgMemCachedStatsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCMsgMemCachedStatsResponse::IsInitialized() const {
  return true;
}

void CGCMsgMemCachedStatsResponse::InternalSwap(CGCMsgMemCachedStatsResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CGCMsgMemCachedStatsResponse, _impl_.bytes_)
      + sizeof(CGCMsgMemCachedStatsResponse::_impl_.bytes_)
      - PROTOBUF_FIELD_OFFSET(CGCMsgMemCachedStatsResponse, _impl_.curr_connections_)>(
          reinterpret_cast<char*>(&_impl_.curr_connections_),
          reinterpret_cast<char*>(&other->_impl_.curr_connections_));
}

std::string CGCMsgMemCachedStatsResponse::GetTypeName() const {
  return "CGCMsgMemCachedStatsResponse";
}


// ===================================================================

class CGCMsgSQLStats::_Internal {
 public:
  using HasBits = decltype(std::declval<CGCMsgSQLStats>()._impl_._has_bits_);
  static void set_has_schema_catalog(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CGCMsgSQLStats::CGCMsgSQLStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCMsgSQLStats)
}
CGCMsgSQLStats::CGCMsgSQLStats(const CGCMsgSQLStats& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGCMsgSQLStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.schema_catalog_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.schema_catalog_ = from._impl_.schema_catalog_;
  // @@protoc_insertion_point(copy_constructor:CGCMsgSQLStats)
}

inline void CGCMsgSQLStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.schema_catalog_){0u}
  };
}

CGCMsgSQLStats::~CGCMsgSQLStats() {
  // @@protoc_insertion_point(destructor:CGCMsgSQLStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCMsgSQLStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CGCMsgSQLStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCMsgSQLStats::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCMsgSQLStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.schema_catalog_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CGCMsgSQLStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 schema_catalog = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_schema_catalog(&has_bits);
          _impl_.schema_catalog_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCMsgSQLStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCMsgSQLStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 schema_catalog = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_schema_catalog(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCMsgSQLStats)
  return target;
}

size_t CGCMsgSQLStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCMsgSQLStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 schema_catalog = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_schema_catalog());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGCMsgSQLStats::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGCMsgSQLStats*>(
      &from));
}

void CGCMsgSQLStats::MergeFrom(const CGCMsgSQLStats& from) {
  CGCMsgSQLStats* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCMsgSQLStats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_schema_catalog()) {
    _this->_internal_set_schema_catalog(from._internal_schema_catalog());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGCMsgSQLStats::CopyFrom(const CGCMsgSQLStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCMsgSQLStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCMsgSQLStats::IsInitialized() const {
  return true;
}

void CGCMsgSQLStats::InternalSwap(CGCMsgSQLStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.schema_catalog_, other->_impl_.schema_catalog_);
}

std::string CGCMsgSQLStats::GetTypeName() const {
  return "CGCMsgSQLStats";
}


// ===================================================================

class CGCMsgSQLStatsResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CGCMsgSQLStatsResponse>()._impl_._has_bits_);
  static void set_has_threads(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_threads_connected(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_threads_active(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_operations_submitted(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_prepared_statements_executed(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_non_prepared_statements_executed(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_deadlock_retries(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_operations_timed_out_in_queue(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_errors(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

CGCMsgSQLStatsResponse::CGCMsgSQLStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCMsgSQLStatsResponse)
}
CGCMsgSQLStatsResponse::CGCMsgSQLStatsResponse(const CGCMsgSQLStatsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGCMsgSQLStatsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.threads_){}
    , decltype(_impl_.threads_connected_){}
    , decltype(_impl_.threads_active_){}
    , decltype(_impl_.operations_submitted_){}
    , decltype(_impl_.prepared_statements_executed_){}
    , decltype(_impl_.non_prepared_statements_executed_){}
    , decltype(_impl_.deadlock_retries_){}
    , decltype(_impl_.operations_timed_out_in_queue_){}
    , decltype(_impl_.errors_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.threads_, &from._impl_.threads_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.errors_) -
    reinterpret_cast<char*>(&_impl_.threads_)) + sizeof(_impl_.errors_));
  // @@protoc_insertion_point(copy_constructor:CGCMsgSQLStatsResponse)
}

inline void CGCMsgSQLStatsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.threads_){0u}
    , decltype(_impl_.threads_connected_){0u}
    , decltype(_impl_.threads_active_){0u}
    , decltype(_impl_.operations_submitted_){0u}
    , decltype(_impl_.prepared_statements_executed_){0u}
    , decltype(_impl_.non_prepared_statements_executed_){0u}
    , decltype(_impl_.deadlock_retries_){0u}
    , decltype(_impl_.operations_timed_out_in_queue_){0u}
    , decltype(_impl_.errors_){0u}
  };
}

CGCMsgSQLStatsResponse::~CGCMsgSQLStatsResponse() {
  // @@protoc_insertion_point(destructor:CGCMsgSQLStatsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCMsgSQLStatsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CGCMsgSQLStatsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCMsgSQLStatsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCMsgSQLStatsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.threads_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.operations_timed_out_in_queue_) -
        reinterpret_cast<char*>(&_impl_.threads_)) + sizeof(_impl_.operations_timed_out_in_queue_));
  }
  _impl_.errors_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CGCMsgSQLStatsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 threads = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_threads(&has_bits);
          _impl_.threads_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 threads_connected = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_threads_connected(&has_bits);
          _impl_.threads_connected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 threads_active = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_threads_active(&has_bits);
          _impl_.threads_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 operations_submitted = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_operations_submitted(&has_bits);
          _impl_.operations_submitted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 prepared_statements_executed = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_prepared_statements_executed(&has_bits);
          _impl_.prepared_statements_executed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 non_prepared_statements_executed = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_non_prepared_statements_executed(&has_bits);
          _impl_.non_prepared_statements_executed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 deadlock_retries = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_deadlock_retries(&has_bits);
          _impl_.deadlock_retries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 operations_timed_out_in_queue = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_operations_timed_out_in_queue(&has_bits);
          _impl_.operations_timed_out_in_queue_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 errors = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_errors(&has_bits);
          _impl_.errors_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCMsgSQLStatsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCMsgSQLStatsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 threads = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_threads(), target);
  }

  // optional uint32 threads_connected = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_threads_connected(), target);
  }

  // optional uint32 threads_active = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_threads_active(), target);
  }

  // optional uint32 operations_submitted = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_operations_submitted(), target);
  }

  // optional uint32 prepared_statements_executed = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_prepared_statements_executed(), target);
  }

  // optional uint32 non_prepared_statements_executed = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_non_prepared_statements_executed(), target);
  }

  // optional uint32 deadlock_retries = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_deadlock_retries(), target);
  }

  // optional uint32 operations_timed_out_in_queue = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_operations_timed_out_in_queue(), target);
  }

  // optional uint32 errors = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_errors(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCMsgSQLStatsResponse)
  return target;
}

size_t CGCMsgSQLStatsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCMsgSQLStatsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 threads = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_threads());
    }

    // optional uint32 threads_connected = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_threads_connected());
    }

    // optional uint32 threads_active = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_threads_active());
    }

    // optional uint32 operations_submitted = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_operations_submitted());
    }

    // optional uint32 prepared_statements_executed = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_prepared_statements_executed());
    }

    // optional uint32 non_prepared_statements_executed = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_non_prepared_statements_executed());
    }

    // optional uint32 deadlock_retries = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_deadlock_retries());
    }

    // optional uint32 operations_timed_out_in_queue = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_operations_timed_out_in_queue());
    }

  }
  // optional uint32 errors = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_errors());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGCMsgSQLStatsResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGCMsgSQLStatsResponse*>(
      &from));
}

void CGCMsgSQLStatsResponse::MergeFrom(const CGCMsgSQLStatsResponse& from) {
  CGCMsgSQLStatsResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCMsgSQLStatsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.threads_ = from._impl_.threads_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.threads_connected_ = from._impl_.threads_connected_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.threads_active_ = from._impl_.threads_active_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.operations_submitted_ = from._impl_.operations_submitted_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.prepared_statements_executed_ = from._impl_.prepared_statements_executed_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.non_prepared_statements_executed_ = from._impl_.non_prepared_statements_executed_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.deadlock_retries_ = from._impl_.deadlock_retries_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.operations_timed_out_in_queue_ = from._impl_.operations_timed_out_in_queue_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_errors(from._internal_errors());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGCMsgSQLStatsResponse::CopyFrom(const CGCMsgSQLStatsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCMsgSQLStatsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCMsgSQLStatsResponse::IsInitialized() const {
  return true;
}

void CGCMsgSQLStatsResponse::InternalSwap(CGCMsgSQLStatsResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CGCMsgSQLStatsResponse, _impl_.errors_)
      + sizeof(CGCMsgSQLStatsResponse::_impl_.errors_)
      - PROTOBUF_FIELD_OFFSET(CGCMsgSQLStatsResponse, _impl_.threads_)>(
          reinterpret_cast<char*>(&_impl_.threads_),
          reinterpret_cast<char*>(&other->_impl_.threads_));
}

std::string CGCMsgSQLStatsResponse::GetTypeName() const {
  return "CGCMsgSQLStatsResponse";
}


// ===================================================================

class CMsgAMAddFreeLicense::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgAMAddFreeLicense>()._impl_._has_bits_);
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ip_public(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_packageid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_store_country_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgAMAddFreeLicense::CMsgAMAddFreeLicense(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgAMAddFreeLicense)
}
CMsgAMAddFreeLicense::CMsgAMAddFreeLicense(const CMsgAMAddFreeLicense& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgAMAddFreeLicense* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.store_country_code_){}
    , decltype(_impl_.steamid_){}
    , decltype(_impl_.ip_public_){}
    , decltype(_impl_.packageid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.store_country_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_country_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_store_country_code()) {
    _this->_impl_.store_country_code_.Set(from._internal_store_country_code(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.steamid_, &from._impl_.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.packageid_) -
    reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.packageid_));
  // @@protoc_insertion_point(copy_constructor:CMsgAMAddFreeLicense)
}

inline void CMsgAMAddFreeLicense::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.store_country_code_){}
    , decltype(_impl_.steamid_){uint64_t{0u}}
    , decltype(_impl_.ip_public_){0u}
    , decltype(_impl_.packageid_){0u}
  };
  _impl_.store_country_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_country_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgAMAddFreeLicense::~CMsgAMAddFreeLicense() {
  // @@protoc_insertion_point(destructor:CMsgAMAddFreeLicense)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgAMAddFreeLicense::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.store_country_code_.Destroy();
}

void CMsgAMAddFreeLicense::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgAMAddFreeLicense::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgAMAddFreeLicense)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.store_country_code_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.packageid_) -
        reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.packageid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgAMAddFreeLicense::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steamid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steamid(&has_bits);
          _impl_.steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ip_public = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ip_public(&has_bits);
          _impl_.ip_public_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 packageid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_packageid(&has_bits);
          _impl_.packageid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string store_country_code = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_store_country_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgAMAddFreeLicense::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgAMAddFreeLicense)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steamid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steamid(), target);
  }

  // optional uint32 ip_public = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ip_public(), target);
  }

  // optional uint32 packageid = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_packageid(), target);
  }

  // optional string store_country_code = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_store_country_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgAMAddFreeLicense)
  return target;
}

size_t CMsgAMAddFreeLicense::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgAMAddFreeLicense)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string store_country_code = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_store_country_code());
    }

    // optional fixed64 steamid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 ip_public = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ip_public());
    }

    // optional uint32 packageid = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_packageid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgAMAddFreeLicense::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgAMAddFreeLicense*>(
      &from));
}

void CMsgAMAddFreeLicense::MergeFrom(const CMsgAMAddFreeLicense& from) {
  CMsgAMAddFreeLicense* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgAMAddFreeLicense)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_store_country_code(from._internal_store_country_code());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.steamid_ = from._impl_.steamid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ip_public_ = from._impl_.ip_public_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.packageid_ = from._impl_.packageid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgAMAddFreeLicense::CopyFrom(const CMsgAMAddFreeLicense& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgAMAddFreeLicense)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgAMAddFreeLicense::IsInitialized() const {
  return true;
}

void CMsgAMAddFreeLicense::InternalSwap(CMsgAMAddFreeLicense* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.store_country_code_, lhs_arena,
      &other->_impl_.store_country_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgAMAddFreeLicense, _impl_.packageid_)
      + sizeof(CMsgAMAddFreeLicense::_impl_.packageid_)
      - PROTOBUF_FIELD_OFFSET(CMsgAMAddFreeLicense, _impl_.steamid_)>(
          reinterpret_cast<char*>(&_impl_.steamid_),
          reinterpret_cast<char*>(&other->_impl_.steamid_));
}

std::string CMsgAMAddFreeLicense::GetTypeName() const {
  return "CMsgAMAddFreeLicense";
}


// ===================================================================

class CMsgAMAddFreeLicenseResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgAMAddFreeLicenseResponse>()._impl_._has_bits_);
  static void set_has_eresult(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_purchase_result_detail(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_transid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgAMAddFreeLicenseResponse::CMsgAMAddFreeLicenseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgAMAddFreeLicenseResponse)
}
CMsgAMAddFreeLicenseResponse::CMsgAMAddFreeLicenseResponse(const CMsgAMAddFreeLicenseResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgAMAddFreeLicenseResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.transid_){}
    , decltype(_impl_.purchase_result_detail_){}
    , decltype(_impl_.eresult_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.transid_, &from._impl_.transid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.eresult_) -
    reinterpret_cast<char*>(&_impl_.transid_)) + sizeof(_impl_.eresult_));
  // @@protoc_insertion_point(copy_constructor:CMsgAMAddFreeLicenseResponse)
}

inline void CMsgAMAddFreeLicenseResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.transid_){uint64_t{0u}}
    , decltype(_impl_.purchase_result_detail_){0}
    , decltype(_impl_.eresult_){2}
  };
}

CMsgAMAddFreeLicenseResponse::~CMsgAMAddFreeLicenseResponse() {
  // @@protoc_insertion_point(destructor:CMsgAMAddFreeLicenseResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgAMAddFreeLicenseResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgAMAddFreeLicenseResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgAMAddFreeLicenseResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgAMAddFreeLicenseResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.transid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.purchase_result_detail_) -
        reinterpret_cast<char*>(&_impl_.transid_)) + sizeof(_impl_.purchase_result_detail_));
    _impl_.eresult_ = 2;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgAMAddFreeLicenseResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 eresult = 1 [default = 2];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_eresult(&has_bits);
          _impl_.eresult_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 purchase_result_detail = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_purchase_result_detail(&has_bits);
          _impl_.purchase_result_detail_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 transid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_transid(&has_bits);
          _impl_.transid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgAMAddFreeLicenseResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgAMAddFreeLicenseResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 eresult = 1 [default = 2];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_eresult(), target);
  }

  // optional int32 purchase_result_detail = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_purchase_result_detail(), target);
  }

  // optional fixed64 transid = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(3, this->_internal_transid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgAMAddFreeLicenseResponse)
  return target;
}

size_t CMsgAMAddFreeLicenseResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgAMAddFreeLicenseResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional fixed64 transid = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional int32 purchase_result_detail = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_purchase_result_detail());
    }

    // optional int32 eresult = 1 [default = 2];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_eresult());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgAMAddFreeLicenseResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgAMAddFreeLicenseResponse*>(
      &from));
}

void CMsgAMAddFreeLicenseResponse::MergeFrom(const CMsgAMAddFreeLicenseResponse& from) {
  CMsgAMAddFreeLicenseResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgAMAddFreeLicenseResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.transid_ = from._impl_.transid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.purchase_result_detail_ = from._impl_.purchase_result_detail_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.eresult_ = from._impl_.eresult_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgAMAddFreeLicenseResponse::CopyFrom(const CMsgAMAddFreeLicenseResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgAMAddFreeLicenseResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgAMAddFreeLicenseResponse::IsInitialized() const {
  return true;
}

void CMsgAMAddFreeLicenseResponse::InternalSwap(CMsgAMAddFreeLicenseResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgAMAddFreeLicenseResponse, _impl_.purchase_result_detail_)
      + sizeof(CMsgAMAddFreeLicenseResponse::_impl_.purchase_result_detail_)
      - PROTOBUF_FIELD_OFFSET(CMsgAMAddFreeLicenseResponse, _impl_.transid_)>(
          reinterpret_cast<char*>(&_impl_.transid_),
          reinterpret_cast<char*>(&other->_impl_.transid_));
  swap(_impl_.eresult_, other->_impl_.eresult_);
}

std::string CMsgAMAddFreeLicenseResponse::GetTypeName() const {
  return "CMsgAMAddFreeLicenseResponse";
}


// ===================================================================

class CGCMsgGetIPLocation::_Internal {
 public:
};

CGCMsgGetIPLocation::CGCMsgGetIPLocation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCMsgGetIPLocation)
}
CGCMsgGetIPLocation::CGCMsgGetIPLocation(const CGCMsgGetIPLocation& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGCMsgGetIPLocation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ips_){from._impl_.ips_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CGCMsgGetIPLocation)
}

inline void CGCMsgGetIPLocation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ips_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CGCMsgGetIPLocation::~CGCMsgGetIPLocation() {
  // @@protoc_insertion_point(destructor:CGCMsgGetIPLocation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCMsgGetIPLocation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ips_.~RepeatedField();
}

void CGCMsgGetIPLocation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCMsgGetIPLocation::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCMsgGetIPLocation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ips_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CGCMsgGetIPLocation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated fixed32 ips = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_ips(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr));
            ptr += sizeof(uint32_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<13>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_ips(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCMsgGetIPLocation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCMsgGetIPLocation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated fixed32 ips = 1;
  for (int i = 0, n = this->_internal_ips_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_ips(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCMsgGetIPLocation)
  return target;
}

size_t CGCMsgGetIPLocation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCMsgGetIPLocation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed32 ips = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_ips_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_ips_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGCMsgGetIPLocation::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGCMsgGetIPLocation*>(
      &from));
}

void CGCMsgGetIPLocation::MergeFrom(const CGCMsgGetIPLocation& from) {
  CGCMsgGetIPLocation* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCMsgGetIPLocation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ips_.MergeFrom(from._impl_.ips_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGCMsgGetIPLocation::CopyFrom(const CGCMsgGetIPLocation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCMsgGetIPLocation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCMsgGetIPLocation::IsInitialized() const {
  return true;
}

void CGCMsgGetIPLocation::InternalSwap(CGCMsgGetIPLocation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.ips_.InternalSwap(&other->_impl_.ips_);
}

std::string CGCMsgGetIPLocation::GetTypeName() const {
  return "CGCMsgGetIPLocation";
}


// ===================================================================

class CIPLocationInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CIPLocationInfo>()._impl_._has_bits_);
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_latitude(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_longitude(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_country(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_city(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CIPLocationInfo::CIPLocationInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CIPLocationInfo)
}
CIPLocationInfo::CIPLocationInfo(const CIPLocationInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CIPLocationInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.country_){}
    , decltype(_impl_.state_){}
    , decltype(_impl_.city_){}
    , decltype(_impl_.ip_){}
    , decltype(_impl_.latitude_){}
    , decltype(_impl_.longitude_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.country_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.country_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_country()) {
    _this->_impl_.country_.Set(from._internal_country(), 
      _this->GetArenaForAllocation());
  }
  _impl_.state_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.state_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_state()) {
    _this->_impl_.state_.Set(from._internal_state(), 
      _this->GetArenaForAllocation());
  }
  _impl_.city_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.city_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_city()) {
    _this->_impl_.city_.Set(from._internal_city(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.ip_, &from._impl_.ip_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.longitude_) -
    reinterpret_cast<char*>(&_impl_.ip_)) + sizeof(_impl_.longitude_));
  // @@protoc_insertion_point(copy_constructor:CIPLocationInfo)
}

inline void CIPLocationInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.country_){}
    , decltype(_impl_.state_){}
    , decltype(_impl_.city_){}
    , decltype(_impl_.ip_){0u}
    , decltype(_impl_.latitude_){0}
    , decltype(_impl_.longitude_){0}
  };
  _impl_.country_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.country_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.state_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.state_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.city_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.city_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CIPLocationInfo::~CIPLocationInfo() {
  // @@protoc_insertion_point(destructor:CIPLocationInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CIPLocationInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.country_.Destroy();
  _impl_.state_.Destroy();
  _impl_.city_.Destroy();
}

void CIPLocationInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CIPLocationInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CIPLocationInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.country_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.state_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.city_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.ip_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.longitude_) -
        reinterpret_cast<char*>(&_impl_.ip_)) + sizeof(_impl_.longitude_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CIPLocationInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 ip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ip(&has_bits);
          _impl_.ip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float latitude = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_latitude(&has_bits);
          _impl_.latitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float longitude = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_longitude(&has_bits);
          _impl_.longitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional string country = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_country();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string state = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_state();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string city = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_city();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CIPLocationInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CIPLocationInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 ip = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ip(), target);
  }

  // optional float latitude = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_latitude(), target);
  }

  // optional float longitude = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_longitude(), target);
  }

  // optional string country = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_country(), target);
  }

  // optional string state = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_state(), target);
  }

  // optional string city = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_city(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CIPLocationInfo)
  return target;
}

size_t CIPLocationInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CIPLocationInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string country = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_country());
    }

    // optional string state = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_state());
    }

    // optional string city = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_city());
    }

    // optional uint32 ip = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ip());
    }

    // optional float latitude = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float longitude = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CIPLocationInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CIPLocationInfo*>(
      &from));
}

void CIPLocationInfo::MergeFrom(const CIPLocationInfo& from) {
  CIPLocationInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CIPLocationInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_country(from._internal_country());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_state(from._internal_state());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_city(from._internal_city());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.ip_ = from._impl_.ip_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.latitude_ = from._impl_.latitude_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.longitude_ = from._impl_.longitude_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CIPLocationInfo::CopyFrom(const CIPLocationInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CIPLocationInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CIPLocationInfo::IsInitialized() const {
  return true;
}

void CIPLocationInfo::InternalSwap(CIPLocationInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.country_, lhs_arena,
      &other->_impl_.country_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.state_, lhs_arena,
      &other->_impl_.state_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.city_, lhs_arena,
      &other->_impl_.city_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CIPLocationInfo, _impl_.longitude_)
      + sizeof(CIPLocationInfo::_impl_.longitude_)
      - PROTOBUF_FIELD_OFFSET(CIPLocationInfo, _impl_.ip_)>(
          reinterpret_cast<char*>(&_impl_.ip_),
          reinterpret_cast<char*>(&other->_impl_.ip_));
}

std::string CIPLocationInfo::GetTypeName() const {
  return "CIPLocationInfo";
}


// ===================================================================

class CGCMsgGetIPLocationResponse::_Internal {
 public:
};

CGCMsgGetIPLocationResponse::CGCMsgGetIPLocationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCMsgGetIPLocationResponse)
}
CGCMsgGetIPLocationResponse::CGCMsgGetIPLocationResponse(const CGCMsgGetIPLocationResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGCMsgGetIPLocationResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.infos_){from._impl_.infos_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CGCMsgGetIPLocationResponse)
}

inline void CGCMsgGetIPLocationResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.infos_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CGCMsgGetIPLocationResponse::~CGCMsgGetIPLocationResponse() {
  // @@protoc_insertion_point(destructor:CGCMsgGetIPLocationResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCMsgGetIPLocationResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.infos_.~RepeatedPtrField();
}

void CGCMsgGetIPLocationResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCMsgGetIPLocationResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCMsgGetIPLocationResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.infos_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CGCMsgGetIPLocationResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CIPLocationInfo infos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCMsgGetIPLocationResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCMsgGetIPLocationResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CIPLocationInfo infos = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCMsgGetIPLocationResponse)
  return target;
}

size_t CGCMsgGetIPLocationResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCMsgGetIPLocationResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CIPLocationInfo infos = 1;
  total_size += 1UL * this->_internal_infos_size();
  for (const auto& msg : this->_impl_.infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGCMsgGetIPLocationResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGCMsgGetIPLocationResponse*>(
      &from));
}

void CGCMsgGetIPLocationResponse::MergeFrom(const CGCMsgGetIPLocationResponse& from) {
  CGCMsgGetIPLocationResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCMsgGetIPLocationResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.infos_.MergeFrom(from._impl_.infos_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGCMsgGetIPLocationResponse::CopyFrom(const CGCMsgGetIPLocationResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCMsgGetIPLocationResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCMsgGetIPLocationResponse::IsInitialized() const {
  return true;
}

void CGCMsgGetIPLocationResponse::InternalSwap(CGCMsgGetIPLocationResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.infos_.InternalSwap(&other->_impl_.infos_);
}

std::string CGCMsgGetIPLocationResponse::GetTypeName() const {
  return "CGCMsgGetIPLocationResponse";
}


// ===================================================================

class CGCMsgSystemStatsSchema::_Internal {
 public:
  using HasBits = decltype(std::declval<CGCMsgSystemStatsSchema>()._impl_._has_bits_);
  static void set_has_gc_app_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_schema_kv(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CGCMsgSystemStatsSchema::CGCMsgSystemStatsSchema(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCMsgSystemStatsSchema)
}
CGCMsgSystemStatsSchema::CGCMsgSystemStatsSchema(const CGCMsgSystemStatsSchema& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGCMsgSystemStatsSchema* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.schema_kv_){}
    , decltype(_impl_.gc_app_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.schema_kv_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.schema_kv_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_schema_kv()) {
    _this->_impl_.schema_kv_.Set(from._internal_schema_kv(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.gc_app_id_ = from._impl_.gc_app_id_;
  // @@protoc_insertion_point(copy_constructor:CGCMsgSystemStatsSchema)
}

inline void CGCMsgSystemStatsSchema::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.schema_kv_){}
    , decltype(_impl_.gc_app_id_){0u}
  };
  _impl_.schema_kv_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.schema_kv_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CGCMsgSystemStatsSchema::~CGCMsgSystemStatsSchema() {
  // @@protoc_insertion_point(destructor:CGCMsgSystemStatsSchema)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCMsgSystemStatsSchema::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.schema_kv_.Destroy();
}

void CGCMsgSystemStatsSchema::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCMsgSystemStatsSchema::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCMsgSystemStatsSchema)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.schema_kv_.ClearNonDefaultToEmpty();
  }
  _impl_.gc_app_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CGCMsgSystemStatsSchema::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 gc_app_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gc_app_id(&has_bits);
          _impl_.gc_app_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes schema_kv = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_schema_kv();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCMsgSystemStatsSchema::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCMsgSystemStatsSchema)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 gc_app_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gc_app_id(), target);
  }

  // optional bytes schema_kv = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_schema_kv(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCMsgSystemStatsSchema)
  return target;
}

size_t CGCMsgSystemStatsSchema::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCMsgSystemStatsSchema)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes schema_kv = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_schema_kv());
    }

    // optional uint32 gc_app_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gc_app_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGCMsgSystemStatsSchema::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGCMsgSystemStatsSchema*>(
      &from));
}

void CGCMsgSystemStatsSchema::MergeFrom(const CGCMsgSystemStatsSchema& from) {
  CGCMsgSystemStatsSchema* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCMsgSystemStatsSchema)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_schema_kv(from._internal_schema_kv());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.gc_app_id_ = from._impl_.gc_app_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGCMsgSystemStatsSchema::CopyFrom(const CGCMsgSystemStatsSchema& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCMsgSystemStatsSchema)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCMsgSystemStatsSchema::IsInitialized() const {
  return true;
}

void CGCMsgSystemStatsSchema::InternalSwap(CGCMsgSystemStatsSchema* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.schema_kv_, lhs_arena,
      &other->_impl_.schema_kv_, rhs_arena
  );
  swap(_impl_.gc_app_id_, other->_impl_.gc_app_id_);
}

std::string CGCMsgSystemStatsSchema::GetTypeName() const {
  return "CGCMsgSystemStatsSchema";
}


// ===================================================================

class CGCMsgGetSystemStats::_Internal {
 public:
};

CGCMsgGetSystemStats::CGCMsgGetSystemStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCMsgGetSystemStats)
}
CGCMsgGetSystemStats::CGCMsgGetSystemStats(const CGCMsgGetSystemStats& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGCMsgGetSystemStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CGCMsgGetSystemStats)
}

inline void CGCMsgGetSystemStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

CGCMsgGetSystemStats::~CGCMsgGetSystemStats() {
  // @@protoc_insertion_point(destructor:CGCMsgGetSystemStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCMsgGetSystemStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CGCMsgGetSystemStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCMsgGetSystemStats::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCMsgGetSystemStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* CGCMsgGetSystemStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCMsgGetSystemStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCMsgGetSystemStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCMsgGetSystemStats)
  return target;
}

size_t CGCMsgGetSystemStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCMsgGetSystemStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGCMsgGetSystemStats::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGCMsgGetSystemStats*>(
      &from));
}

void CGCMsgGetSystemStats::MergeFrom(const CGCMsgGetSystemStats& from) {
  CGCMsgGetSystemStats* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCMsgGetSystemStats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGCMsgGetSystemStats::CopyFrom(const CGCMsgGetSystemStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCMsgGetSystemStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCMsgGetSystemStats::IsInitialized() const {
  return true;
}

void CGCMsgGetSystemStats::InternalSwap(CGCMsgGetSystemStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string CGCMsgGetSystemStats::GetTypeName() const {
  return "CGCMsgGetSystemStats";
}


// ===================================================================

class CGCMsgGetSystemStatsResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CGCMsgGetSystemStatsResponse>()._impl_._has_bits_);
  static void set_has_gc_app_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_stats_kv(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_active_jobs(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_yielding_jobs(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_user_sessions(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_game_server_sessions(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_socaches(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_socaches_to_unload(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_socaches_loading(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_writeback_queue(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_steamid_locks(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_logon_queue(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_logon_jobs(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
};

CGCMsgGetSystemStatsResponse::CGCMsgGetSystemStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCMsgGetSystemStatsResponse)
}
CGCMsgGetSystemStatsResponse::CGCMsgGetSystemStatsResponse(const CGCMsgGetSystemStatsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGCMsgGetSystemStatsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stats_kv_){}
    , decltype(_impl_.gc_app_id_){}
    , decltype(_impl_.active_jobs_){}
    , decltype(_impl_.yielding_jobs_){}
    , decltype(_impl_.user_sessions_){}
    , decltype(_impl_.game_server_sessions_){}
    , decltype(_impl_.socaches_){}
    , decltype(_impl_.socaches_to_unload_){}
    , decltype(_impl_.socaches_loading_){}
    , decltype(_impl_.writeback_queue_){}
    , decltype(_impl_.steamid_locks_){}
    , decltype(_impl_.logon_queue_){}
    , decltype(_impl_.logon_jobs_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.stats_kv_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stats_kv_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_stats_kv()) {
    _this->_impl_.stats_kv_.Set(from._internal_stats_kv(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.gc_app_id_, &from._impl_.gc_app_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.logon_jobs_) -
    reinterpret_cast<char*>(&_impl_.gc_app_id_)) + sizeof(_impl_.logon_jobs_));
  // @@protoc_insertion_point(copy_constructor:CGCMsgGetSystemStatsResponse)
}

inline void CGCMsgGetSystemStatsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stats_kv_){}
    , decltype(_impl_.gc_app_id_){0u}
    , decltype(_impl_.active_jobs_){0u}
    , decltype(_impl_.yielding_jobs_){0u}
    , decltype(_impl_.user_sessions_){0u}
    , decltype(_impl_.game_server_sessions_){0u}
    , decltype(_impl_.socaches_){0u}
    , decltype(_impl_.socaches_to_unload_){0u}
    , decltype(_impl_.socaches_loading_){0u}
    , decltype(_impl_.writeback_queue_){0u}
    , decltype(_impl_.steamid_locks_){0u}
    , decltype(_impl_.logon_queue_){0u}
    , decltype(_impl_.logon_jobs_){0u}
  };
  _impl_.stats_kv_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stats_kv_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CGCMsgGetSystemStatsResponse::~CGCMsgGetSystemStatsResponse() {
  // @@protoc_insertion_point(destructor:CGCMsgGetSystemStatsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCMsgGetSystemStatsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stats_kv_.Destroy();
}

void CGCMsgGetSystemStatsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCMsgGetSystemStatsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCMsgGetSystemStatsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.stats_kv_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.gc_app_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.socaches_to_unload_) -
        reinterpret_cast<char*>(&_impl_.gc_app_id_)) + sizeof(_impl_.socaches_to_unload_));
  }
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&_impl_.socaches_loading_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.logon_jobs_) -
        reinterpret_cast<char*>(&_impl_.socaches_loading_)) + sizeof(_impl_.logon_jobs_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CGCMsgGetSystemStatsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 gc_app_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gc_app_id(&has_bits);
          _impl_.gc_app_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes stats_kv = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_stats_kv();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 active_jobs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_active_jobs(&has_bits);
          _impl_.active_jobs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 yielding_jobs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_yielding_jobs(&has_bits);
          _impl_.yielding_jobs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 user_sessions = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_user_sessions(&has_bits);
          _impl_.user_sessions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 game_server_sessions = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_game_server_sessions(&has_bits);
          _impl_.game_server_sessions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 socaches = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_socaches(&has_bits);
          _impl_.socaches_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 socaches_to_unload = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_socaches_to_unload(&has_bits);
          _impl_.socaches_to_unload_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 socaches_loading = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_socaches_loading(&has_bits);
          _impl_.socaches_loading_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 writeback_queue = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_writeback_queue(&has_bits);
          _impl_.writeback_queue_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 steamid_locks = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_steamid_locks(&has_bits);
          _impl_.steamid_locks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 logon_queue = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_logon_queue(&has_bits);
          _impl_.logon_queue_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 logon_jobs = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_logon_jobs(&has_bits);
          _impl_.logon_jobs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCMsgGetSystemStatsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCMsgGetSystemStatsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 gc_app_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gc_app_id(), target);
  }

  // optional bytes stats_kv = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_stats_kv(), target);
  }

  // optional uint32 active_jobs = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_active_jobs(), target);
  }

  // optional uint32 yielding_jobs = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_yielding_jobs(), target);
  }

  // optional uint32 user_sessions = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_user_sessions(), target);
  }

  // optional uint32 game_server_sessions = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_game_server_sessions(), target);
  }

  // optional uint32 socaches = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_socaches(), target);
  }

  // optional uint32 socaches_to_unload = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_socaches_to_unload(), target);
  }

  // optional uint32 socaches_loading = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_socaches_loading(), target);
  }

  // optional uint32 writeback_queue = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_writeback_queue(), target);
  }

  // optional uint32 steamid_locks = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_steamid_locks(), target);
  }

  // optional uint32 logon_queue = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_logon_queue(), target);
  }

  // optional uint32 logon_jobs = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_logon_jobs(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCMsgGetSystemStatsResponse)
  return target;
}

size_t CGCMsgGetSystemStatsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCMsgGetSystemStatsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes stats_kv = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_stats_kv());
    }

    // optional uint32 gc_app_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gc_app_id());
    }

    // optional uint32 active_jobs = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_active_jobs());
    }

    // optional uint32 yielding_jobs = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_yielding_jobs());
    }

    // optional uint32 user_sessions = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_sessions());
    }

    // optional uint32 game_server_sessions = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_game_server_sessions());
    }

    // optional uint32 socaches = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_socaches());
    }

    // optional uint32 socaches_to_unload = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_socaches_to_unload());
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional uint32 socaches_loading = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_socaches_loading());
    }

    // optional uint32 writeback_queue = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_writeback_queue());
    }

    // optional uint32 steamid_locks = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_steamid_locks());
    }

    // optional uint32 logon_queue = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_logon_queue());
    }

    // optional uint32 logon_jobs = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_logon_jobs());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGCMsgGetSystemStatsResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGCMsgGetSystemStatsResponse*>(
      &from));
}

void CGCMsgGetSystemStatsResponse::MergeFrom(const CGCMsgGetSystemStatsResponse& from) {
  CGCMsgGetSystemStatsResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCMsgGetSystemStatsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_stats_kv(from._internal_stats_kv());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.gc_app_id_ = from._impl_.gc_app_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.active_jobs_ = from._impl_.active_jobs_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.yielding_jobs_ = from._impl_.yielding_jobs_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.user_sessions_ = from._impl_.user_sessions_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.game_server_sessions_ = from._impl_.game_server_sessions_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.socaches_ = from._impl_.socaches_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.socaches_to_unload_ = from._impl_.socaches_to_unload_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.socaches_loading_ = from._impl_.socaches_loading_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.writeback_queue_ = from._impl_.writeback_queue_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.steamid_locks_ = from._impl_.steamid_locks_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.logon_queue_ = from._impl_.logon_queue_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.logon_jobs_ = from._impl_.logon_jobs_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGCMsgGetSystemStatsResponse::CopyFrom(const CGCMsgGetSystemStatsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCMsgGetSystemStatsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCMsgGetSystemStatsResponse::IsInitialized() const {
  return true;
}

void CGCMsgGetSystemStatsResponse::InternalSwap(CGCMsgGetSystemStatsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.stats_kv_, lhs_arena,
      &other->_impl_.stats_kv_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CGCMsgGetSystemStatsResponse, _impl_.logon_jobs_)
      + sizeof(CGCMsgGetSystemStatsResponse::_impl_.logon_jobs_)
      - PROTOBUF_FIELD_OFFSET(CGCMsgGetSystemStatsResponse, _impl_.gc_app_id_)>(
          reinterpret_cast<char*>(&_impl_.gc_app_id_),
          reinterpret_cast<char*>(&other->_impl_.gc_app_id_));
}

std::string CGCMsgGetSystemStatsResponse::GetTypeName() const {
  return "CGCMsgGetSystemStatsResponse";
}


// ===================================================================

class CMsgAMSendEmail_PersonaNameReplacementToken::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgAMSendEmail_PersonaNameReplacementToken>()._impl_._has_bits_);
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_token_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgAMSendEmail_PersonaNameReplacementToken::CMsgAMSendEmail_PersonaNameReplacementToken(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgAMSendEmail.PersonaNameReplacementToken)
}
CMsgAMSendEmail_PersonaNameReplacementToken::CMsgAMSendEmail_PersonaNameReplacementToken(const CMsgAMSendEmail_PersonaNameReplacementToken& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgAMSendEmail_PersonaNameReplacementToken* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_name_){}
    , decltype(_impl_.steamid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.token_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_token_name()) {
    _this->_impl_.token_name_.Set(from._internal_token_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.steamid_ = from._impl_.steamid_;
  // @@protoc_insertion_point(copy_constructor:CMsgAMSendEmail.PersonaNameReplacementToken)
}

inline void CMsgAMSendEmail_PersonaNameReplacementToken::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_name_){}
    , decltype(_impl_.steamid_){uint64_t{0u}}
  };
  _impl_.token_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgAMSendEmail_PersonaNameReplacementToken::~CMsgAMSendEmail_PersonaNameReplacementToken() {
  // @@protoc_insertion_point(destructor:CMsgAMSendEmail.PersonaNameReplacementToken)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgAMSendEmail_PersonaNameReplacementToken::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.token_name_.Destroy();
}

void CMsgAMSendEmail_PersonaNameReplacementToken::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgAMSendEmail_PersonaNameReplacementToken::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgAMSendEmail.PersonaNameReplacementToken)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.token_name_.ClearNonDefaultToEmpty();
  }
  _impl_.steamid_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgAMSendEmail_PersonaNameReplacementToken::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steamid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steamid(&has_bits);
          _impl_.steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional string token_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_token_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgAMSendEmail_PersonaNameReplacementToken::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgAMSendEmail.PersonaNameReplacementToken)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steamid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steamid(), target);
  }

  // optional string token_name = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_token_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgAMSendEmail.PersonaNameReplacementToken)
  return target;
}

size_t CMsgAMSendEmail_PersonaNameReplacementToken::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgAMSendEmail.PersonaNameReplacementToken)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string token_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_token_name());
    }

    // optional fixed64 steamid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgAMSendEmail_PersonaNameReplacementToken::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgAMSendEmail_PersonaNameReplacementToken*>(
      &from));
}

void CMsgAMSendEmail_PersonaNameReplacementToken::MergeFrom(const CMsgAMSendEmail_PersonaNameReplacementToken& from) {
  CMsgAMSendEmail_PersonaNameReplacementToken* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgAMSendEmail.PersonaNameReplacementToken)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_token_name(from._internal_token_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.steamid_ = from._impl_.steamid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgAMSendEmail_PersonaNameReplacementToken::CopyFrom(const CMsgAMSendEmail_PersonaNameReplacementToken& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgAMSendEmail.PersonaNameReplacementToken)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgAMSendEmail_PersonaNameReplacementToken::IsInitialized() const {
  return true;
}

void CMsgAMSendEmail_PersonaNameReplacementToken::InternalSwap(CMsgAMSendEmail_PersonaNameReplacementToken* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.token_name_, lhs_arena,
      &other->_impl_.token_name_, rhs_arena
  );
  swap(_impl_.steamid_, other->_impl_.steamid_);
}

std::string CMsgAMSendEmail_PersonaNameReplacementToken::GetTypeName() const {
  return "CMsgAMSendEmail.PersonaNameReplacementToken";
}


// ===================================================================

class CMsgAMSendEmail_ReplacementToken::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgAMSendEmail_ReplacementToken>()._impl_._has_bits_);
  static void set_has_token_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_token_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgAMSendEmail_ReplacementToken::CMsgAMSendEmail_ReplacementToken(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgAMSendEmail.ReplacementToken)
}
CMsgAMSendEmail_ReplacementToken::CMsgAMSendEmail_ReplacementToken(const CMsgAMSendEmail_ReplacementToken& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgAMSendEmail_ReplacementToken* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_name_){}
    , decltype(_impl_.token_value_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.token_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_token_name()) {
    _this->_impl_.token_name_.Set(from._internal_token_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.token_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_token_value()) {
    _this->_impl_.token_value_.Set(from._internal_token_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgAMSendEmail.ReplacementToken)
}

inline void CMsgAMSendEmail_ReplacementToken::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_name_){}
    , decltype(_impl_.token_value_){}
  };
  _impl_.token_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.token_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgAMSendEmail_ReplacementToken::~CMsgAMSendEmail_ReplacementToken() {
  // @@protoc_insertion_point(destructor:CMsgAMSendEmail.ReplacementToken)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgAMSendEmail_ReplacementToken::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.token_name_.Destroy();
  _impl_.token_value_.Destroy();
}

void CMsgAMSendEmail_ReplacementToken::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgAMSendEmail_ReplacementToken::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgAMSendEmail.ReplacementToken)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.token_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.token_value_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgAMSendEmail_ReplacementToken::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string token_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_token_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string token_value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_token_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgAMSendEmail_ReplacementToken::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgAMSendEmail.ReplacementToken)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string token_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_token_name(), target);
  }

  // optional string token_value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_token_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgAMSendEmail.ReplacementToken)
  return target;
}

size_t CMsgAMSendEmail_ReplacementToken::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgAMSendEmail.ReplacementToken)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string token_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_token_name());
    }

    // optional string token_value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_token_value());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgAMSendEmail_ReplacementToken::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgAMSendEmail_ReplacementToken*>(
      &from));
}

void CMsgAMSendEmail_ReplacementToken::MergeFrom(const CMsgAMSendEmail_ReplacementToken& from) {
  CMsgAMSendEmail_ReplacementToken* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgAMSendEmail.ReplacementToken)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_token_name(from._internal_token_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_token_value(from._internal_token_value());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgAMSendEmail_ReplacementToken::CopyFrom(const CMsgAMSendEmail_ReplacementToken& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgAMSendEmail.ReplacementToken)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgAMSendEmail_ReplacementToken::IsInitialized() const {
  return true;
}

void CMsgAMSendEmail_ReplacementToken::InternalSwap(CMsgAMSendEmail_ReplacementToken* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.token_name_, lhs_arena,
      &other->_impl_.token_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.token_value_, lhs_arena,
      &other->_impl_.token_value_, rhs_arena
  );
}

std::string CMsgAMSendEmail_ReplacementToken::GetTypeName() const {
  return "CMsgAMSendEmail.ReplacementToken";
}


// ===================================================================

class CMsgAMSendEmail::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgAMSendEmail>()._impl_._has_bits_);
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_email_msg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_email_format(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_source_gc(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgAMSendEmail::CMsgAMSendEmail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgAMSendEmail)
}
CMsgAMSendEmail::CMsgAMSendEmail(const CMsgAMSendEmail& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgAMSendEmail* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.persona_name_tokens_){from._impl_.persona_name_tokens_}
    , decltype(_impl_.tokens_){from._impl_.tokens_}
    , decltype(_impl_.steamid_){}
    , decltype(_impl_.email_msg_type_){}
    , decltype(_impl_.email_format_){}
    , decltype(_impl_.source_gc_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.steamid_, &from._impl_.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.source_gc_) -
    reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.source_gc_));
  // @@protoc_insertion_point(copy_constructor:CMsgAMSendEmail)
}

inline void CMsgAMSendEmail::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.persona_name_tokens_){arena}
    , decltype(_impl_.tokens_){arena}
    , decltype(_impl_.steamid_){uint64_t{0u}}
    , decltype(_impl_.email_msg_type_){0u}
    , decltype(_impl_.email_format_){0u}
    , decltype(_impl_.source_gc_){0u}
  };
}

CMsgAMSendEmail::~CMsgAMSendEmail() {
  // @@protoc_insertion_point(destructor:CMsgAMSendEmail)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgAMSendEmail::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.persona_name_tokens_.~RepeatedPtrField();
  _impl_.tokens_.~RepeatedPtrField();
}

void CMsgAMSendEmail::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgAMSendEmail::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgAMSendEmail)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.persona_name_tokens_.Clear();
  _impl_.tokens_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.source_gc_) -
        reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.source_gc_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgAMSendEmail::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steamid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steamid(&has_bits);
          _impl_.steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 email_msg_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_email_msg_type(&has_bits);
          _impl_.email_msg_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 email_format = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_email_format(&has_bits);
          _impl_.email_format_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgAMSendEmail.PersonaNameReplacementToken persona_name_tokens = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_persona_name_tokens(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 source_gc = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_source_gc(&has_bits);
          _impl_.source_gc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgAMSendEmail.ReplacementToken tokens = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tokens(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgAMSendEmail::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgAMSendEmail)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steamid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steamid(), target);
  }

  // optional uint32 email_msg_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_email_msg_type(), target);
  }

  // optional uint32 email_format = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_email_format(), target);
  }

  // repeated .CMsgAMSendEmail.PersonaNameReplacementToken persona_name_tokens = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_persona_name_tokens_size()); i < n; i++) {
    const auto& repfield = this->_internal_persona_name_tokens(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 source_gc = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_source_gc(), target);
  }

  // repeated .CMsgAMSendEmail.ReplacementToken tokens = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tokens_size()); i < n; i++) {
    const auto& repfield = this->_internal_tokens(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgAMSendEmail)
  return target;
}

size_t CMsgAMSendEmail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgAMSendEmail)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgAMSendEmail.PersonaNameReplacementToken persona_name_tokens = 5;
  total_size += 1UL * this->_internal_persona_name_tokens_size();
  for (const auto& msg : this->_impl_.persona_name_tokens_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgAMSendEmail.ReplacementToken tokens = 7;
  total_size += 1UL * this->_internal_tokens_size();
  for (const auto& msg : this->_impl_.tokens_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional fixed64 steamid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional uint32 email_msg_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_email_msg_type());
    }

    // optional uint32 email_format = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_email_format());
    }

    // optional uint32 source_gc = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_source_gc());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgAMSendEmail::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgAMSendEmail*>(
      &from));
}

void CMsgAMSendEmail::MergeFrom(const CMsgAMSendEmail& from) {
  CMsgAMSendEmail* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgAMSendEmail)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.persona_name_tokens_.MergeFrom(from._impl_.persona_name_tokens_);
  _this->_impl_.tokens_.MergeFrom(from._impl_.tokens_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.steamid_ = from._impl_.steamid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.email_msg_type_ = from._impl_.email_msg_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.email_format_ = from._impl_.email_format_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.source_gc_ = from._impl_.source_gc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgAMSendEmail::CopyFrom(const CMsgAMSendEmail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgAMSendEmail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgAMSendEmail::IsInitialized() const {
  return true;
}

void CMsgAMSendEmail::InternalSwap(CMsgAMSendEmail* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.persona_name_tokens_.InternalSwap(&other->_impl_.persona_name_tokens_);
  _impl_.tokens_.InternalSwap(&other->_impl_.tokens_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgAMSendEmail, _impl_.source_gc_)
      + sizeof(CMsgAMSendEmail::_impl_.source_gc_)
      - PROTOBUF_FIELD_OFFSET(CMsgAMSendEmail, _impl_.steamid_)>(
          reinterpret_cast<char*>(&_impl_.steamid_),
          reinterpret_cast<char*>(&other->_impl_.steamid_));
}

std::string CMsgAMSendEmail::GetTypeName() const {
  return "CMsgAMSendEmail";
}


// ===================================================================

class CMsgAMSendEmailResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgAMSendEmailResponse>()._impl_._has_bits_);
  static void set_has_eresult(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgAMSendEmailResponse::CMsgAMSendEmailResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgAMSendEmailResponse)
}
CMsgAMSendEmailResponse::CMsgAMSendEmailResponse(const CMsgAMSendEmailResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgAMSendEmailResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.eresult_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.eresult_ = from._impl_.eresult_;
  // @@protoc_insertion_point(copy_constructor:CMsgAMSendEmailResponse)
}

inline void CMsgAMSendEmailResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.eresult_){2u}
  };
}

CMsgAMSendEmailResponse::~CMsgAMSendEmailResponse() {
  // @@protoc_insertion_point(destructor:CMsgAMSendEmailResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgAMSendEmailResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgAMSendEmailResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgAMSendEmailResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgAMSendEmailResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.eresult_ = 2u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgAMSendEmailResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 eresult = 1 [default = 2];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_eresult(&has_bits);
          _impl_.eresult_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgAMSendEmailResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgAMSendEmailResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 eresult = 1 [default = 2];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_eresult(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgAMSendEmailResponse)
  return target;
}

size_t CMsgAMSendEmailResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgAMSendEmailResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 eresult = 1 [default = 2];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_eresult());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgAMSendEmailResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgAMSendEmailResponse*>(
      &from));
}

void CMsgAMSendEmailResponse::MergeFrom(const CMsgAMSendEmailResponse& from) {
  CMsgAMSendEmailResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgAMSendEmailResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_eresult()) {
    _this->_internal_set_eresult(from._internal_eresult());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgAMSendEmailResponse::CopyFrom(const CMsgAMSendEmailResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgAMSendEmailResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgAMSendEmailResponse::IsInitialized() const {
  return true;
}

void CMsgAMSendEmailResponse::InternalSwap(CMsgAMSendEmailResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.eresult_, other->_impl_.eresult_);
}

std::string CMsgAMSendEmailResponse::GetTypeName() const {
  return "CMsgAMSendEmailResponse";
}


// ===================================================================

class CMsgGCGetEmailTemplate::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCGetEmailTemplate>()._impl_._has_bits_);
  static void set_has_app_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_email_msg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_email_lang(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_email_format(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgGCGetEmailTemplate::CMsgGCGetEmailTemplate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCGetEmailTemplate)
}
CMsgGCGetEmailTemplate::CMsgGCGetEmailTemplate(const CMsgGCGetEmailTemplate& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCGetEmailTemplate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.app_id_){}
    , decltype(_impl_.email_msg_type_){}
    , decltype(_impl_.email_lang_){}
    , decltype(_impl_.email_format_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.app_id_, &from._impl_.app_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.email_format_) -
    reinterpret_cast<char*>(&_impl_.app_id_)) + sizeof(_impl_.email_format_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCGetEmailTemplate)
}

inline void CMsgGCGetEmailTemplate::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.app_id_){0u}
    , decltype(_impl_.email_msg_type_){0u}
    , decltype(_impl_.email_lang_){0}
    , decltype(_impl_.email_format_){0}
  };
}

CMsgGCGetEmailTemplate::~CMsgGCGetEmailTemplate() {
  // @@protoc_insertion_point(destructor:CMsgGCGetEmailTemplate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCGetEmailTemplate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCGetEmailTemplate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCGetEmailTemplate::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCGetEmailTemplate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.app_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.email_format_) -
        reinterpret_cast<char*>(&_impl_.app_id_)) + sizeof(_impl_.email_format_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCGetEmailTemplate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 app_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_app_id(&has_bits);
          _impl_.app_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 email_msg_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_email_msg_type(&has_bits);
          _impl_.email_msg_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 email_lang = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_email_lang(&has_bits);
          _impl_.email_lang_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 email_format = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_email_format(&has_bits);
          _impl_.email_format_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCGetEmailTemplate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCGetEmailTemplate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 app_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_app_id(), target);
  }

  // optional uint32 email_msg_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_email_msg_type(), target);
  }

  // optional int32 email_lang = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_email_lang(), target);
  }

  // optional int32 email_format = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_email_format(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCGetEmailTemplate)
  return target;
}

size_t CMsgGCGetEmailTemplate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCGetEmailTemplate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 app_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_app_id());
    }

    // optional uint32 email_msg_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_email_msg_type());
    }

    // optional int32 email_lang = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_email_lang());
    }

    // optional int32 email_format = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_email_format());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCGetEmailTemplate::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCGetEmailTemplate*>(
      &from));
}

void CMsgGCGetEmailTemplate::MergeFrom(const CMsgGCGetEmailTemplate& from) {
  CMsgGCGetEmailTemplate* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCGetEmailTemplate)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.app_id_ = from._impl_.app_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.email_msg_type_ = from._impl_.email_msg_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.email_lang_ = from._impl_.email_lang_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.email_format_ = from._impl_.email_format_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCGetEmailTemplate::CopyFrom(const CMsgGCGetEmailTemplate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCGetEmailTemplate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCGetEmailTemplate::IsInitialized() const {
  return true;
}

void CMsgGCGetEmailTemplate::InternalSwap(CMsgGCGetEmailTemplate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCGetEmailTemplate, _impl_.email_format_)
      + sizeof(CMsgGCGetEmailTemplate::_impl_.email_format_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCGetEmailTemplate, _impl_.app_id_)>(
          reinterpret_cast<char*>(&_impl_.app_id_),
          reinterpret_cast<char*>(&other->_impl_.app_id_));
}

std::string CMsgGCGetEmailTemplate::GetTypeName() const {
  return "CMsgGCGetEmailTemplate";
}


// ===================================================================

class CMsgGCGetEmailTemplateResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCGetEmailTemplateResponse>()._impl_._has_bits_);
  static void set_has_eresult(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_template_exists(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_template_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCGetEmailTemplateResponse::CMsgGCGetEmailTemplateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCGetEmailTemplateResponse)
}
CMsgGCGetEmailTemplateResponse::CMsgGCGetEmailTemplateResponse(const CMsgGCGetEmailTemplateResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCGetEmailTemplateResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.template__){}
    , decltype(_impl_.template_exists_){}
    , decltype(_impl_.eresult_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.template__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.template__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_template_()) {
    _this->_impl_.template__.Set(from._internal_template_(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.template_exists_, &from._impl_.template_exists_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.eresult_) -
    reinterpret_cast<char*>(&_impl_.template_exists_)) + sizeof(_impl_.eresult_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCGetEmailTemplateResponse)
}

inline void CMsgGCGetEmailTemplateResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.template__){}
    , decltype(_impl_.template_exists_){false}
    , decltype(_impl_.eresult_){2u}
  };
  _impl_.template__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.template__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCGetEmailTemplateResponse::~CMsgGCGetEmailTemplateResponse() {
  // @@protoc_insertion_point(destructor:CMsgGCGetEmailTemplateResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCGetEmailTemplateResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.template__.Destroy();
}

void CMsgGCGetEmailTemplateResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCGetEmailTemplateResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCGetEmailTemplateResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.template__.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    _impl_.template_exists_ = false;
    _impl_.eresult_ = 2u;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCGetEmailTemplateResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 eresult = 1 [default = 2];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_eresult(&has_bits);
          _impl_.eresult_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool template_exists = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_template_exists(&has_bits);
          _impl_.template_exists_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string template = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_template_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCGetEmailTemplateResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCGetEmailTemplateResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 eresult = 1 [default = 2];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_eresult(), target);
  }

  // optional bool template_exists = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_template_exists(), target);
  }

  // optional string template = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_template_(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCGetEmailTemplateResponse)
  return target;
}

size_t CMsgGCGetEmailTemplateResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCGetEmailTemplateResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string template = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_template_());
    }

    // optional bool template_exists = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional uint32 eresult = 1 [default = 2];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_eresult());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCGetEmailTemplateResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCGetEmailTemplateResponse*>(
      &from));
}

void CMsgGCGetEmailTemplateResponse::MergeFrom(const CMsgGCGetEmailTemplateResponse& from) {
  CMsgGCGetEmailTemplateResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCGetEmailTemplateResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_template_(from._internal_template_());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.template_exists_ = from._impl_.template_exists_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.eresult_ = from._impl_.eresult_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCGetEmailTemplateResponse::CopyFrom(const CMsgGCGetEmailTemplateResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCGetEmailTemplateResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCGetEmailTemplateResponse::IsInitialized() const {
  return true;
}

void CMsgGCGetEmailTemplateResponse::InternalSwap(CMsgGCGetEmailTemplateResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.template__, lhs_arena,
      &other->_impl_.template__, rhs_arena
  );
  swap(_impl_.template_exists_, other->_impl_.template_exists_);
  swap(_impl_.eresult_, other->_impl_.eresult_);
}

std::string CMsgGCGetEmailTemplateResponse::GetTypeName() const {
  return "CMsgGCGetEmailTemplateResponse";
}


// ===================================================================

class CMsgAMGrantGuestPasses2::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgAMGrantGuestPasses2>()._impl_._has_bits_);
  static void set_has_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_package_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_passes_to_grant(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_days_to_expiration(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_action(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CMsgAMGrantGuestPasses2::CMsgAMGrantGuestPasses2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgAMGrantGuestPasses2)
}
CMsgAMGrantGuestPasses2::CMsgAMGrantGuestPasses2(const CMsgAMGrantGuestPasses2& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgAMGrantGuestPasses2* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steam_id_){}
    , decltype(_impl_.package_id_){}
    , decltype(_impl_.passes_to_grant_){}
    , decltype(_impl_.days_to_expiration_){}
    , decltype(_impl_.action_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.steam_id_, &from._impl_.steam_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.action_) -
    reinterpret_cast<char*>(&_impl_.steam_id_)) + sizeof(_impl_.action_));
  // @@protoc_insertion_point(copy_constructor:CMsgAMGrantGuestPasses2)
}

inline void CMsgAMGrantGuestPasses2::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steam_id_){uint64_t{0u}}
    , decltype(_impl_.package_id_){0u}
    , decltype(_impl_.passes_to_grant_){0}
    , decltype(_impl_.days_to_expiration_){0}
    , decltype(_impl_.action_){0}
  };
}

CMsgAMGrantGuestPasses2::~CMsgAMGrantGuestPasses2() {
  // @@protoc_insertion_point(destructor:CMsgAMGrantGuestPasses2)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgAMGrantGuestPasses2::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgAMGrantGuestPasses2::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgAMGrantGuestPasses2::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgAMGrantGuestPasses2)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.steam_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.action_) -
        reinterpret_cast<char*>(&_impl_.steam_id_)) + sizeof(_impl_.action_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgAMGrantGuestPasses2::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steam_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steam_id(&has_bits);
          _impl_.steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 package_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_package_id(&has_bits);
          _impl_.package_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 passes_to_grant = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_passes_to_grant(&has_bits);
          _impl_.passes_to_grant_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 days_to_expiration = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_days_to_expiration(&has_bits);
          _impl_.days_to_expiration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 action = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_action(&has_bits);
          _impl_.action_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgAMGrantGuestPasses2::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgAMGrantGuestPasses2)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steam_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steam_id(), target);
  }

  // optional uint32 package_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_package_id(), target);
  }

  // optional int32 passes_to_grant = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_passes_to_grant(), target);
  }

  // optional int32 days_to_expiration = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_days_to_expiration(), target);
  }

  // optional int32 action = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_action(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgAMGrantGuestPasses2)
  return target;
}

size_t CMsgAMGrantGuestPasses2::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgAMGrantGuestPasses2)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional fixed64 steam_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional uint32 package_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_package_id());
    }

    // optional int32 passes_to_grant = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_passes_to_grant());
    }

    // optional int32 days_to_expiration = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_days_to_expiration());
    }

    // optional int32 action = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_action());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgAMGrantGuestPasses2::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgAMGrantGuestPasses2*>(
      &from));
}

void CMsgAMGrantGuestPasses2::MergeFrom(const CMsgAMGrantGuestPasses2& from) {
  CMsgAMGrantGuestPasses2* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgAMGrantGuestPasses2)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.steam_id_ = from._impl_.steam_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.package_id_ = from._impl_.package_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.passes_to_grant_ = from._impl_.passes_to_grant_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.days_to_expiration_ = from._impl_.days_to_expiration_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.action_ = from._impl_.action_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgAMGrantGuestPasses2::CopyFrom(const CMsgAMGrantGuestPasses2& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgAMGrantGuestPasses2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgAMGrantGuestPasses2::IsInitialized() const {
  return true;
}

void CMsgAMGrantGuestPasses2::InternalSwap(CMsgAMGrantGuestPasses2* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgAMGrantGuestPasses2, _impl_.action_)
      + sizeof(CMsgAMGrantGuestPasses2::_impl_.action_)
      - PROTOBUF_FIELD_OFFSET(CMsgAMGrantGuestPasses2, _impl_.steam_id_)>(
          reinterpret_cast<char*>(&_impl_.steam_id_),
          reinterpret_cast<char*>(&other->_impl_.steam_id_));
}

std::string CMsgAMGrantGuestPasses2::GetTypeName() const {
  return "CMsgAMGrantGuestPasses2";
}


// ===================================================================

class CMsgAMGrantGuestPasses2Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgAMGrantGuestPasses2Response>()._impl_._has_bits_);
  static void set_has_eresult(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_passes_granted(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgAMGrantGuestPasses2Response::CMsgAMGrantGuestPasses2Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgAMGrantGuestPasses2Response)
}
CMsgAMGrantGuestPasses2Response::CMsgAMGrantGuestPasses2Response(const CMsgAMGrantGuestPasses2Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgAMGrantGuestPasses2Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.passes_granted_){}
    , decltype(_impl_.eresult_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.passes_granted_, &from._impl_.passes_granted_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.eresult_) -
    reinterpret_cast<char*>(&_impl_.passes_granted_)) + sizeof(_impl_.eresult_));
  // @@protoc_insertion_point(copy_constructor:CMsgAMGrantGuestPasses2Response)
}

inline void CMsgAMGrantGuestPasses2Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.passes_granted_){0}
    , decltype(_impl_.eresult_){2}
  };
}

CMsgAMGrantGuestPasses2Response::~CMsgAMGrantGuestPasses2Response() {
  // @@protoc_insertion_point(destructor:CMsgAMGrantGuestPasses2Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgAMGrantGuestPasses2Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgAMGrantGuestPasses2Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgAMGrantGuestPasses2Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgAMGrantGuestPasses2Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.passes_granted_ = 0;
    _impl_.eresult_ = 2;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgAMGrantGuestPasses2Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 eresult = 1 [default = 2];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_eresult(&has_bits);
          _impl_.eresult_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 passes_granted = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_passes_granted(&has_bits);
          _impl_.passes_granted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgAMGrantGuestPasses2Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgAMGrantGuestPasses2Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 eresult = 1 [default = 2];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_eresult(), target);
  }

  // optional int32 passes_granted = 2 [default = 0];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_passes_granted(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgAMGrantGuestPasses2Response)
  return target;
}

size_t CMsgAMGrantGuestPasses2Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgAMGrantGuestPasses2Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 passes_granted = 2 [default = 0];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_passes_granted());
    }

    // optional int32 eresult = 1 [default = 2];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_eresult());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgAMGrantGuestPasses2Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgAMGrantGuestPasses2Response*>(
      &from));
}

void CMsgAMGrantGuestPasses2Response::MergeFrom(const CMsgAMGrantGuestPasses2Response& from) {
  CMsgAMGrantGuestPasses2Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgAMGrantGuestPasses2Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.passes_granted_ = from._impl_.passes_granted_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.eresult_ = from._impl_.eresult_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgAMGrantGuestPasses2Response::CopyFrom(const CMsgAMGrantGuestPasses2Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgAMGrantGuestPasses2Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgAMGrantGuestPasses2Response::IsInitialized() const {
  return true;
}

void CMsgAMGrantGuestPasses2Response::InternalSwap(CMsgAMGrantGuestPasses2Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.passes_granted_, other->_impl_.passes_granted_);
  swap(_impl_.eresult_, other->_impl_.eresult_);
}

std::string CMsgAMGrantGuestPasses2Response::GetTypeName() const {
  return "CMsgAMGrantGuestPasses2Response";
}


// ===================================================================

class CGCSystemMsg_GetAccountDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<CGCSystemMsg_GetAccountDetails>()._impl_._has_bits_);
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CGCSystemMsg_GetAccountDetails::CGCSystemMsg_GetAccountDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCSystemMsg_GetAccountDetails)
}
CGCSystemMsg_GetAccountDetails::CGCSystemMsg_GetAccountDetails(const CGCSystemMsg_GetAccountDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGCSystemMsg_GetAccountDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steamid_){}
    , decltype(_impl_.appid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.steamid_, &from._impl_.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.appid_) -
    reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.appid_));
  // @@protoc_insertion_point(copy_constructor:CGCSystemMsg_GetAccountDetails)
}

inline void CGCSystemMsg_GetAccountDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steamid_){uint64_t{0u}}
    , decltype(_impl_.appid_){0u}
  };
}

CGCSystemMsg_GetAccountDetails::~CGCSystemMsg_GetAccountDetails() {
  // @@protoc_insertion_point(destructor:CGCSystemMsg_GetAccountDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCSystemMsg_GetAccountDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CGCSystemMsg_GetAccountDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCSystemMsg_GetAccountDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCSystemMsg_GetAccountDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.appid_) -
        reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.appid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CGCSystemMsg_GetAccountDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steamid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steamid(&has_bits);
          _impl_.steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 appid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_appid(&has_bits);
          _impl_.appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCSystemMsg_GetAccountDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCSystemMsg_GetAccountDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steamid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steamid(), target);
  }

  // optional uint32 appid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_appid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCSystemMsg_GetAccountDetails)
  return target;
}

size_t CGCSystemMsg_GetAccountDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCSystemMsg_GetAccountDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional fixed64 steamid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional uint32 appid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGCSystemMsg_GetAccountDetails::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGCSystemMsg_GetAccountDetails*>(
      &from));
}

void CGCSystemMsg_GetAccountDetails::MergeFrom(const CGCSystemMsg_GetAccountDetails& from) {
  CGCSystemMsg_GetAccountDetails* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCSystemMsg_GetAccountDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.steamid_ = from._impl_.steamid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.appid_ = from._impl_.appid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGCSystemMsg_GetAccountDetails::CopyFrom(const CGCSystemMsg_GetAccountDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCSystemMsg_GetAccountDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCSystemMsg_GetAccountDetails::IsInitialized() const {
  return true;
}

void CGCSystemMsg_GetAccountDetails::InternalSwap(CGCSystemMsg_GetAccountDetails* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CGCSystemMsg_GetAccountDetails, _impl_.appid_)
      + sizeof(CGCSystemMsg_GetAccountDetails::_impl_.appid_)
      - PROTOBUF_FIELD_OFFSET(CGCSystemMsg_GetAccountDetails, _impl_.steamid_)>(
          reinterpret_cast<char*>(&_impl_.steamid_),
          reinterpret_cast<char*>(&other->_impl_.steamid_));
}

std::string CGCSystemMsg_GetAccountDetails::GetTypeName() const {
  return "CGCSystemMsg_GetAccountDetails";
}


// ===================================================================

class CGCSystemMsg_GetAccountDetails_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CGCSystemMsg_GetAccountDetails_Response>()._impl_._has_bits_);
  static void set_has_eresult_deprecated(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static void set_has_account_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_persona_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_profile_public(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_is_inventory_public(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_is_vac_banned(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_is_cyber_cafe(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_is_school_account(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_is_limited(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_is_subscribed(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_package(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_is_free_trial_account(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_free_trial_expiration(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_is_low_violence(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_is_account_locked_down(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_is_community_banned(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_is_trade_banned(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_trade_ban_expiration(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_accountid(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_suspension_end_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_currency(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_steam_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_friend_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_account_creation_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_is_steamguard_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_is_phone_verified(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_is_two_factor_auth_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_two_factor_enabled_time(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_phone_verification_time(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_phone_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_is_phone_identifying(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_rt_identity_linked(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_rt_birth_date(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_txn_country_code(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_has_accepted_china_ssa(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_is_banned_steam_china(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
};

CGCSystemMsg_GetAccountDetails_Response::CGCSystemMsg_GetAccountDetails_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCSystemMsg_GetAccountDetails_Response)
}
CGCSystemMsg_GetAccountDetails_Response::CGCSystemMsg_GetAccountDetails_Response(const CGCSystemMsg_GetAccountDetails_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGCSystemMsg_GetAccountDetails_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_name_){}
    , decltype(_impl_.persona_name_){}
    , decltype(_impl_.currency_){}
    , decltype(_impl_.txn_country_code_){}
    , decltype(_impl_.is_profile_public_){}
    , decltype(_impl_.is_inventory_public_){}
    , decltype(_impl_.is_vac_banned_){}
    , decltype(_impl_.is_cyber_cafe_){}
    , decltype(_impl_.is_school_account_){}
    , decltype(_impl_.is_limited_){}
    , decltype(_impl_.is_subscribed_){}
    , decltype(_impl_.is_free_trial_account_){}
    , decltype(_impl_.package_){}
    , decltype(_impl_.free_trial_expiration_){}
    , decltype(_impl_.is_low_violence_){}
    , decltype(_impl_.is_account_locked_down_){}
    , decltype(_impl_.is_community_banned_){}
    , decltype(_impl_.is_trade_banned_){}
    , decltype(_impl_.trade_ban_expiration_){}
    , decltype(_impl_.accountid_){}
    , decltype(_impl_.suspension_end_time_){}
    , decltype(_impl_.steam_level_){}
    , decltype(_impl_.friend_count_){}
    , decltype(_impl_.account_creation_time_){}
    , decltype(_impl_.is_steamguard_enabled_){}
    , decltype(_impl_.is_phone_verified_){}
    , decltype(_impl_.is_two_factor_auth_enabled_){}
    , decltype(_impl_.is_phone_identifying_){}
    , decltype(_impl_.two_factor_enabled_time_){}
    , decltype(_impl_.phone_verification_time_){}
    , decltype(_impl_.phone_id_){}
    , decltype(_impl_.rt_identity_linked_){}
    , decltype(_impl_.rt_birth_date_){}
    , decltype(_impl_.has_accepted_china_ssa_){}
    , decltype(_impl_.is_banned_steam_china_){}
    , decltype(_impl_.eresult_deprecated_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.account_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_account_name()) {
    _this->_impl_.account_name_.Set(from._internal_account_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.persona_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.persona_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_persona_name()) {
    _this->_impl_.persona_name_.Set(from._internal_persona_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.currency_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currency_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_currency()) {
    _this->_impl_.currency_.Set(from._internal_currency(), 
      _this->GetArenaForAllocation());
  }
  _impl_.txn_country_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.txn_country_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_txn_country_code()) {
    _this->_impl_.txn_country_code_.Set(from._internal_txn_country_code(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.is_profile_public_, &from._impl_.is_profile_public_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.eresult_deprecated_) -
    reinterpret_cast<char*>(&_impl_.is_profile_public_)) + sizeof(_impl_.eresult_deprecated_));
  // @@protoc_insertion_point(copy_constructor:CGCSystemMsg_GetAccountDetails_Response)
}

inline void CGCSystemMsg_GetAccountDetails_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_name_){}
    , decltype(_impl_.persona_name_){}
    , decltype(_impl_.currency_){}
    , decltype(_impl_.txn_country_code_){}
    , decltype(_impl_.is_profile_public_){false}
    , decltype(_impl_.is_inventory_public_){false}
    , decltype(_impl_.is_vac_banned_){false}
    , decltype(_impl_.is_cyber_cafe_){false}
    , decltype(_impl_.is_school_account_){false}
    , decltype(_impl_.is_limited_){false}
    , decltype(_impl_.is_subscribed_){false}
    , decltype(_impl_.is_free_trial_account_){false}
    , decltype(_impl_.package_){0u}
    , decltype(_impl_.free_trial_expiration_){0u}
    , decltype(_impl_.is_low_violence_){false}
    , decltype(_impl_.is_account_locked_down_){false}
    , decltype(_impl_.is_community_banned_){false}
    , decltype(_impl_.is_trade_banned_){false}
    , decltype(_impl_.trade_ban_expiration_){0u}
    , decltype(_impl_.accountid_){0u}
    , decltype(_impl_.suspension_end_time_){0u}
    , decltype(_impl_.steam_level_){0u}
    , decltype(_impl_.friend_count_){0u}
    , decltype(_impl_.account_creation_time_){0u}
    , decltype(_impl_.is_steamguard_enabled_){false}
    , decltype(_impl_.is_phone_verified_){false}
    , decltype(_impl_.is_two_factor_auth_enabled_){false}
    , decltype(_impl_.is_phone_identifying_){false}
    , decltype(_impl_.two_factor_enabled_time_){0u}
    , decltype(_impl_.phone_verification_time_){0u}
    , decltype(_impl_.phone_id_){uint64_t{0u}}
    , decltype(_impl_.rt_identity_linked_){0u}
    , decltype(_impl_.rt_birth_date_){0u}
    , decltype(_impl_.has_accepted_china_ssa_){false}
    , decltype(_impl_.is_banned_steam_china_){false}
    , decltype(_impl_.eresult_deprecated_){2u}
  };
  _impl_.account_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.persona_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.persona_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.currency_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currency_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.txn_country_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.txn_country_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CGCSystemMsg_GetAccountDetails_Response::~CGCSystemMsg_GetAccountDetails_Response() {
  // @@protoc_insertion_point(destructor:CGCSystemMsg_GetAccountDetails_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCSystemMsg_GetAccountDetails_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_name_.Destroy();
  _impl_.persona_name_.Destroy();
  _impl_.currency_.Destroy();
  _impl_.txn_country_code_.Destroy();
}

void CGCSystemMsg_GetAccountDetails_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCSystemMsg_GetAccountDetails_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCSystemMsg_GetAccountDetails_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.account_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.persona_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.currency_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.txn_country_code_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.is_profile_public_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_cyber_cafe_) -
        reinterpret_cast<char*>(&_impl_.is_profile_public_)) + sizeof(_impl_.is_cyber_cafe_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.is_school_account_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_account_locked_down_) -
        reinterpret_cast<char*>(&_impl_.is_school_account_)) + sizeof(_impl_.is_account_locked_down_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.is_community_banned_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.account_creation_time_) -
        reinterpret_cast<char*>(&_impl_.is_community_banned_)) + sizeof(_impl_.account_creation_time_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.is_steamguard_enabled_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.rt_identity_linked_) -
        reinterpret_cast<char*>(&_impl_.is_steamguard_enabled_)) + sizeof(_impl_.rt_identity_linked_));
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.rt_birth_date_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_banned_steam_china_) -
        reinterpret_cast<char*>(&_impl_.rt_birth_date_)) + sizeof(_impl_.is_banned_steam_china_));
    _impl_.eresult_deprecated_ = 2u;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CGCSystemMsg_GetAccountDetails_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 eresult_deprecated = 1 [default = 2];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_eresult_deprecated(&_impl_._has_bits_);
          _impl_.eresult_deprecated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string account_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_account_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string persona_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_persona_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_profile_public = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_profile_public(&_impl_._has_bits_);
          _impl_.is_profile_public_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_inventory_public = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_is_inventory_public(&_impl_._has_bits_);
          _impl_.is_inventory_public_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_vac_banned = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_is_vac_banned(&_impl_._has_bits_);
          _impl_.is_vac_banned_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_cyber_cafe = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_is_cyber_cafe(&_impl_._has_bits_);
          _impl_.is_cyber_cafe_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_school_account = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_is_school_account(&_impl_._has_bits_);
          _impl_.is_school_account_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_limited = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_is_limited(&_impl_._has_bits_);
          _impl_.is_limited_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_subscribed = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_is_subscribed(&_impl_._has_bits_);
          _impl_.is_subscribed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 package = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_package(&_impl_._has_bits_);
          _impl_.package_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_free_trial_account = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_is_free_trial_account(&_impl_._has_bits_);
          _impl_.is_free_trial_account_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 free_trial_expiration = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_free_trial_expiration(&_impl_._has_bits_);
          _impl_.free_trial_expiration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_low_violence = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_is_low_violence(&_impl_._has_bits_);
          _impl_.is_low_violence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_account_locked_down = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_is_account_locked_down(&_impl_._has_bits_);
          _impl_.is_account_locked_down_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_community_banned = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_is_community_banned(&_impl_._has_bits_);
          _impl_.is_community_banned_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_trade_banned = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_is_trade_banned(&_impl_._has_bits_);
          _impl_.is_trade_banned_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 trade_ban_expiration = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_trade_ban_expiration(&_impl_._has_bits_);
          _impl_.trade_ban_expiration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 accountid = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_accountid(&_impl_._has_bits_);
          _impl_.accountid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 suspension_end_time = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_suspension_end_time(&_impl_._has_bits_);
          _impl_.suspension_end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string currency = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          auto str = _internal_mutable_currency();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 steam_level = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_steam_level(&_impl_._has_bits_);
          _impl_.steam_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 friend_count = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_friend_count(&_impl_._has_bits_);
          _impl_.friend_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 account_creation_time = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_account_creation_time(&_impl_._has_bits_);
          _impl_.account_creation_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_steamguard_enabled = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_is_steamguard_enabled(&_impl_._has_bits_);
          _impl_.is_steamguard_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_phone_verified = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_is_phone_verified(&_impl_._has_bits_);
          _impl_.is_phone_verified_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_two_factor_auth_enabled = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_is_two_factor_auth_enabled(&_impl_._has_bits_);
          _impl_.is_two_factor_auth_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 two_factor_enabled_time = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _Internal::set_has_two_factor_enabled_time(&_impl_._has_bits_);
          _impl_.two_factor_enabled_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 phone_verification_time = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_phone_verification_time(&_impl_._has_bits_);
          _impl_.phone_verification_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 phone_id = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_phone_id(&_impl_._has_bits_);
          _impl_.phone_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_phone_identifying = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_is_phone_identifying(&_impl_._has_bits_);
          _impl_.is_phone_identifying_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rt_identity_linked = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_rt_identity_linked(&_impl_._has_bits_);
          _impl_.rt_identity_linked_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rt_birth_date = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_rt_birth_date(&_impl_._has_bits_);
          _impl_.rt_birth_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string txn_country_code = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_txn_country_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool has_accepted_china_ssa = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_has_accepted_china_ssa(&_impl_._has_bits_);
          _impl_.has_accepted_china_ssa_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_banned_steam_china = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_is_banned_steam_china(&_impl_._has_bits_);
          _impl_.is_banned_steam_china_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCSystemMsg_GetAccountDetails_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCSystemMsg_GetAccountDetails_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[1];
  // optional uint32 eresult_deprecated = 1 [default = 2];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_eresult_deprecated(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string account_name = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_account_name(), target);
  }

  // optional string persona_name = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_persona_name(), target);
  }

  // optional bool is_profile_public = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_profile_public(), target);
  }

  // optional bool is_inventory_public = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_is_inventory_public(), target);
  }

  // optional bool is_vac_banned = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_is_vac_banned(), target);
  }

  // optional bool is_cyber_cafe = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_is_cyber_cafe(), target);
  }

  // optional bool is_school_account = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_is_school_account(), target);
  }

  // optional bool is_limited = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_is_limited(), target);
  }

  // optional bool is_subscribed = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_is_subscribed(), target);
  }

  // optional uint32 package = 12;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_package(), target);
  }

  // optional bool is_free_trial_account = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_is_free_trial_account(), target);
  }

  // optional uint32 free_trial_expiration = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_free_trial_expiration(), target);
  }

  // optional bool is_low_violence = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_is_low_violence(), target);
  }

  // optional bool is_account_locked_down = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_is_account_locked_down(), target);
  }

  // optional bool is_community_banned = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_is_community_banned(), target);
  }

  // optional bool is_trade_banned = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_is_trade_banned(), target);
  }

  // optional uint32 trade_ban_expiration = 19;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_trade_ban_expiration(), target);
  }

  // optional uint32 accountid = 20;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_accountid(), target);
  }

  // optional uint32 suspension_end_time = 21;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_suspension_end_time(), target);
  }

  // optional string currency = 22;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        22, this->_internal_currency(), target);
  }

  // optional uint32 steam_level = 23;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(23, this->_internal_steam_level(), target);
  }

  // optional uint32 friend_count = 24;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(24, this->_internal_friend_count(), target);
  }

  // optional uint32 account_creation_time = 25;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(25, this->_internal_account_creation_time(), target);
  }

  // optional bool is_steamguard_enabled = 27;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(27, this->_internal_is_steamguard_enabled(), target);
  }

  // optional bool is_phone_verified = 28;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(28, this->_internal_is_phone_verified(), target);
  }

  // optional bool is_two_factor_auth_enabled = 29;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(29, this->_internal_is_two_factor_auth_enabled(), target);
  }

  // optional uint32 two_factor_enabled_time = 30;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(30, this->_internal_two_factor_enabled_time(), target);
  }

  // optional uint32 phone_verification_time = 31;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(31, this->_internal_phone_verification_time(), target);
  }

  // optional uint64 phone_id = 33;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(33, this->_internal_phone_id(), target);
  }

  // optional bool is_phone_identifying = 34;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(34, this->_internal_is_phone_identifying(), target);
  }

  // optional uint32 rt_identity_linked = 35;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(35, this->_internal_rt_identity_linked(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional uint32 rt_birth_date = 36;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(36, this->_internal_rt_birth_date(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string txn_country_code = 37;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        37, this->_internal_txn_country_code(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional bool has_accepted_china_ssa = 38;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(38, this->_internal_has_accepted_china_ssa(), target);
  }

  // optional bool is_banned_steam_china = 39;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(39, this->_internal_is_banned_steam_china(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCSystemMsg_GetAccountDetails_Response)
  return target;
}

size_t CGCSystemMsg_GetAccountDetails_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCSystemMsg_GetAccountDetails_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string account_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_account_name());
    }

    // optional string persona_name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_persona_name());
    }

    // optional string currency = 22;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_currency());
    }

    // optional string txn_country_code = 37;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_txn_country_code());
    }

    // optional bool is_profile_public = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool is_inventory_public = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool is_vac_banned = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool is_cyber_cafe = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool is_school_account = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool is_limited = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool is_subscribed = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool is_free_trial_account = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional uint32 package = 12;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_package());
    }

    // optional uint32 free_trial_expiration = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_free_trial_expiration());
    }

    // optional bool is_low_violence = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional bool is_account_locked_down = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional bool is_community_banned = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional bool is_trade_banned = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional uint32 trade_ban_expiration = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_trade_ban_expiration());
    }

    // optional uint32 accountid = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_accountid());
    }

    // optional uint32 suspension_end_time = 21;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_suspension_end_time());
    }

    // optional uint32 steam_level = 23;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_steam_level());
    }

    // optional uint32 friend_count = 24;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_friend_count());
    }

    // optional uint32 account_creation_time = 25;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_account_creation_time());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional bool is_steamguard_enabled = 27;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 1;
    }

    // optional bool is_phone_verified = 28;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 1;
    }

    // optional bool is_two_factor_auth_enabled = 29;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 1;
    }

    // optional bool is_phone_identifying = 34;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 1;
    }

    // optional uint32 two_factor_enabled_time = 30;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_two_factor_enabled_time());
    }

    // optional uint32 phone_verification_time = 31;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_phone_verification_time());
    }

    // optional uint64 phone_id = 33;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_phone_id());
    }

    // optional uint32 rt_identity_linked = 35;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_rt_identity_linked());
    }

  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 rt_birth_date = 36;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_rt_birth_date());
    }

    // optional bool has_accepted_china_ssa = 38;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + 1;
    }

    // optional bool is_banned_steam_china = 39;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + 1;
    }

    // optional uint32 eresult_deprecated = 1 [default = 2];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_eresult_deprecated());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGCSystemMsg_GetAccountDetails_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGCSystemMsg_GetAccountDetails_Response*>(
      &from));
}

void CGCSystemMsg_GetAccountDetails_Response::MergeFrom(const CGCSystemMsg_GetAccountDetails_Response& from) {
  CGCSystemMsg_GetAccountDetails_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCSystemMsg_GetAccountDetails_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_account_name(from._internal_account_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_persona_name(from._internal_persona_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_currency(from._internal_currency());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_txn_country_code(from._internal_txn_country_code());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.is_profile_public_ = from._impl_.is_profile_public_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.is_inventory_public_ = from._impl_.is_inventory_public_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.is_vac_banned_ = from._impl_.is_vac_banned_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.is_cyber_cafe_ = from._impl_.is_cyber_cafe_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.is_school_account_ = from._impl_.is_school_account_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.is_limited_ = from._impl_.is_limited_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.is_subscribed_ = from._impl_.is_subscribed_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.is_free_trial_account_ = from._impl_.is_free_trial_account_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.package_ = from._impl_.package_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.free_trial_expiration_ = from._impl_.free_trial_expiration_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.is_low_violence_ = from._impl_.is_low_violence_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.is_account_locked_down_ = from._impl_.is_account_locked_down_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.is_community_banned_ = from._impl_.is_community_banned_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.is_trade_banned_ = from._impl_.is_trade_banned_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.trade_ban_expiration_ = from._impl_.trade_ban_expiration_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.accountid_ = from._impl_.accountid_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.suspension_end_time_ = from._impl_.suspension_end_time_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.steam_level_ = from._impl_.steam_level_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.friend_count_ = from._impl_.friend_count_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.account_creation_time_ = from._impl_.account_creation_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.is_steamguard_enabled_ = from._impl_.is_steamguard_enabled_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.is_phone_verified_ = from._impl_.is_phone_verified_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.is_two_factor_auth_enabled_ = from._impl_.is_two_factor_auth_enabled_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.is_phone_identifying_ = from._impl_.is_phone_identifying_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.two_factor_enabled_time_ = from._impl_.two_factor_enabled_time_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.phone_verification_time_ = from._impl_.phone_verification_time_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.phone_id_ = from._impl_.phone_id_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.rt_identity_linked_ = from._impl_.rt_identity_linked_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.rt_birth_date_ = from._impl_.rt_birth_date_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.has_accepted_china_ssa_ = from._impl_.has_accepted_china_ssa_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.is_banned_steam_china_ = from._impl_.is_banned_steam_china_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.eresult_deprecated_ = from._impl_.eresult_deprecated_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGCSystemMsg_GetAccountDetails_Response::CopyFrom(const CGCSystemMsg_GetAccountDetails_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCSystemMsg_GetAccountDetails_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCSystemMsg_GetAccountDetails_Response::IsInitialized() const {
  return true;
}

void CGCSystemMsg_GetAccountDetails_Response::InternalSwap(CGCSystemMsg_GetAccountDetails_Response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.account_name_, lhs_arena,
      &other->_impl_.account_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.persona_name_, lhs_arena,
      &other->_impl_.persona_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.currency_, lhs_arena,
      &other->_impl_.currency_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.txn_country_code_, lhs_arena,
      &other->_impl_.txn_country_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CGCSystemMsg_GetAccountDetails_Response, _impl_.is_banned_steam_china_)
      + sizeof(CGCSystemMsg_GetAccountDetails_Response::_impl_.is_banned_steam_china_)
      - PROTOBUF_FIELD_OFFSET(CGCSystemMsg_GetAccountDetails_Response, _impl_.is_profile_public_)>(
          reinterpret_cast<char*>(&_impl_.is_profile_public_),
          reinterpret_cast<char*>(&other->_impl_.is_profile_public_));
  swap(_impl_.eresult_deprecated_, other->_impl_.eresult_deprecated_);
}

std::string CGCSystemMsg_GetAccountDetails_Response::GetTypeName() const {
  return "CGCSystemMsg_GetAccountDetails_Response";
}


// ===================================================================

class CMsgGCGetPersonaNames::_Internal {
 public:
};

CMsgGCGetPersonaNames::CMsgGCGetPersonaNames(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCGetPersonaNames)
}
CMsgGCGetPersonaNames::CMsgGCGetPersonaNames(const CMsgGCGetPersonaNames& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCGetPersonaNames* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.steamids_){from._impl_.steamids_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgGCGetPersonaNames)
}

inline void CMsgGCGetPersonaNames::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.steamids_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgGCGetPersonaNames::~CMsgGCGetPersonaNames() {
  // @@protoc_insertion_point(destructor:CMsgGCGetPersonaNames)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCGetPersonaNames::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.steamids_.~RepeatedField();
}

void CMsgGCGetPersonaNames::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCGetPersonaNames::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCGetPersonaNames)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.steamids_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCGetPersonaNames::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated fixed64 steamids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_steamids(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr));
            ptr += sizeof(uint64_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<9>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed64Parser(_internal_mutable_steamids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCGetPersonaNames::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCGetPersonaNames)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated fixed64 steamids = 1;
  for (int i = 0, n = this->_internal_steamids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steamids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCGetPersonaNames)
  return target;
}

size_t CMsgGCGetPersonaNames::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCGetPersonaNames)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed64 steamids = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_steamids_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_steamids_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCGetPersonaNames::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCGetPersonaNames*>(
      &from));
}

void CMsgGCGetPersonaNames::MergeFrom(const CMsgGCGetPersonaNames& from) {
  CMsgGCGetPersonaNames* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCGetPersonaNames)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.steamids_.MergeFrom(from._impl_.steamids_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCGetPersonaNames::CopyFrom(const CMsgGCGetPersonaNames& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCGetPersonaNames)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCGetPersonaNames::IsInitialized() const {
  return true;
}

void CMsgGCGetPersonaNames::InternalSwap(CMsgGCGetPersonaNames* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.steamids_.InternalSwap(&other->_impl_.steamids_);
}

std::string CMsgGCGetPersonaNames::GetTypeName() const {
  return "CMsgGCGetPersonaNames";
}


// ===================================================================

class CMsgGCGetPersonaNames_Response_PersonaName::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCGetPersonaNames_Response_PersonaName>()._impl_._has_bits_);
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_persona_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCGetPersonaNames_Response_PersonaName::CMsgGCGetPersonaNames_Response_PersonaName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCGetPersonaNames_Response.PersonaName)
}
CMsgGCGetPersonaNames_Response_PersonaName::CMsgGCGetPersonaNames_Response_PersonaName(const CMsgGCGetPersonaNames_Response_PersonaName& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCGetPersonaNames_Response_PersonaName* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.persona_name_){}
    , decltype(_impl_.steamid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.persona_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.persona_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_persona_name()) {
    _this->_impl_.persona_name_.Set(from._internal_persona_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.steamid_ = from._impl_.steamid_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCGetPersonaNames_Response.PersonaName)
}

inline void CMsgGCGetPersonaNames_Response_PersonaName::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.persona_name_){}
    , decltype(_impl_.steamid_){uint64_t{0u}}
  };
  _impl_.persona_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.persona_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCGetPersonaNames_Response_PersonaName::~CMsgGCGetPersonaNames_Response_PersonaName() {
  // @@protoc_insertion_point(destructor:CMsgGCGetPersonaNames_Response.PersonaName)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCGetPersonaNames_Response_PersonaName::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.persona_name_.Destroy();
}

void CMsgGCGetPersonaNames_Response_PersonaName::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCGetPersonaNames_Response_PersonaName::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCGetPersonaNames_Response.PersonaName)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.persona_name_.ClearNonDefaultToEmpty();
  }
  _impl_.steamid_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCGetPersonaNames_Response_PersonaName::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steamid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steamid(&has_bits);
          _impl_.steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional string persona_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_persona_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCGetPersonaNames_Response_PersonaName::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCGetPersonaNames_Response.PersonaName)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steamid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steamid(), target);
  }

  // optional string persona_name = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_persona_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCGetPersonaNames_Response.PersonaName)
  return target;
}

size_t CMsgGCGetPersonaNames_Response_PersonaName::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCGetPersonaNames_Response.PersonaName)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string persona_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_persona_name());
    }

    // optional fixed64 steamid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCGetPersonaNames_Response_PersonaName::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCGetPersonaNames_Response_PersonaName*>(
      &from));
}

void CMsgGCGetPersonaNames_Response_PersonaName::MergeFrom(const CMsgGCGetPersonaNames_Response_PersonaName& from) {
  CMsgGCGetPersonaNames_Response_PersonaName* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCGetPersonaNames_Response.PersonaName)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_persona_name(from._internal_persona_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.steamid_ = from._impl_.steamid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCGetPersonaNames_Response_PersonaName::CopyFrom(const CMsgGCGetPersonaNames_Response_PersonaName& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCGetPersonaNames_Response.PersonaName)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCGetPersonaNames_Response_PersonaName::IsInitialized() const {
  return true;
}

void CMsgGCGetPersonaNames_Response_PersonaName::InternalSwap(CMsgGCGetPersonaNames_Response_PersonaName* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.persona_name_, lhs_arena,
      &other->_impl_.persona_name_, rhs_arena
  );
  swap(_impl_.steamid_, other->_impl_.steamid_);
}

std::string CMsgGCGetPersonaNames_Response_PersonaName::GetTypeName() const {
  return "CMsgGCGetPersonaNames_Response.PersonaName";
}


// ===================================================================

class CMsgGCGetPersonaNames_Response::_Internal {
 public:
};

CMsgGCGetPersonaNames_Response::CMsgGCGetPersonaNames_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCGetPersonaNames_Response)
}
CMsgGCGetPersonaNames_Response::CMsgGCGetPersonaNames_Response(const CMsgGCGetPersonaNames_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCGetPersonaNames_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.succeeded_lookups_){from._impl_.succeeded_lookups_}
    , decltype(_impl_.failed_lookup_steamids_){from._impl_.failed_lookup_steamids_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgGCGetPersonaNames_Response)
}

inline void CMsgGCGetPersonaNames_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.succeeded_lookups_){arena}
    , decltype(_impl_.failed_lookup_steamids_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgGCGetPersonaNames_Response::~CMsgGCGetPersonaNames_Response() {
  // @@protoc_insertion_point(destructor:CMsgGCGetPersonaNames_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCGetPersonaNames_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.succeeded_lookups_.~RepeatedPtrField();
  _impl_.failed_lookup_steamids_.~RepeatedField();
}

void CMsgGCGetPersonaNames_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCGetPersonaNames_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCGetPersonaNames_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.succeeded_lookups_.Clear();
  _impl_.failed_lookup_steamids_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCGetPersonaNames_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgGCGetPersonaNames_Response.PersonaName succeeded_lookups = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_succeeded_lookups(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated fixed64 failed_lookup_steamids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_failed_lookup_steamids(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr));
            ptr += sizeof(uint64_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<17>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed64Parser(_internal_mutable_failed_lookup_steamids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCGetPersonaNames_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCGetPersonaNames_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgGCGetPersonaNames_Response.PersonaName succeeded_lookups = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_succeeded_lookups_size()); i < n; i++) {
    const auto& repfield = this->_internal_succeeded_lookups(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated fixed64 failed_lookup_steamids = 2;
  for (int i = 0, n = this->_internal_failed_lookup_steamids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_failed_lookup_steamids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCGetPersonaNames_Response)
  return target;
}

size_t CMsgGCGetPersonaNames_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCGetPersonaNames_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgGCGetPersonaNames_Response.PersonaName succeeded_lookups = 1;
  total_size += 1UL * this->_internal_succeeded_lookups_size();
  for (const auto& msg : this->_impl_.succeeded_lookups_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated fixed64 failed_lookup_steamids = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_failed_lookup_steamids_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_failed_lookup_steamids_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCGetPersonaNames_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCGetPersonaNames_Response*>(
      &from));
}

void CMsgGCGetPersonaNames_Response::MergeFrom(const CMsgGCGetPersonaNames_Response& from) {
  CMsgGCGetPersonaNames_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCGetPersonaNames_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.succeeded_lookups_.MergeFrom(from._impl_.succeeded_lookups_);
  _this->_impl_.failed_lookup_steamids_.MergeFrom(from._impl_.failed_lookup_steamids_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCGetPersonaNames_Response::CopyFrom(const CMsgGCGetPersonaNames_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCGetPersonaNames_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCGetPersonaNames_Response::IsInitialized() const {
  return true;
}

void CMsgGCGetPersonaNames_Response::InternalSwap(CMsgGCGetPersonaNames_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.succeeded_lookups_.InternalSwap(&other->_impl_.succeeded_lookups_);
  _impl_.failed_lookup_steamids_.InternalSwap(&other->_impl_.failed_lookup_steamids_);
}

std::string CMsgGCGetPersonaNames_Response::GetTypeName() const {
  return "CMsgGCGetPersonaNames_Response";
}


// ===================================================================

class CMsgGCCheckFriendship::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCCheckFriendship>()._impl_._has_bits_);
  static void set_has_steamid_left(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_steamid_right(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgGCCheckFriendship::CMsgGCCheckFriendship(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCCheckFriendship)
}
CMsgGCCheckFriendship::CMsgGCCheckFriendship(const CMsgGCCheckFriendship& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCCheckFriendship* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steamid_left_){}
    , decltype(_impl_.steamid_right_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.steamid_left_, &from._impl_.steamid_left_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.steamid_right_) -
    reinterpret_cast<char*>(&_impl_.steamid_left_)) + sizeof(_impl_.steamid_right_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCCheckFriendship)
}

inline void CMsgGCCheckFriendship::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steamid_left_){uint64_t{0u}}
    , decltype(_impl_.steamid_right_){uint64_t{0u}}
  };
}

CMsgGCCheckFriendship::~CMsgGCCheckFriendship() {
  // @@protoc_insertion_point(destructor:CMsgGCCheckFriendship)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCCheckFriendship::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCCheckFriendship::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCCheckFriendship::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCCheckFriendship)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.steamid_left_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.steamid_right_) -
        reinterpret_cast<char*>(&_impl_.steamid_left_)) + sizeof(_impl_.steamid_right_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCCheckFriendship::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steamid_left = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steamid_left(&has_bits);
          _impl_.steamid_left_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 steamid_right = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_steamid_right(&has_bits);
          _impl_.steamid_right_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCCheckFriendship::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCCheckFriendship)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steamid_left = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steamid_left(), target);
  }

  // optional fixed64 steamid_right = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_steamid_right(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCCheckFriendship)
  return target;
}

size_t CMsgGCCheckFriendship::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCCheckFriendship)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional fixed64 steamid_left = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional fixed64 steamid_right = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCCheckFriendship::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCCheckFriendship*>(
      &from));
}

void CMsgGCCheckFriendship::MergeFrom(const CMsgGCCheckFriendship& from) {
  CMsgGCCheckFriendship* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCCheckFriendship)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.steamid_left_ = from._impl_.steamid_left_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.steamid_right_ = from._impl_.steamid_right_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCCheckFriendship::CopyFrom(const CMsgGCCheckFriendship& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCCheckFriendship)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCCheckFriendship::IsInitialized() const {
  return true;
}

void CMsgGCCheckFriendship::InternalSwap(CMsgGCCheckFriendship* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCCheckFriendship, _impl_.steamid_right_)
      + sizeof(CMsgGCCheckFriendship::_impl_.steamid_right_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCCheckFriendship, _impl_.steamid_left_)>(
          reinterpret_cast<char*>(&_impl_.steamid_left_),
          reinterpret_cast<char*>(&other->_impl_.steamid_left_));
}

std::string CMsgGCCheckFriendship::GetTypeName() const {
  return "CMsgGCCheckFriendship";
}


// ===================================================================

class CMsgGCCheckFriendship_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCCheckFriendship_Response>()._impl_._has_bits_);
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_found_friendship(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgGCCheckFriendship_Response::CMsgGCCheckFriendship_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCCheckFriendship_Response)
}
CMsgGCCheckFriendship_Response::CMsgGCCheckFriendship_Response(const CMsgGCCheckFriendship_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCCheckFriendship_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.success_){}
    , decltype(_impl_.found_friendship_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.success_, &from._impl_.success_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.found_friendship_) -
    reinterpret_cast<char*>(&_impl_.success_)) + sizeof(_impl_.found_friendship_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCCheckFriendship_Response)
}

inline void CMsgGCCheckFriendship_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.success_){false}
    , decltype(_impl_.found_friendship_){false}
  };
}

CMsgGCCheckFriendship_Response::~CMsgGCCheckFriendship_Response() {
  // @@protoc_insertion_point(destructor:CMsgGCCheckFriendship_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCCheckFriendship_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCCheckFriendship_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCCheckFriendship_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCCheckFriendship_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.success_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.found_friendship_) -
      reinterpret_cast<char*>(&_impl_.success_)) + sizeof(_impl_.found_friendship_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCCheckFriendship_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_success(&has_bits);
          _impl_.success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool found_friendship = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_found_friendship(&has_bits);
          _impl_.found_friendship_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCCheckFriendship_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCCheckFriendship_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool success = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_success(), target);
  }

  // optional bool found_friendship = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_found_friendship(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCCheckFriendship_Response)
  return target;
}

size_t CMsgGCCheckFriendship_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCCheckFriendship_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool success = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool found_friendship = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCCheckFriendship_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCCheckFriendship_Response*>(
      &from));
}

void CMsgGCCheckFriendship_Response::MergeFrom(const CMsgGCCheckFriendship_Response& from) {
  CMsgGCCheckFriendship_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCCheckFriendship_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.success_ = from._impl_.success_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.found_friendship_ = from._impl_.found_friendship_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCCheckFriendship_Response::CopyFrom(const CMsgGCCheckFriendship_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCCheckFriendship_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCCheckFriendship_Response::IsInitialized() const {
  return true;
}

void CMsgGCCheckFriendship_Response::InternalSwap(CMsgGCCheckFriendship_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCCheckFriendship_Response, _impl_.found_friendship_)
      + sizeof(CMsgGCCheckFriendship_Response::_impl_.found_friendship_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCCheckFriendship_Response, _impl_.success_)>(
          reinterpret_cast<char*>(&_impl_.success_),
          reinterpret_cast<char*>(&other->_impl_.success_));
}

std::string CMsgGCCheckFriendship_Response::GetTypeName() const {
  return "CMsgGCCheckFriendship_Response";
}


// ===================================================================

class CMsgGCMsgMasterSetDirectory_SubGC::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCMsgMasterSetDirectory_SubGC>()._impl_._has_bits_);
  static void set_has_dir_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_box(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_command_line(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gc_binary(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgGCMsgMasterSetDirectory_SubGC::CMsgGCMsgMasterSetDirectory_SubGC(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCMsgMasterSetDirectory.SubGC)
}
CMsgGCMsgMasterSetDirectory_SubGC::CMsgGCMsgMasterSetDirectory_SubGC(const CMsgGCMsgMasterSetDirectory_SubGC& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCMsgMasterSetDirectory_SubGC* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.box_){}
    , decltype(_impl_.command_line_){}
    , decltype(_impl_.gc_binary_){}
    , decltype(_impl_.dir_index_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.box_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.box_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_box()) {
    _this->_impl_.box_.Set(from._internal_box(), 
      _this->GetArenaForAllocation());
  }
  _impl_.command_line_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.command_line_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_command_line()) {
    _this->_impl_.command_line_.Set(from._internal_command_line(), 
      _this->GetArenaForAllocation());
  }
  _impl_.gc_binary_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gc_binary_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gc_binary()) {
    _this->_impl_.gc_binary_.Set(from._internal_gc_binary(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.dir_index_ = from._impl_.dir_index_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCMsgMasterSetDirectory.SubGC)
}

inline void CMsgGCMsgMasterSetDirectory_SubGC::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.box_){}
    , decltype(_impl_.command_line_){}
    , decltype(_impl_.gc_binary_){}
    , decltype(_impl_.dir_index_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.box_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.box_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.command_line_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.command_line_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.gc_binary_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gc_binary_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCMsgMasterSetDirectory_SubGC::~CMsgGCMsgMasterSetDirectory_SubGC() {
  // @@protoc_insertion_point(destructor:CMsgGCMsgMasterSetDirectory.SubGC)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCMsgMasterSetDirectory_SubGC::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.box_.Destroy();
  _impl_.command_line_.Destroy();
  _impl_.gc_binary_.Destroy();
}

void CMsgGCMsgMasterSetDirectory_SubGC::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCMsgMasterSetDirectory_SubGC::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCMsgMasterSetDirectory.SubGC)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.box_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.command_line_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.gc_binary_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.dir_index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCMsgMasterSetDirectory_SubGC::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 dir_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dir_index(&has_bits);
          _impl_.dir_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string box = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_box();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string command_line = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_command_line();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string gc_binary = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_gc_binary();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCMsgMasterSetDirectory_SubGC::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCMsgMasterSetDirectory.SubGC)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 dir_index = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_dir_index(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional string box = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_box(), target);
  }

  // optional string command_line = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_command_line(), target);
  }

  // optional string gc_binary = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_gc_binary(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCMsgMasterSetDirectory.SubGC)
  return target;
}

size_t CMsgGCMsgMasterSetDirectory_SubGC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCMsgMasterSetDirectory.SubGC)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string box = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_box());
    }

    // optional string command_line = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_command_line());
    }

    // optional string gc_binary = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_gc_binary());
    }

    // optional uint32 dir_index = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dir_index());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCMsgMasterSetDirectory_SubGC::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCMsgMasterSetDirectory_SubGC*>(
      &from));
}

void CMsgGCMsgMasterSetDirectory_SubGC::MergeFrom(const CMsgGCMsgMasterSetDirectory_SubGC& from) {
  CMsgGCMsgMasterSetDirectory_SubGC* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCMsgMasterSetDirectory.SubGC)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_box(from._internal_box());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_command_line(from._internal_command_line());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_gc_binary(from._internal_gc_binary());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.dir_index_ = from._impl_.dir_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCMsgMasterSetDirectory_SubGC::CopyFrom(const CMsgGCMsgMasterSetDirectory_SubGC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCMsgMasterSetDirectory.SubGC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCMsgMasterSetDirectory_SubGC::IsInitialized() const {
  return true;
}

void CMsgGCMsgMasterSetDirectory_SubGC::InternalSwap(CMsgGCMsgMasterSetDirectory_SubGC* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.box_, lhs_arena,
      &other->_impl_.box_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.command_line_, lhs_arena,
      &other->_impl_.command_line_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.gc_binary_, lhs_arena,
      &other->_impl_.gc_binary_, rhs_arena
  );
  swap(_impl_.dir_index_, other->_impl_.dir_index_);
}

std::string CMsgGCMsgMasterSetDirectory_SubGC::GetTypeName() const {
  return "CMsgGCMsgMasterSetDirectory.SubGC";
}


// ===================================================================

class CMsgGCMsgMasterSetDirectory::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCMsgMasterSetDirectory>()._impl_._has_bits_);
  static void set_has_master_dir_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCMsgMasterSetDirectory::CMsgGCMsgMasterSetDirectory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCMsgMasterSetDirectory)
}
CMsgGCMsgMasterSetDirectory::CMsgGCMsgMasterSetDirectory(const CMsgGCMsgMasterSetDirectory& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCMsgMasterSetDirectory* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dir_){from._impl_.dir_}
    , decltype(_impl_.master_dir_index_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.master_dir_index_ = from._impl_.master_dir_index_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCMsgMasterSetDirectory)
}

inline void CMsgGCMsgMasterSetDirectory::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dir_){arena}
    , decltype(_impl_.master_dir_index_){0u}
  };
}

CMsgGCMsgMasterSetDirectory::~CMsgGCMsgMasterSetDirectory() {
  // @@protoc_insertion_point(destructor:CMsgGCMsgMasterSetDirectory)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCMsgMasterSetDirectory::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dir_.~RepeatedPtrField();
}

void CMsgGCMsgMasterSetDirectory::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCMsgMasterSetDirectory::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCMsgMasterSetDirectory)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dir_.Clear();
  _impl_.master_dir_index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCMsgMasterSetDirectory::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 master_dir_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_master_dir_index(&has_bits);
          _impl_.master_dir_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgGCMsgMasterSetDirectory.SubGC dir = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_dir(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCMsgMasterSetDirectory::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCMsgMasterSetDirectory)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 master_dir_index = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_master_dir_index(), target);
  }

  // repeated .CMsgGCMsgMasterSetDirectory.SubGC dir = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_dir_size()); i < n; i++) {
    const auto& repfield = this->_internal_dir(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCMsgMasterSetDirectory)
  return target;
}

size_t CMsgGCMsgMasterSetDirectory::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCMsgMasterSetDirectory)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgGCMsgMasterSetDirectory.SubGC dir = 2;
  total_size += 1UL * this->_internal_dir_size();
  for (const auto& msg : this->_impl_.dir_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint32 master_dir_index = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_master_dir_index());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCMsgMasterSetDirectory::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCMsgMasterSetDirectory*>(
      &from));
}

void CMsgGCMsgMasterSetDirectory::MergeFrom(const CMsgGCMsgMasterSetDirectory& from) {
  CMsgGCMsgMasterSetDirectory* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCMsgMasterSetDirectory)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.dir_.MergeFrom(from._impl_.dir_);
  if (from._internal_has_master_dir_index()) {
    _this->_internal_set_master_dir_index(from._internal_master_dir_index());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCMsgMasterSetDirectory::CopyFrom(const CMsgGCMsgMasterSetDirectory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCMsgMasterSetDirectory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCMsgMasterSetDirectory::IsInitialized() const {
  return true;
}

void CMsgGCMsgMasterSetDirectory::InternalSwap(CMsgGCMsgMasterSetDirectory* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.dir_.InternalSwap(&other->_impl_.dir_);
  swap(_impl_.master_dir_index_, other->_impl_.master_dir_index_);
}

std::string CMsgGCMsgMasterSetDirectory::GetTypeName() const {
  return "CMsgGCMsgMasterSetDirectory";
}


// ===================================================================

class CMsgGCMsgMasterSetDirectory_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCMsgMasterSetDirectory_Response>()._impl_._has_bits_);
  static void set_has_eresult(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCMsgMasterSetDirectory_Response::CMsgGCMsgMasterSetDirectory_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCMsgMasterSetDirectory_Response)
}
CMsgGCMsgMasterSetDirectory_Response::CMsgGCMsgMasterSetDirectory_Response(const CMsgGCMsgMasterSetDirectory_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCMsgMasterSetDirectory_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}
    , decltype(_impl_.eresult_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.eresult_ = from._impl_.eresult_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCMsgMasterSetDirectory_Response)
}

inline void CMsgGCMsgMasterSetDirectory_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}
    , decltype(_impl_.eresult_){2}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCMsgMasterSetDirectory_Response::~CMsgGCMsgMasterSetDirectory_Response() {
  // @@protoc_insertion_point(destructor:CMsgGCMsgMasterSetDirectory_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCMsgMasterSetDirectory_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
}

void CMsgGCMsgMasterSetDirectory_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCMsgMasterSetDirectory_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCMsgMasterSetDirectory_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.message_.ClearNonDefaultToEmpty();
    }
    _impl_.eresult_ = 2;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCMsgMasterSetDirectory_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 eresult = 1 [default = 2];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_eresult(&has_bits);
          _impl_.eresult_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCMsgMasterSetDirectory_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCMsgMasterSetDirectory_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 eresult = 1 [default = 2];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_eresult(), target);
  }

  // optional string message = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCMsgMasterSetDirectory_Response)
  return target;
}

size_t CMsgGCMsgMasterSetDirectory_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCMsgMasterSetDirectory_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string message = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message());
    }

    // optional int32 eresult = 1 [default = 2];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_eresult());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCMsgMasterSetDirectory_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCMsgMasterSetDirectory_Response*>(
      &from));
}

void CMsgGCMsgMasterSetDirectory_Response::MergeFrom(const CMsgGCMsgMasterSetDirectory_Response& from) {
  CMsgGCMsgMasterSetDirectory_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCMsgMasterSetDirectory_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.eresult_ = from._impl_.eresult_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCMsgMasterSetDirectory_Response::CopyFrom(const CMsgGCMsgMasterSetDirectory_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCMsgMasterSetDirectory_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCMsgMasterSetDirectory_Response::IsInitialized() const {
  return true;
}

void CMsgGCMsgMasterSetDirectory_Response::InternalSwap(CMsgGCMsgMasterSetDirectory_Response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  swap(_impl_.eresult_, other->_impl_.eresult_);
}

std::string CMsgGCMsgMasterSetDirectory_Response::GetTypeName() const {
  return "CMsgGCMsgMasterSetDirectory_Response";
}


// ===================================================================

class CMsgGCMsgWebAPIJobRequestForwardResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCMsgWebAPIJobRequestForwardResponse>()._impl_._has_bits_);
  static void set_has_dir_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCMsgWebAPIJobRequestForwardResponse::CMsgGCMsgWebAPIJobRequestForwardResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCMsgWebAPIJobRequestForwardResponse)
}
CMsgGCMsgWebAPIJobRequestForwardResponse::CMsgGCMsgWebAPIJobRequestForwardResponse(const CMsgGCMsgWebAPIJobRequestForwardResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCMsgWebAPIJobRequestForwardResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dir_index_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.dir_index_ = from._impl_.dir_index_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCMsgWebAPIJobRequestForwardResponse)
}

inline void CMsgGCMsgWebAPIJobRequestForwardResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dir_index_){0u}
  };
}

CMsgGCMsgWebAPIJobRequestForwardResponse::~CMsgGCMsgWebAPIJobRequestForwardResponse() {
  // @@protoc_insertion_point(destructor:CMsgGCMsgWebAPIJobRequestForwardResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCMsgWebAPIJobRequestForwardResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCMsgWebAPIJobRequestForwardResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCMsgWebAPIJobRequestForwardResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCMsgWebAPIJobRequestForwardResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dir_index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCMsgWebAPIJobRequestForwardResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 dir_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dir_index(&has_bits);
          _impl_.dir_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCMsgWebAPIJobRequestForwardResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCMsgWebAPIJobRequestForwardResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 dir_index = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_dir_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCMsgWebAPIJobRequestForwardResponse)
  return target;
}

size_t CMsgGCMsgWebAPIJobRequestForwardResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCMsgWebAPIJobRequestForwardResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 dir_index = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dir_index());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCMsgWebAPIJobRequestForwardResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCMsgWebAPIJobRequestForwardResponse*>(
      &from));
}

void CMsgGCMsgWebAPIJobRequestForwardResponse::MergeFrom(const CMsgGCMsgWebAPIJobRequestForwardResponse& from) {
  CMsgGCMsgWebAPIJobRequestForwardResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCMsgWebAPIJobRequestForwardResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_dir_index()) {
    _this->_internal_set_dir_index(from._internal_dir_index());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCMsgWebAPIJobRequestForwardResponse::CopyFrom(const CMsgGCMsgWebAPIJobRequestForwardResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCMsgWebAPIJobRequestForwardResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCMsgWebAPIJobRequestForwardResponse::IsInitialized() const {
  return true;
}

void CMsgGCMsgWebAPIJobRequestForwardResponse::InternalSwap(CMsgGCMsgWebAPIJobRequestForwardResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.dir_index_, other->_impl_.dir_index_);
}

std::string CMsgGCMsgWebAPIJobRequestForwardResponse::GetTypeName() const {
  return "CMsgGCMsgWebAPIJobRequestForwardResponse";
}


// ===================================================================

class CGCSystemMsg_GetPurchaseTrust_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CGCSystemMsg_GetPurchaseTrust_Request>()._impl_._has_bits_);
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CGCSystemMsg_GetPurchaseTrust_Request::CGCSystemMsg_GetPurchaseTrust_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCSystemMsg_GetPurchaseTrust_Request)
}
CGCSystemMsg_GetPurchaseTrust_Request::CGCSystemMsg_GetPurchaseTrust_Request(const CGCSystemMsg_GetPurchaseTrust_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGCSystemMsg_GetPurchaseTrust_Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steamid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.steamid_ = from._impl_.steamid_;
  // @@protoc_insertion_point(copy_constructor:CGCSystemMsg_GetPurchaseTrust_Request)
}

inline void CGCSystemMsg_GetPurchaseTrust_Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steamid_){uint64_t{0u}}
  };
}

CGCSystemMsg_GetPurchaseTrust_Request::~CGCSystemMsg_GetPurchaseTrust_Request() {
  // @@protoc_insertion_point(destructor:CGCSystemMsg_GetPurchaseTrust_Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCSystemMsg_GetPurchaseTrust_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CGCSystemMsg_GetPurchaseTrust_Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCSystemMsg_GetPurchaseTrust_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCSystemMsg_GetPurchaseTrust_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.steamid_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CGCSystemMsg_GetPurchaseTrust_Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steamid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steamid(&has_bits);
          _impl_.steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCSystemMsg_GetPurchaseTrust_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCSystemMsg_GetPurchaseTrust_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steamid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steamid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCSystemMsg_GetPurchaseTrust_Request)
  return target;
}

size_t CGCSystemMsg_GetPurchaseTrust_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCSystemMsg_GetPurchaseTrust_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional fixed64 steamid = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 8;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGCSystemMsg_GetPurchaseTrust_Request::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGCSystemMsg_GetPurchaseTrust_Request*>(
      &from));
}

void CGCSystemMsg_GetPurchaseTrust_Request::MergeFrom(const CGCSystemMsg_GetPurchaseTrust_Request& from) {
  CGCSystemMsg_GetPurchaseTrust_Request* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCSystemMsg_GetPurchaseTrust_Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_steamid()) {
    _this->_internal_set_steamid(from._internal_steamid());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGCSystemMsg_GetPurchaseTrust_Request::CopyFrom(const CGCSystemMsg_GetPurchaseTrust_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCSystemMsg_GetPurchaseTrust_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCSystemMsg_GetPurchaseTrust_Request::IsInitialized() const {
  return true;
}

void CGCSystemMsg_GetPurchaseTrust_Request::InternalSwap(CGCSystemMsg_GetPurchaseTrust_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.steamid_, other->_impl_.steamid_);
}

std::string CGCSystemMsg_GetPurchaseTrust_Request::GetTypeName() const {
  return "CGCSystemMsg_GetPurchaseTrust_Request";
}


// ===================================================================

class CGCSystemMsg_GetPurchaseTrust_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CGCSystemMsg_GetPurchaseTrust_Response>()._impl_._has_bits_);
  static void set_has_has_prior_purchase_history(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_has_no_recent_password_resets(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_wallet_cash_trusted(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_time_all_trusted(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CGCSystemMsg_GetPurchaseTrust_Response::CGCSystemMsg_GetPurchaseTrust_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCSystemMsg_GetPurchaseTrust_Response)
}
CGCSystemMsg_GetPurchaseTrust_Response::CGCSystemMsg_GetPurchaseTrust_Response(const CGCSystemMsg_GetPurchaseTrust_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGCSystemMsg_GetPurchaseTrust_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.has_prior_purchase_history_){}
    , decltype(_impl_.has_no_recent_password_resets_){}
    , decltype(_impl_.is_wallet_cash_trusted_){}
    , decltype(_impl_.time_all_trusted_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.has_prior_purchase_history_, &from._impl_.has_prior_purchase_history_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.time_all_trusted_) -
    reinterpret_cast<char*>(&_impl_.has_prior_purchase_history_)) + sizeof(_impl_.time_all_trusted_));
  // @@protoc_insertion_point(copy_constructor:CGCSystemMsg_GetPurchaseTrust_Response)
}

inline void CGCSystemMsg_GetPurchaseTrust_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.has_prior_purchase_history_){false}
    , decltype(_impl_.has_no_recent_password_resets_){false}
    , decltype(_impl_.is_wallet_cash_trusted_){false}
    , decltype(_impl_.time_all_trusted_){0u}
  };
}

CGCSystemMsg_GetPurchaseTrust_Response::~CGCSystemMsg_GetPurchaseTrust_Response() {
  // @@protoc_insertion_point(destructor:CGCSystemMsg_GetPurchaseTrust_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCSystemMsg_GetPurchaseTrust_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CGCSystemMsg_GetPurchaseTrust_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCSystemMsg_GetPurchaseTrust_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCSystemMsg_GetPurchaseTrust_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.has_prior_purchase_history_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.time_all_trusted_) -
        reinterpret_cast<char*>(&_impl_.has_prior_purchase_history_)) + sizeof(_impl_.time_all_trusted_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CGCSystemMsg_GetPurchaseTrust_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool has_prior_purchase_history = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_has_prior_purchase_history(&has_bits);
          _impl_.has_prior_purchase_history_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool has_no_recent_password_resets = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_has_no_recent_password_resets(&has_bits);
          _impl_.has_no_recent_password_resets_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_wallet_cash_trusted = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_wallet_cash_trusted(&has_bits);
          _impl_.is_wallet_cash_trusted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 time_all_trusted = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_time_all_trusted(&has_bits);
          _impl_.time_all_trusted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCSystemMsg_GetPurchaseTrust_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCSystemMsg_GetPurchaseTrust_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool has_prior_purchase_history = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_has_prior_purchase_history(), target);
  }

  // optional bool has_no_recent_password_resets = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_has_no_recent_password_resets(), target);
  }

  // optional bool is_wallet_cash_trusted = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_wallet_cash_trusted(), target);
  }

  // optional uint32 time_all_trusted = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_time_all_trusted(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCSystemMsg_GetPurchaseTrust_Response)
  return target;
}

size_t CGCSystemMsg_GetPurchaseTrust_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCSystemMsg_GetPurchaseTrust_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bool has_prior_purchase_history = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool has_no_recent_password_resets = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool is_wallet_cash_trusted = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional uint32 time_all_trusted = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_time_all_trusted());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGCSystemMsg_GetPurchaseTrust_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGCSystemMsg_GetPurchaseTrust_Response*>(
      &from));
}

void CGCSystemMsg_GetPurchaseTrust_Response::MergeFrom(const CGCSystemMsg_GetPurchaseTrust_Response& from) {
  CGCSystemMsg_GetPurchaseTrust_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCSystemMsg_GetPurchaseTrust_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.has_prior_purchase_history_ = from._impl_.has_prior_purchase_history_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.has_no_recent_password_resets_ = from._impl_.has_no_recent_password_resets_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.is_wallet_cash_trusted_ = from._impl_.is_wallet_cash_trusted_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.time_all_trusted_ = from._impl_.time_all_trusted_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGCSystemMsg_GetPurchaseTrust_Response::CopyFrom(const CGCSystemMsg_GetPurchaseTrust_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCSystemMsg_GetPurchaseTrust_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCSystemMsg_GetPurchaseTrust_Response::IsInitialized() const {
  return true;
}

void CGCSystemMsg_GetPurchaseTrust_Response::InternalSwap(CGCSystemMsg_GetPurchaseTrust_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CGCSystemMsg_GetPurchaseTrust_Response, _impl_.time_all_trusted_)
      + sizeof(CGCSystemMsg_GetPurchaseTrust_Response::_impl_.time_all_trusted_)
      - PROTOBUF_FIELD_OFFSET(CGCSystemMsg_GetPurchaseTrust_Response, _impl_.has_prior_purchase_history_)>(
          reinterpret_cast<char*>(&_impl_.has_prior_purchase_history_),
          reinterpret_cast<char*>(&other->_impl_.has_prior_purchase_history_));
}

std::string CGCSystemMsg_GetPurchaseTrust_Response::GetTypeName() const {
  return "CGCSystemMsg_GetPurchaseTrust_Response";
}


// ===================================================================

class CMsgGCHAccountVacStatusChange::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCHAccountVacStatusChange>()._impl_._has_bits_);
  static void set_has_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_app_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rtime_vacban_starts(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_banned_now(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_is_banned_future(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CMsgGCHAccountVacStatusChange::CMsgGCHAccountVacStatusChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCHAccountVacStatusChange)
}
CMsgGCHAccountVacStatusChange::CMsgGCHAccountVacStatusChange(const CMsgGCHAccountVacStatusChange& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCHAccountVacStatusChange* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steam_id_){}
    , decltype(_impl_.app_id_){}
    , decltype(_impl_.rtime_vacban_starts_){}
    , decltype(_impl_.is_banned_now_){}
    , decltype(_impl_.is_banned_future_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.steam_id_, &from._impl_.steam_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_banned_future_) -
    reinterpret_cast<char*>(&_impl_.steam_id_)) + sizeof(_impl_.is_banned_future_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCHAccountVacStatusChange)
}

inline void CMsgGCHAccountVacStatusChange::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steam_id_){uint64_t{0u}}
    , decltype(_impl_.app_id_){0u}
    , decltype(_impl_.rtime_vacban_starts_){0u}
    , decltype(_impl_.is_banned_now_){false}
    , decltype(_impl_.is_banned_future_){false}
  };
}

CMsgGCHAccountVacStatusChange::~CMsgGCHAccountVacStatusChange() {
  // @@protoc_insertion_point(destructor:CMsgGCHAccountVacStatusChange)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCHAccountVacStatusChange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCHAccountVacStatusChange::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCHAccountVacStatusChange::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCHAccountVacStatusChange)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.steam_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_banned_future_) -
        reinterpret_cast<char*>(&_impl_.steam_id_)) + sizeof(_impl_.is_banned_future_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCHAccountVacStatusChange::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steam_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steam_id(&has_bits);
          _impl_.steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 app_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_app_id(&has_bits);
          _impl_.app_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rtime_vacban_starts = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_rtime_vacban_starts(&has_bits);
          _impl_.rtime_vacban_starts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_banned_now = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_banned_now(&has_bits);
          _impl_.is_banned_now_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_banned_future = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_is_banned_future(&has_bits);
          _impl_.is_banned_future_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCHAccountVacStatusChange::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCHAccountVacStatusChange)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steam_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steam_id(), target);
  }

  // optional uint32 app_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_app_id(), target);
  }

  // optional uint32 rtime_vacban_starts = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_rtime_vacban_starts(), target);
  }

  // optional bool is_banned_now = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_banned_now(), target);
  }

  // optional bool is_banned_future = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_is_banned_future(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCHAccountVacStatusChange)
  return target;
}

size_t CMsgGCHAccountVacStatusChange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCHAccountVacStatusChange)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional fixed64 steam_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional uint32 app_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_app_id());
    }

    // optional uint32 rtime_vacban_starts = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rtime_vacban_starts());
    }

    // optional bool is_banned_now = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool is_banned_future = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCHAccountVacStatusChange::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCHAccountVacStatusChange*>(
      &from));
}

void CMsgGCHAccountVacStatusChange::MergeFrom(const CMsgGCHAccountVacStatusChange& from) {
  CMsgGCHAccountVacStatusChange* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCHAccountVacStatusChange)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.steam_id_ = from._impl_.steam_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.app_id_ = from._impl_.app_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.rtime_vacban_starts_ = from._impl_.rtime_vacban_starts_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.is_banned_now_ = from._impl_.is_banned_now_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.is_banned_future_ = from._impl_.is_banned_future_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCHAccountVacStatusChange::CopyFrom(const CMsgGCHAccountVacStatusChange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCHAccountVacStatusChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCHAccountVacStatusChange::IsInitialized() const {
  return true;
}

void CMsgGCHAccountVacStatusChange::InternalSwap(CMsgGCHAccountVacStatusChange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCHAccountVacStatusChange, _impl_.is_banned_future_)
      + sizeof(CMsgGCHAccountVacStatusChange::_impl_.is_banned_future_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCHAccountVacStatusChange, _impl_.steam_id_)>(
          reinterpret_cast<char*>(&_impl_.steam_id_),
          reinterpret_cast<char*>(&other->_impl_.steam_id_));
}

std::string CMsgGCHAccountVacStatusChange::GetTypeName() const {
  return "CMsgGCHAccountVacStatusChange";
}


// ===================================================================

class CMsgGCGetPartnerAccountLink::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCGetPartnerAccountLink>()._impl_._has_bits_);
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCGetPartnerAccountLink::CMsgGCGetPartnerAccountLink(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCGetPartnerAccountLink)
}
CMsgGCGetPartnerAccountLink::CMsgGCGetPartnerAccountLink(const CMsgGCGetPartnerAccountLink& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCGetPartnerAccountLink* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steamid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.steamid_ = from._impl_.steamid_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCGetPartnerAccountLink)
}

inline void CMsgGCGetPartnerAccountLink::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steamid_){uint64_t{0u}}
  };
}

CMsgGCGetPartnerAccountLink::~CMsgGCGetPartnerAccountLink() {
  // @@protoc_insertion_point(destructor:CMsgGCGetPartnerAccountLink)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCGetPartnerAccountLink::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCGetPartnerAccountLink::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCGetPartnerAccountLink::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCGetPartnerAccountLink)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.steamid_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCGetPartnerAccountLink::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steamid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steamid(&has_bits);
          _impl_.steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCGetPartnerAccountLink::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCGetPartnerAccountLink)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steamid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steamid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCGetPartnerAccountLink)
  return target;
}

size_t CMsgGCGetPartnerAccountLink::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCGetPartnerAccountLink)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional fixed64 steamid = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 8;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCGetPartnerAccountLink::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCGetPartnerAccountLink*>(
      &from));
}

void CMsgGCGetPartnerAccountLink::MergeFrom(const CMsgGCGetPartnerAccountLink& from) {
  CMsgGCGetPartnerAccountLink* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCGetPartnerAccountLink)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_steamid()) {
    _this->_internal_set_steamid(from._internal_steamid());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCGetPartnerAccountLink::CopyFrom(const CMsgGCGetPartnerAccountLink& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCGetPartnerAccountLink)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCGetPartnerAccountLink::IsInitialized() const {
  return true;
}

void CMsgGCGetPartnerAccountLink::InternalSwap(CMsgGCGetPartnerAccountLink* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.steamid_, other->_impl_.steamid_);
}

std::string CMsgGCGetPartnerAccountLink::GetTypeName() const {
  return "CMsgGCGetPartnerAccountLink";
}


// ===================================================================

class CMsgGCGetPartnerAccountLink_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCGetPartnerAccountLink_Response>()._impl_._has_bits_);
  static void set_has_pwid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nexonid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ageclass(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_id_verified(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_is_adult(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgGCGetPartnerAccountLink_Response::CMsgGCGetPartnerAccountLink_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCGetPartnerAccountLink_Response)
}
CMsgGCGetPartnerAccountLink_Response::CMsgGCGetPartnerAccountLink_Response(const CMsgGCGetPartnerAccountLink_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCGetPartnerAccountLink_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pwid_){}
    , decltype(_impl_.nexonid_){}
    , decltype(_impl_.ageclass_){}
    , decltype(_impl_.is_adult_){}
    , decltype(_impl_.id_verified_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.pwid_, &from._impl_.pwid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.id_verified_) -
    reinterpret_cast<char*>(&_impl_.pwid_)) + sizeof(_impl_.id_verified_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCGetPartnerAccountLink_Response)
}

inline void CMsgGCGetPartnerAccountLink_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pwid_){0u}
    , decltype(_impl_.nexonid_){0u}
    , decltype(_impl_.ageclass_){0}
    , decltype(_impl_.is_adult_){false}
    , decltype(_impl_.id_verified_){true}
  };
}

CMsgGCGetPartnerAccountLink_Response::~CMsgGCGetPartnerAccountLink_Response() {
  // @@protoc_insertion_point(destructor:CMsgGCGetPartnerAccountLink_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCGetPartnerAccountLink_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCGetPartnerAccountLink_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCGetPartnerAccountLink_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCGetPartnerAccountLink_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.pwid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_adult_) -
        reinterpret_cast<char*>(&_impl_.pwid_)) + sizeof(_impl_.is_adult_));
    _impl_.id_verified_ = true;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCGetPartnerAccountLink_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 pwid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_pwid(&has_bits);
          _impl_.pwid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 nexonid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_nexonid(&has_bits);
          _impl_.nexonid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ageclass = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ageclass(&has_bits);
          _impl_.ageclass_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool id_verified = 4 [default = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_id_verified(&has_bits);
          _impl_.id_verified_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_adult = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_is_adult(&has_bits);
          _impl_.is_adult_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCGetPartnerAccountLink_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCGetPartnerAccountLink_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 pwid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_pwid(), target);
  }

  // optional uint32 nexonid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_nexonid(), target);
  }

  // optional int32 ageclass = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_ageclass(), target);
  }

  // optional bool id_verified = 4 [default = true];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_id_verified(), target);
  }

  // optional bool is_adult = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_is_adult(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCGetPartnerAccountLink_Response)
  return target;
}

size_t CMsgGCGetPartnerAccountLink_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCGetPartnerAccountLink_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint32 pwid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pwid());
    }

    // optional uint32 nexonid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nexonid());
    }

    // optional int32 ageclass = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ageclass());
    }

    // optional bool is_adult = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool id_verified = 4 [default = true];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCGetPartnerAccountLink_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCGetPartnerAccountLink_Response*>(
      &from));
}

void CMsgGCGetPartnerAccountLink_Response::MergeFrom(const CMsgGCGetPartnerAccountLink_Response& from) {
  CMsgGCGetPartnerAccountLink_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCGetPartnerAccountLink_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.pwid_ = from._impl_.pwid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.nexonid_ = from._impl_.nexonid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ageclass_ = from._impl_.ageclass_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.is_adult_ = from._impl_.is_adult_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.id_verified_ = from._impl_.id_verified_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCGetPartnerAccountLink_Response::CopyFrom(const CMsgGCGetPartnerAccountLink_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCGetPartnerAccountLink_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCGetPartnerAccountLink_Response::IsInitialized() const {
  return true;
}

void CMsgGCGetPartnerAccountLink_Response::InternalSwap(CMsgGCGetPartnerAccountLink_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCGetPartnerAccountLink_Response, _impl_.is_adult_)
      + sizeof(CMsgGCGetPartnerAccountLink_Response::_impl_.is_adult_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCGetPartnerAccountLink_Response, _impl_.pwid_)>(
          reinterpret_cast<char*>(&_impl_.pwid_),
          reinterpret_cast<char*>(&other->_impl_.pwid_));
  swap(_impl_.id_verified_, other->_impl_.id_verified_);
}

std::string CMsgGCGetPartnerAccountLink_Response::GetTypeName() const {
  return "CMsgGCGetPartnerAccountLink_Response";
}


// ===================================================================

class CMsgGCAddressMask::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCAddressMask>()._impl_._has_bits_);
  static void set_has_ipv4(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_maskbits(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgGCAddressMask::CMsgGCAddressMask(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCAddressMask)
}
CMsgGCAddressMask::CMsgGCAddressMask(const CMsgGCAddressMask& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCAddressMask* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ipv4_){}
    , decltype(_impl_.maskbits_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.ipv4_, &from._impl_.ipv4_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.maskbits_) -
    reinterpret_cast<char*>(&_impl_.ipv4_)) + sizeof(_impl_.maskbits_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCAddressMask)
}

inline void CMsgGCAddressMask::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ipv4_){0u}
    , decltype(_impl_.maskbits_){32u}
  };
}

CMsgGCAddressMask::~CMsgGCAddressMask() {
  // @@protoc_insertion_point(destructor:CMsgGCAddressMask)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCAddressMask::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCAddressMask::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCAddressMask::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCAddressMask)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.ipv4_ = 0u;
    _impl_.maskbits_ = 32u;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCAddressMask::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 ipv4 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_ipv4(&has_bits);
          _impl_.ipv4_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 maskbits = 2 [default = 32];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_maskbits(&has_bits);
          _impl_.maskbits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCAddressMask::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCAddressMask)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 ipv4 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_ipv4(), target);
  }

  // optional uint32 maskbits = 2 [default = 32];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_maskbits(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCAddressMask)
  return target;
}

size_t CMsgGCAddressMask::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCAddressMask)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional fixed32 ipv4 = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional uint32 maskbits = 2 [default = 32];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_maskbits());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCAddressMask::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCAddressMask*>(
      &from));
}

void CMsgGCAddressMask::MergeFrom(const CMsgGCAddressMask& from) {
  CMsgGCAddressMask* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCAddressMask)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ipv4_ = from._impl_.ipv4_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.maskbits_ = from._impl_.maskbits_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCAddressMask::CopyFrom(const CMsgGCAddressMask& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCAddressMask)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCAddressMask::IsInitialized() const {
  return true;
}

void CMsgGCAddressMask::InternalSwap(CMsgGCAddressMask* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.ipv4_, other->_impl_.ipv4_);
  swap(_impl_.maskbits_, other->_impl_.maskbits_);
}

std::string CMsgGCAddressMask::GetTypeName() const {
  return "CMsgGCAddressMask";
}


// ===================================================================

class CMsgGCAddressMaskGroup::_Internal {
 public:
};

CMsgGCAddressMaskGroup::CMsgGCAddressMaskGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCAddressMaskGroup)
}
CMsgGCAddressMaskGroup::CMsgGCAddressMaskGroup(const CMsgGCAddressMaskGroup& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCAddressMaskGroup* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.addrs_){from._impl_.addrs_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgGCAddressMaskGroup)
}

inline void CMsgGCAddressMaskGroup::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.addrs_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgGCAddressMaskGroup::~CMsgGCAddressMaskGroup() {
  // @@protoc_insertion_point(destructor:CMsgGCAddressMaskGroup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCAddressMaskGroup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.addrs_.~RepeatedPtrField();
}

void CMsgGCAddressMaskGroup::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCAddressMaskGroup::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCAddressMaskGroup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.addrs_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCAddressMaskGroup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgGCAddressMask addrs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_addrs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCAddressMaskGroup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCAddressMaskGroup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgGCAddressMask addrs = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_addrs_size()); i < n; i++) {
    const auto& repfield = this->_internal_addrs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCAddressMaskGroup)
  return target;
}

size_t CMsgGCAddressMaskGroup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCAddressMaskGroup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgGCAddressMask addrs = 1;
  total_size += 1UL * this->_internal_addrs_size();
  for (const auto& msg : this->_impl_.addrs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCAddressMaskGroup::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCAddressMaskGroup*>(
      &from));
}

void CMsgGCAddressMaskGroup::MergeFrom(const CMsgGCAddressMaskGroup& from) {
  CMsgGCAddressMaskGroup* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCAddressMaskGroup)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.addrs_.MergeFrom(from._impl_.addrs_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCAddressMaskGroup::CopyFrom(const CMsgGCAddressMaskGroup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCAddressMaskGroup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCAddressMaskGroup::IsInitialized() const {
  return true;
}

void CMsgGCAddressMaskGroup::InternalSwap(CMsgGCAddressMaskGroup* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.addrs_.InternalSwap(&other->_impl_.addrs_);
}

std::string CMsgGCAddressMaskGroup::GetTypeName() const {
  return "CMsgGCAddressMaskGroup";
}


// ===================================================================

class CMsgGCRoutingInfo_PolicyRule::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCRoutingInfo_PolicyRule>()._impl_._has_bits_);
  static void set_has_account_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_address_mask_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgGCRoutingInfo_TokenBucketConfiguration& token_bucket(const CMsgGCRoutingInfo_PolicyRule* msg);
  static void set_has_token_bucket(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgGCRoutingInfo_TokenBucketConfiguration&
CMsgGCRoutingInfo_PolicyRule::_Internal::token_bucket(const CMsgGCRoutingInfo_PolicyRule* msg) {
  return *msg->_impl_.token_bucket_;
}
CMsgGCRoutingInfo_PolicyRule::CMsgGCRoutingInfo_PolicyRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCRoutingInfo.PolicyRule)
}
CMsgGCRoutingInfo_PolicyRule::CMsgGCRoutingInfo_PolicyRule(const CMsgGCRoutingInfo_PolicyRule& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCRoutingInfo_PolicyRule* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_bucket_){nullptr}
    , decltype(_impl_.account_type_){}
    , decltype(_impl_.address_mask_group_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_token_bucket()) {
    _this->_impl_.token_bucket_ = new ::CMsgGCRoutingInfo_TokenBucketConfiguration(*from._impl_.token_bucket_);
  }
  ::memcpy(&_impl_.account_type_, &from._impl_.account_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.address_mask_group_id_) -
    reinterpret_cast<char*>(&_impl_.account_type_)) + sizeof(_impl_.address_mask_group_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCRoutingInfo.PolicyRule)
}

inline void CMsgGCRoutingInfo_PolicyRule::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_bucket_){nullptr}
    , decltype(_impl_.account_type_){0}
    , decltype(_impl_.address_mask_group_id_){0}
  };
}

CMsgGCRoutingInfo_PolicyRule::~CMsgGCRoutingInfo_PolicyRule() {
  // @@protoc_insertion_point(destructor:CMsgGCRoutingInfo.PolicyRule)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCRoutingInfo_PolicyRule::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.token_bucket_;
}

void CMsgGCRoutingInfo_PolicyRule::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCRoutingInfo_PolicyRule::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCRoutingInfo.PolicyRule)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.token_bucket_ != nullptr);
    _impl_.token_bucket_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.account_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.address_mask_group_id_) -
        reinterpret_cast<char*>(&_impl_.account_type_)) + sizeof(_impl_.address_mask_group_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCRoutingInfo_PolicyRule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 account_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_type(&has_bits);
          _impl_.account_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 address_mask_group_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_address_mask_group_id(&has_bits);
          _impl_.address_mask_group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgGCRoutingInfo.TokenBucketConfiguration token_bucket = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_token_bucket(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCRoutingInfo_PolicyRule::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCRoutingInfo.PolicyRule)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 account_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_account_type(), target);
  }

  // optional int32 address_mask_group_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_address_mask_group_id(), target);
  }

  // optional .CMsgGCRoutingInfo.TokenBucketConfiguration token_bucket = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::token_bucket(this),
        _Internal::token_bucket(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCRoutingInfo.PolicyRule)
  return target;
}

size_t CMsgGCRoutingInfo_PolicyRule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCRoutingInfo.PolicyRule)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgGCRoutingInfo.TokenBucketConfiguration token_bucket = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.token_bucket_);
    }

    // optional int32 account_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_account_type());
    }

    // optional int32 address_mask_group_id = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_address_mask_group_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCRoutingInfo_PolicyRule::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCRoutingInfo_PolicyRule*>(
      &from));
}

void CMsgGCRoutingInfo_PolicyRule::MergeFrom(const CMsgGCRoutingInfo_PolicyRule& from) {
  CMsgGCRoutingInfo_PolicyRule* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCRoutingInfo.PolicyRule)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_token_bucket()->::CMsgGCRoutingInfo_TokenBucketConfiguration::MergeFrom(
          from._internal_token_bucket());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.account_type_ = from._impl_.account_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.address_mask_group_id_ = from._impl_.address_mask_group_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCRoutingInfo_PolicyRule::CopyFrom(const CMsgGCRoutingInfo_PolicyRule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCRoutingInfo.PolicyRule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCRoutingInfo_PolicyRule::IsInitialized() const {
  return true;
}

void CMsgGCRoutingInfo_PolicyRule::InternalSwap(CMsgGCRoutingInfo_PolicyRule* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCRoutingInfo_PolicyRule, _impl_.address_mask_group_id_)
      + sizeof(CMsgGCRoutingInfo_PolicyRule::_impl_.address_mask_group_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCRoutingInfo_PolicyRule, _impl_.token_bucket_)>(
          reinterpret_cast<char*>(&_impl_.token_bucket_),
          reinterpret_cast<char*>(&other->_impl_.token_bucket_));
}

std::string CMsgGCRoutingInfo_PolicyRule::GetTypeName() const {
  return "CMsgGCRoutingInfo.PolicyRule";
}


// ===================================================================

class CMsgGCRoutingInfo_TokenBucketConfiguration::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCRoutingInfo_TokenBucketConfiguration>()._impl_._has_bits_);
  static void set_has_tokens_start(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tokens_grant(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_grant_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgGCRoutingInfo_TokenBucketConfiguration::CMsgGCRoutingInfo_TokenBucketConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCRoutingInfo.TokenBucketConfiguration)
}
CMsgGCRoutingInfo_TokenBucketConfiguration::CMsgGCRoutingInfo_TokenBucketConfiguration(const CMsgGCRoutingInfo_TokenBucketConfiguration& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCRoutingInfo_TokenBucketConfiguration* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tokens_start_){}
    , decltype(_impl_.tokens_grant_){}
    , decltype(_impl_.grant_seconds_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.tokens_start_, &from._impl_.tokens_start_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.grant_seconds_) -
    reinterpret_cast<char*>(&_impl_.tokens_start_)) + sizeof(_impl_.grant_seconds_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCRoutingInfo.TokenBucketConfiguration)
}

inline void CMsgGCRoutingInfo_TokenBucketConfiguration::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tokens_start_){0}
    , decltype(_impl_.tokens_grant_){0}
    , decltype(_impl_.grant_seconds_){0}
  };
}

CMsgGCRoutingInfo_TokenBucketConfiguration::~CMsgGCRoutingInfo_TokenBucketConfiguration() {
  // @@protoc_insertion_point(destructor:CMsgGCRoutingInfo.TokenBucketConfiguration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCRoutingInfo_TokenBucketConfiguration::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCRoutingInfo_TokenBucketConfiguration::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCRoutingInfo_TokenBucketConfiguration::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCRoutingInfo.TokenBucketConfiguration)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.tokens_start_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.grant_seconds_) -
        reinterpret_cast<char*>(&_impl_.tokens_start_)) + sizeof(_impl_.grant_seconds_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCRoutingInfo_TokenBucketConfiguration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 tokens_start = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_tokens_start(&has_bits);
          _impl_.tokens_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 tokens_grant = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_tokens_grant(&has_bits);
          _impl_.tokens_grant_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 grant_seconds = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_grant_seconds(&has_bits);
          _impl_.grant_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCRoutingInfo_TokenBucketConfiguration::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCRoutingInfo.TokenBucketConfiguration)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 tokens_start = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_tokens_start(), target);
  }

  // optional int32 tokens_grant = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_tokens_grant(), target);
  }

  // optional int32 grant_seconds = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_grant_seconds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCRoutingInfo.TokenBucketConfiguration)
  return target;
}

size_t CMsgGCRoutingInfo_TokenBucketConfiguration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCRoutingInfo.TokenBucketConfiguration)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int32 tokens_start = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tokens_start());
    }

    // optional int32 tokens_grant = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tokens_grant());
    }

    // optional int32 grant_seconds = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_grant_seconds());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCRoutingInfo_TokenBucketConfiguration::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCRoutingInfo_TokenBucketConfiguration*>(
      &from));
}

void CMsgGCRoutingInfo_TokenBucketConfiguration::MergeFrom(const CMsgGCRoutingInfo_TokenBucketConfiguration& from) {
  CMsgGCRoutingInfo_TokenBucketConfiguration* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCRoutingInfo.TokenBucketConfiguration)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.tokens_start_ = from._impl_.tokens_start_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.tokens_grant_ = from._impl_.tokens_grant_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.grant_seconds_ = from._impl_.grant_seconds_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCRoutingInfo_TokenBucketConfiguration::CopyFrom(const CMsgGCRoutingInfo_TokenBucketConfiguration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCRoutingInfo.TokenBucketConfiguration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCRoutingInfo_TokenBucketConfiguration::IsInitialized() const {
  return true;
}

void CMsgGCRoutingInfo_TokenBucketConfiguration::InternalSwap(CMsgGCRoutingInfo_TokenBucketConfiguration* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCRoutingInfo_TokenBucketConfiguration, _impl_.grant_seconds_)
      + sizeof(CMsgGCRoutingInfo_TokenBucketConfiguration::_impl_.grant_seconds_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCRoutingInfo_TokenBucketConfiguration, _impl_.tokens_start_)>(
          reinterpret_cast<char*>(&_impl_.tokens_start_),
          reinterpret_cast<char*>(&other->_impl_.tokens_start_));
}

std::string CMsgGCRoutingInfo_TokenBucketConfiguration::GetTypeName() const {
  return "CMsgGCRoutingInfo.TokenBucketConfiguration";
}


// ===================================================================

class CMsgGCRoutingInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCRoutingInfo>()._impl_._has_bits_);
  static void set_has_method(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_fallback(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_protobuf_field(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_webapi_param(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCRoutingInfo::CMsgGCRoutingInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCRoutingInfo)
}
CMsgGCRoutingInfo::CMsgGCRoutingInfo(const CMsgGCRoutingInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCRoutingInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dir_index_){from._impl_.dir_index_}
    , decltype(_impl_.policy_rules_){from._impl_.policy_rules_}
    , decltype(_impl_.webapi_param_){}
    , decltype(_impl_.method_){}
    , decltype(_impl_.protobuf_field_){}
    , decltype(_impl_.fallback_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.webapi_param_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.webapi_param_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_webapi_param()) {
    _this->_impl_.webapi_param_.Set(from._internal_webapi_param(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.method_, &from._impl_.method_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.fallback_) -
    reinterpret_cast<char*>(&_impl_.method_)) + sizeof(_impl_.fallback_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCRoutingInfo)
}

inline void CMsgGCRoutingInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dir_index_){arena}
    , decltype(_impl_.policy_rules_){arena}
    , decltype(_impl_.webapi_param_){}
    , decltype(_impl_.method_){0}
    , decltype(_impl_.protobuf_field_){0u}
    , decltype(_impl_.fallback_){1}
  };
  _impl_.webapi_param_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.webapi_param_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCRoutingInfo::~CMsgGCRoutingInfo() {
  // @@protoc_insertion_point(destructor:CMsgGCRoutingInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCRoutingInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dir_index_.~RepeatedField();
  _impl_.policy_rules_.~RepeatedPtrField();
  _impl_.webapi_param_.Destroy();
}

void CMsgGCRoutingInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCRoutingInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCRoutingInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dir_index_.Clear();
  _impl_.policy_rules_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.webapi_param_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.method_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.protobuf_field_) -
        reinterpret_cast<char*>(&_impl_.method_)) + sizeof(_impl_.protobuf_field_));
    _impl_.fallback_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCRoutingInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 dir_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_dir_index(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_dir_index(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgGCRoutingInfo.RoutingMethod method = 2 [default = RANDOM];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgGCRoutingInfo_RoutingMethod_IsValid(val))) {
            _internal_set_method(static_cast<::CMsgGCRoutingInfo_RoutingMethod>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgGCRoutingInfo.RoutingMethod fallback = 3 [default = DISCARD];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgGCRoutingInfo_RoutingMethod_IsValid(val))) {
            _internal_set_fallback(static_cast<::CMsgGCRoutingInfo_RoutingMethod>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 protobuf_field = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_protobuf_field(&has_bits);
          _impl_.protobuf_field_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string webapi_param = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_webapi_param();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgGCRoutingInfo.PolicyRule policy_rules = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_policy_rules(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCRoutingInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCRoutingInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 dir_index = 1;
  for (int i = 0, n = this->_internal_dir_index_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_dir_index(i), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgGCRoutingInfo.RoutingMethod method = 2 [default = RANDOM];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_method(), target);
  }

  // optional .CMsgGCRoutingInfo.RoutingMethod fallback = 3 [default = DISCARD];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_fallback(), target);
  }

  // optional uint32 protobuf_field = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_protobuf_field(), target);
  }

  // optional string webapi_param = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_webapi_param(), target);
  }

  // repeated .CMsgGCRoutingInfo.PolicyRule policy_rules = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_policy_rules_size()); i < n; i++) {
    const auto& repfield = this->_internal_policy_rules(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCRoutingInfo)
  return target;
}

size_t CMsgGCRoutingInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCRoutingInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 dir_index = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.dir_index_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_dir_index_size());
    total_size += data_size;
  }

  // repeated .CMsgGCRoutingInfo.PolicyRule policy_rules = 6;
  total_size += 1UL * this->_internal_policy_rules_size();
  for (const auto& msg : this->_impl_.policy_rules_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string webapi_param = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_webapi_param());
    }

    // optional .CMsgGCRoutingInfo.RoutingMethod method = 2 [default = RANDOM];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_method());
    }

    // optional uint32 protobuf_field = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_protobuf_field());
    }

    // optional .CMsgGCRoutingInfo.RoutingMethod fallback = 3 [default = DISCARD];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_fallback());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCRoutingInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCRoutingInfo*>(
      &from));
}

void CMsgGCRoutingInfo::MergeFrom(const CMsgGCRoutingInfo& from) {
  CMsgGCRoutingInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCRoutingInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.dir_index_.MergeFrom(from._impl_.dir_index_);
  _this->_impl_.policy_rules_.MergeFrom(from._impl_.policy_rules_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_webapi_param(from._internal_webapi_param());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.method_ = from._impl_.method_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.protobuf_field_ = from._impl_.protobuf_field_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.fallback_ = from._impl_.fallback_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCRoutingInfo::CopyFrom(const CMsgGCRoutingInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCRoutingInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCRoutingInfo::IsInitialized() const {
  return true;
}

void CMsgGCRoutingInfo::InternalSwap(CMsgGCRoutingInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.dir_index_.InternalSwap(&other->_impl_.dir_index_);
  _impl_.policy_rules_.InternalSwap(&other->_impl_.policy_rules_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.webapi_param_, lhs_arena,
      &other->_impl_.webapi_param_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCRoutingInfo, _impl_.protobuf_field_)
      + sizeof(CMsgGCRoutingInfo::_impl_.protobuf_field_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCRoutingInfo, _impl_.method_)>(
          reinterpret_cast<char*>(&_impl_.method_),
          reinterpret_cast<char*>(&other->_impl_.method_));
  swap(_impl_.fallback_, other->_impl_.fallback_);
}

std::string CMsgGCRoutingInfo::GetTypeName() const {
  return "CMsgGCRoutingInfo";
}


// ===================================================================

class CMsgGCMsgMasterSetWebAPIRouting_Entry::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCMsgMasterSetWebAPIRouting_Entry>()._impl_._has_bits_);
  static void set_has_interface_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_method_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgGCRoutingInfo& routing(const CMsgGCMsgMasterSetWebAPIRouting_Entry* msg);
  static void set_has_routing(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgGCRoutingInfo&
CMsgGCMsgMasterSetWebAPIRouting_Entry::_Internal::routing(const CMsgGCMsgMasterSetWebAPIRouting_Entry* msg) {
  return *msg->_impl_.routing_;
}
CMsgGCMsgMasterSetWebAPIRouting_Entry::CMsgGCMsgMasterSetWebAPIRouting_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCMsgMasterSetWebAPIRouting.Entry)
}
CMsgGCMsgMasterSetWebAPIRouting_Entry::CMsgGCMsgMasterSetWebAPIRouting_Entry(const CMsgGCMsgMasterSetWebAPIRouting_Entry& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCMsgMasterSetWebAPIRouting_Entry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.interface_name_){}
    , decltype(_impl_.method_name_){}
    , decltype(_impl_.routing_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.interface_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.interface_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_interface_name()) {
    _this->_impl_.interface_name_.Set(from._internal_interface_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.method_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.method_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_method_name()) {
    _this->_impl_.method_name_.Set(from._internal_method_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_routing()) {
    _this->_impl_.routing_ = new ::CMsgGCRoutingInfo(*from._impl_.routing_);
  }
  // @@protoc_insertion_point(copy_constructor:CMsgGCMsgMasterSetWebAPIRouting.Entry)
}

inline void CMsgGCMsgMasterSetWebAPIRouting_Entry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.interface_name_){}
    , decltype(_impl_.method_name_){}
    , decltype(_impl_.routing_){nullptr}
  };
  _impl_.interface_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.interface_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.method_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.method_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCMsgMasterSetWebAPIRouting_Entry::~CMsgGCMsgMasterSetWebAPIRouting_Entry() {
  // @@protoc_insertion_point(destructor:CMsgGCMsgMasterSetWebAPIRouting.Entry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCMsgMasterSetWebAPIRouting_Entry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.interface_name_.Destroy();
  _impl_.method_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.routing_;
}

void CMsgGCMsgMasterSetWebAPIRouting_Entry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCMsgMasterSetWebAPIRouting_Entry::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCMsgMasterSetWebAPIRouting.Entry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.interface_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.method_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.routing_ != nullptr);
      _impl_.routing_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCMsgMasterSetWebAPIRouting_Entry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string interface_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_interface_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string method_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_method_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgGCRoutingInfo routing = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_routing(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCMsgMasterSetWebAPIRouting_Entry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCMsgMasterSetWebAPIRouting.Entry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string interface_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_interface_name(), target);
  }

  // optional string method_name = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_method_name(), target);
  }

  // optional .CMsgGCRoutingInfo routing = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::routing(this),
        _Internal::routing(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCMsgMasterSetWebAPIRouting.Entry)
  return target;
}

size_t CMsgGCMsgMasterSetWebAPIRouting_Entry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCMsgMasterSetWebAPIRouting.Entry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string interface_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_interface_name());
    }

    // optional string method_name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_method_name());
    }

    // optional .CMsgGCRoutingInfo routing = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.routing_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCMsgMasterSetWebAPIRouting_Entry::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCMsgMasterSetWebAPIRouting_Entry*>(
      &from));
}

void CMsgGCMsgMasterSetWebAPIRouting_Entry::MergeFrom(const CMsgGCMsgMasterSetWebAPIRouting_Entry& from) {
  CMsgGCMsgMasterSetWebAPIRouting_Entry* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCMsgMasterSetWebAPIRouting.Entry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_interface_name(from._internal_interface_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_method_name(from._internal_method_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_routing()->::CMsgGCRoutingInfo::MergeFrom(
          from._internal_routing());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCMsgMasterSetWebAPIRouting_Entry::CopyFrom(const CMsgGCMsgMasterSetWebAPIRouting_Entry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCMsgMasterSetWebAPIRouting.Entry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCMsgMasterSetWebAPIRouting_Entry::IsInitialized() const {
  return true;
}

void CMsgGCMsgMasterSetWebAPIRouting_Entry::InternalSwap(CMsgGCMsgMasterSetWebAPIRouting_Entry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.interface_name_, lhs_arena,
      &other->_impl_.interface_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.method_name_, lhs_arena,
      &other->_impl_.method_name_, rhs_arena
  );
  swap(_impl_.routing_, other->_impl_.routing_);
}

std::string CMsgGCMsgMasterSetWebAPIRouting_Entry::GetTypeName() const {
  return "CMsgGCMsgMasterSetWebAPIRouting.Entry";
}


// ===================================================================

class CMsgGCMsgMasterSetWebAPIRouting::_Internal {
 public:
};

CMsgGCMsgMasterSetWebAPIRouting::CMsgGCMsgMasterSetWebAPIRouting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCMsgMasterSetWebAPIRouting)
}
CMsgGCMsgMasterSetWebAPIRouting::CMsgGCMsgMasterSetWebAPIRouting(const CMsgGCMsgMasterSetWebAPIRouting& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCMsgMasterSetWebAPIRouting* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.entries_){from._impl_.entries_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgGCMsgMasterSetWebAPIRouting)
}

inline void CMsgGCMsgMasterSetWebAPIRouting::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.entries_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgGCMsgMasterSetWebAPIRouting::~CMsgGCMsgMasterSetWebAPIRouting() {
  // @@protoc_insertion_point(destructor:CMsgGCMsgMasterSetWebAPIRouting)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCMsgMasterSetWebAPIRouting::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entries_.~RepeatedPtrField();
}

void CMsgGCMsgMasterSetWebAPIRouting::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCMsgMasterSetWebAPIRouting::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCMsgMasterSetWebAPIRouting)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.entries_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCMsgMasterSetWebAPIRouting::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgGCMsgMasterSetWebAPIRouting.Entry entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCMsgMasterSetWebAPIRouting::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCMsgMasterSetWebAPIRouting)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgGCMsgMasterSetWebAPIRouting.Entry entries = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCMsgMasterSetWebAPIRouting)
  return target;
}

size_t CMsgGCMsgMasterSetWebAPIRouting::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCMsgMasterSetWebAPIRouting)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgGCMsgMasterSetWebAPIRouting.Entry entries = 1;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->_impl_.entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCMsgMasterSetWebAPIRouting::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCMsgMasterSetWebAPIRouting*>(
      &from));
}

void CMsgGCMsgMasterSetWebAPIRouting::MergeFrom(const CMsgGCMsgMasterSetWebAPIRouting& from) {
  CMsgGCMsgMasterSetWebAPIRouting* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCMsgMasterSetWebAPIRouting)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.entries_.MergeFrom(from._impl_.entries_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCMsgMasterSetWebAPIRouting::CopyFrom(const CMsgGCMsgMasterSetWebAPIRouting& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCMsgMasterSetWebAPIRouting)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCMsgMasterSetWebAPIRouting::IsInitialized() const {
  return true;
}

void CMsgGCMsgMasterSetWebAPIRouting::InternalSwap(CMsgGCMsgMasterSetWebAPIRouting* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.entries_.InternalSwap(&other->_impl_.entries_);
}

std::string CMsgGCMsgMasterSetWebAPIRouting::GetTypeName() const {
  return "CMsgGCMsgMasterSetWebAPIRouting";
}


// ===================================================================

class CMsgGCMsgMasterSetClientMsgRouting_Entry::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCMsgMasterSetClientMsgRouting_Entry>()._impl_._has_bits_);
  static void set_has_msg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgGCRoutingInfo& routing(const CMsgGCMsgMasterSetClientMsgRouting_Entry* msg);
  static void set_has_routing(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgGCRoutingInfo&
CMsgGCMsgMasterSetClientMsgRouting_Entry::_Internal::routing(const CMsgGCMsgMasterSetClientMsgRouting_Entry* msg) {
  return *msg->_impl_.routing_;
}
CMsgGCMsgMasterSetClientMsgRouting_Entry::CMsgGCMsgMasterSetClientMsgRouting_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCMsgMasterSetClientMsgRouting.Entry)
}
CMsgGCMsgMasterSetClientMsgRouting_Entry::CMsgGCMsgMasterSetClientMsgRouting_Entry(const CMsgGCMsgMasterSetClientMsgRouting_Entry& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCMsgMasterSetClientMsgRouting_Entry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.routing_){nullptr}
    , decltype(_impl_.msg_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_routing()) {
    _this->_impl_.routing_ = new ::CMsgGCRoutingInfo(*from._impl_.routing_);
  }
  _this->_impl_.msg_type_ = from._impl_.msg_type_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCMsgMasterSetClientMsgRouting.Entry)
}

inline void CMsgGCMsgMasterSetClientMsgRouting_Entry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.routing_){nullptr}
    , decltype(_impl_.msg_type_){0u}
  };
}

CMsgGCMsgMasterSetClientMsgRouting_Entry::~CMsgGCMsgMasterSetClientMsgRouting_Entry() {
  // @@protoc_insertion_point(destructor:CMsgGCMsgMasterSetClientMsgRouting.Entry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCMsgMasterSetClientMsgRouting_Entry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.routing_;
}

void CMsgGCMsgMasterSetClientMsgRouting_Entry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCMsgMasterSetClientMsgRouting_Entry::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCMsgMasterSetClientMsgRouting.Entry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.routing_ != nullptr);
    _impl_.routing_->Clear();
  }
  _impl_.msg_type_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCMsgMasterSetClientMsgRouting_Entry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 msg_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_msg_type(&has_bits);
          _impl_.msg_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgGCRoutingInfo routing = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_routing(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCMsgMasterSetClientMsgRouting_Entry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCMsgMasterSetClientMsgRouting.Entry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 msg_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_msg_type(), target);
  }

  // optional .CMsgGCRoutingInfo routing = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::routing(this),
        _Internal::routing(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCMsgMasterSetClientMsgRouting.Entry)
  return target;
}

size_t CMsgGCMsgMasterSetClientMsgRouting_Entry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCMsgMasterSetClientMsgRouting.Entry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgGCRoutingInfo routing = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.routing_);
    }

    // optional uint32 msg_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msg_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCMsgMasterSetClientMsgRouting_Entry::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCMsgMasterSetClientMsgRouting_Entry*>(
      &from));
}

void CMsgGCMsgMasterSetClientMsgRouting_Entry::MergeFrom(const CMsgGCMsgMasterSetClientMsgRouting_Entry& from) {
  CMsgGCMsgMasterSetClientMsgRouting_Entry* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCMsgMasterSetClientMsgRouting.Entry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_routing()->::CMsgGCRoutingInfo::MergeFrom(
          from._internal_routing());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.msg_type_ = from._impl_.msg_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCMsgMasterSetClientMsgRouting_Entry::CopyFrom(const CMsgGCMsgMasterSetClientMsgRouting_Entry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCMsgMasterSetClientMsgRouting.Entry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCMsgMasterSetClientMsgRouting_Entry::IsInitialized() const {
  return true;
}

void CMsgGCMsgMasterSetClientMsgRouting_Entry::InternalSwap(CMsgGCMsgMasterSetClientMsgRouting_Entry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCMsgMasterSetClientMsgRouting_Entry, _impl_.msg_type_)
      + sizeof(CMsgGCMsgMasterSetClientMsgRouting_Entry::_impl_.msg_type_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCMsgMasterSetClientMsgRouting_Entry, _impl_.routing_)>(
          reinterpret_cast<char*>(&_impl_.routing_),
          reinterpret_cast<char*>(&other->_impl_.routing_));
}

std::string CMsgGCMsgMasterSetClientMsgRouting_Entry::GetTypeName() const {
  return "CMsgGCMsgMasterSetClientMsgRouting.Entry";
}


// ===================================================================

class CMsgGCMsgMasterSetClientMsgRouting::_Internal {
 public:
};

CMsgGCMsgMasterSetClientMsgRouting::CMsgGCMsgMasterSetClientMsgRouting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCMsgMasterSetClientMsgRouting)
}
CMsgGCMsgMasterSetClientMsgRouting::CMsgGCMsgMasterSetClientMsgRouting(const CMsgGCMsgMasterSetClientMsgRouting& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCMsgMasterSetClientMsgRouting* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.entries_){from._impl_.entries_}
    , decltype(_impl_.address_mask_groups_){from._impl_.address_mask_groups_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgGCMsgMasterSetClientMsgRouting)
}

inline void CMsgGCMsgMasterSetClientMsgRouting::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.entries_){arena}
    , decltype(_impl_.address_mask_groups_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgGCMsgMasterSetClientMsgRouting::~CMsgGCMsgMasterSetClientMsgRouting() {
  // @@protoc_insertion_point(destructor:CMsgGCMsgMasterSetClientMsgRouting)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCMsgMasterSetClientMsgRouting::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entries_.~RepeatedPtrField();
  _impl_.address_mask_groups_.~RepeatedPtrField();
}

void CMsgGCMsgMasterSetClientMsgRouting::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCMsgMasterSetClientMsgRouting::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCMsgMasterSetClientMsgRouting)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.entries_.Clear();
  _impl_.address_mask_groups_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCMsgMasterSetClientMsgRouting::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgGCMsgMasterSetClientMsgRouting.Entry entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgGCAddressMaskGroup address_mask_groups = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_address_mask_groups(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCMsgMasterSetClientMsgRouting::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCMsgMasterSetClientMsgRouting)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgGCMsgMasterSetClientMsgRouting.Entry entries = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgGCAddressMaskGroup address_mask_groups = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_address_mask_groups_size()); i < n; i++) {
    const auto& repfield = this->_internal_address_mask_groups(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCMsgMasterSetClientMsgRouting)
  return target;
}

size_t CMsgGCMsgMasterSetClientMsgRouting::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCMsgMasterSetClientMsgRouting)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgGCMsgMasterSetClientMsgRouting.Entry entries = 1;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->_impl_.entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgGCAddressMaskGroup address_mask_groups = 2;
  total_size += 1UL * this->_internal_address_mask_groups_size();
  for (const auto& msg : this->_impl_.address_mask_groups_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCMsgMasterSetClientMsgRouting::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCMsgMasterSetClientMsgRouting*>(
      &from));
}

void CMsgGCMsgMasterSetClientMsgRouting::MergeFrom(const CMsgGCMsgMasterSetClientMsgRouting& from) {
  CMsgGCMsgMasterSetClientMsgRouting* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCMsgMasterSetClientMsgRouting)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.entries_.MergeFrom(from._impl_.entries_);
  _this->_impl_.address_mask_groups_.MergeFrom(from._impl_.address_mask_groups_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCMsgMasterSetClientMsgRouting::CopyFrom(const CMsgGCMsgMasterSetClientMsgRouting& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCMsgMasterSetClientMsgRouting)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCMsgMasterSetClientMsgRouting::IsInitialized() const {
  return true;
}

void CMsgGCMsgMasterSetClientMsgRouting::InternalSwap(CMsgGCMsgMasterSetClientMsgRouting* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.entries_.InternalSwap(&other->_impl_.entries_);
  _impl_.address_mask_groups_.InternalSwap(&other->_impl_.address_mask_groups_);
}

std::string CMsgGCMsgMasterSetClientMsgRouting::GetTypeName() const {
  return "CMsgGCMsgMasterSetClientMsgRouting";
}


// ===================================================================

class CMsgGCMsgMasterSetWebAPIRouting_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCMsgMasterSetWebAPIRouting_Response>()._impl_._has_bits_);
  static void set_has_eresult(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCMsgMasterSetWebAPIRouting_Response::CMsgGCMsgMasterSetWebAPIRouting_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCMsgMasterSetWebAPIRouting_Response)
}
CMsgGCMsgMasterSetWebAPIRouting_Response::CMsgGCMsgMasterSetWebAPIRouting_Response(const CMsgGCMsgMasterSetWebAPIRouting_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCMsgMasterSetWebAPIRouting_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.eresult_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.eresult_ = from._impl_.eresult_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCMsgMasterSetWebAPIRouting_Response)
}

inline void CMsgGCMsgMasterSetWebAPIRouting_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.eresult_){2}
  };
}

CMsgGCMsgMasterSetWebAPIRouting_Response::~CMsgGCMsgMasterSetWebAPIRouting_Response() {
  // @@protoc_insertion_point(destructor:CMsgGCMsgMasterSetWebAPIRouting_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCMsgMasterSetWebAPIRouting_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCMsgMasterSetWebAPIRouting_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCMsgMasterSetWebAPIRouting_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCMsgMasterSetWebAPIRouting_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.eresult_ = 2;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCMsgMasterSetWebAPIRouting_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 eresult = 1 [default = 2];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_eresult(&has_bits);
          _impl_.eresult_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCMsgMasterSetWebAPIRouting_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCMsgMasterSetWebAPIRouting_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 eresult = 1 [default = 2];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_eresult(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCMsgMasterSetWebAPIRouting_Response)
  return target;
}

size_t CMsgGCMsgMasterSetWebAPIRouting_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCMsgMasterSetWebAPIRouting_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 eresult = 1 [default = 2];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_eresult());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCMsgMasterSetWebAPIRouting_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCMsgMasterSetWebAPIRouting_Response*>(
      &from));
}

void CMsgGCMsgMasterSetWebAPIRouting_Response::MergeFrom(const CMsgGCMsgMasterSetWebAPIRouting_Response& from) {
  CMsgGCMsgMasterSetWebAPIRouting_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCMsgMasterSetWebAPIRouting_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_eresult()) {
    _this->_internal_set_eresult(from._internal_eresult());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCMsgMasterSetWebAPIRouting_Response::CopyFrom(const CMsgGCMsgMasterSetWebAPIRouting_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCMsgMasterSetWebAPIRouting_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCMsgMasterSetWebAPIRouting_Response::IsInitialized() const {
  return true;
}

void CMsgGCMsgMasterSetWebAPIRouting_Response::InternalSwap(CMsgGCMsgMasterSetWebAPIRouting_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.eresult_, other->_impl_.eresult_);
}

std::string CMsgGCMsgMasterSetWebAPIRouting_Response::GetTypeName() const {
  return "CMsgGCMsgMasterSetWebAPIRouting_Response";
}


// ===================================================================

class CMsgGCMsgMasterSetClientMsgRouting_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCMsgMasterSetClientMsgRouting_Response>()._impl_._has_bits_);
  static void set_has_eresult(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCMsgMasterSetClientMsgRouting_Response::CMsgGCMsgMasterSetClientMsgRouting_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCMsgMasterSetClientMsgRouting_Response)
}
CMsgGCMsgMasterSetClientMsgRouting_Response::CMsgGCMsgMasterSetClientMsgRouting_Response(const CMsgGCMsgMasterSetClientMsgRouting_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCMsgMasterSetClientMsgRouting_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.eresult_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.eresult_ = from._impl_.eresult_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCMsgMasterSetClientMsgRouting_Response)
}

inline void CMsgGCMsgMasterSetClientMsgRouting_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.eresult_){2}
  };
}

CMsgGCMsgMasterSetClientMsgRouting_Response::~CMsgGCMsgMasterSetClientMsgRouting_Response() {
  // @@protoc_insertion_point(destructor:CMsgGCMsgMasterSetClientMsgRouting_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCMsgMasterSetClientMsgRouting_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCMsgMasterSetClientMsgRouting_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCMsgMasterSetClientMsgRouting_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCMsgMasterSetClientMsgRouting_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.eresult_ = 2;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCMsgMasterSetClientMsgRouting_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 eresult = 1 [default = 2];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_eresult(&has_bits);
          _impl_.eresult_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCMsgMasterSetClientMsgRouting_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCMsgMasterSetClientMsgRouting_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 eresult = 1 [default = 2];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_eresult(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCMsgMasterSetClientMsgRouting_Response)
  return target;
}

size_t CMsgGCMsgMasterSetClientMsgRouting_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCMsgMasterSetClientMsgRouting_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 eresult = 1 [default = 2];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_eresult());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCMsgMasterSetClientMsgRouting_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCMsgMasterSetClientMsgRouting_Response*>(
      &from));
}

void CMsgGCMsgMasterSetClientMsgRouting_Response::MergeFrom(const CMsgGCMsgMasterSetClientMsgRouting_Response& from) {
  CMsgGCMsgMasterSetClientMsgRouting_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCMsgMasterSetClientMsgRouting_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_eresult()) {
    _this->_internal_set_eresult(from._internal_eresult());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCMsgMasterSetClientMsgRouting_Response::CopyFrom(const CMsgGCMsgMasterSetClientMsgRouting_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCMsgMasterSetClientMsgRouting_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCMsgMasterSetClientMsgRouting_Response::IsInitialized() const {
  return true;
}

void CMsgGCMsgMasterSetClientMsgRouting_Response::InternalSwap(CMsgGCMsgMasterSetClientMsgRouting_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.eresult_, other->_impl_.eresult_);
}

std::string CMsgGCMsgMasterSetClientMsgRouting_Response::GetTypeName() const {
  return "CMsgGCMsgMasterSetClientMsgRouting_Response";
}


// ===================================================================

class CMsgGCMsgSetOptions_MessageRange::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCMsgSetOptions_MessageRange>()._impl_._has_bits_);
  static void set_has_low(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_high(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CMsgGCMsgSetOptions_MessageRange::CMsgGCMsgSetOptions_MessageRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCMsgSetOptions.MessageRange)
}
CMsgGCMsgSetOptions_MessageRange::CMsgGCMsgSetOptions_MessageRange(const CMsgGCMsgSetOptions_MessageRange& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCMsgSetOptions_MessageRange* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.low_){}
    , decltype(_impl_.high_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.low_, &from._impl_.low_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.high_) -
    reinterpret_cast<char*>(&_impl_.low_)) + sizeof(_impl_.high_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCMsgSetOptions.MessageRange)
}

inline void CMsgGCMsgSetOptions_MessageRange::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.low_){0u}
    , decltype(_impl_.high_){0u}
  };
}

CMsgGCMsgSetOptions_MessageRange::~CMsgGCMsgSetOptions_MessageRange() {
  // @@protoc_insertion_point(destructor:CMsgGCMsgSetOptions.MessageRange)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCMsgSetOptions_MessageRange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCMsgSetOptions_MessageRange::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCMsgSetOptions_MessageRange::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCMsgSetOptions.MessageRange)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.low_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.high_) -
        reinterpret_cast<char*>(&_impl_.low_)) + sizeof(_impl_.high_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCMsgSetOptions_MessageRange::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 low = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_low(&has_bits);
          _impl_.low_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 high = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_high(&has_bits);
          _impl_.high_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCMsgSetOptions_MessageRange::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCMsgSetOptions.MessageRange)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 low = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_low(), target);
  }

  // required uint32 high = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_high(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCMsgSetOptions.MessageRange)
  return target;
}

size_t CMsgGCMsgSetOptions_MessageRange::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:CMsgGCMsgSetOptions.MessageRange)
  size_t total_size = 0;

  if (_internal_has_low()) {
    // required uint32 low = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_low());
  }

  if (_internal_has_high()) {
    // required uint32 high = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_high());
  }

  return total_size;
}
size_t CMsgGCMsgSetOptions_MessageRange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCMsgSetOptions.MessageRange)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 low = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_low());

    // required uint32 high = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_high());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCMsgSetOptions_MessageRange::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCMsgSetOptions_MessageRange*>(
      &from));
}

void CMsgGCMsgSetOptions_MessageRange::MergeFrom(const CMsgGCMsgSetOptions_MessageRange& from) {
  CMsgGCMsgSetOptions_MessageRange* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCMsgSetOptions.MessageRange)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.low_ = from._impl_.low_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.high_ = from._impl_.high_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCMsgSetOptions_MessageRange::CopyFrom(const CMsgGCMsgSetOptions_MessageRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCMsgSetOptions.MessageRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCMsgSetOptions_MessageRange::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void CMsgGCMsgSetOptions_MessageRange::InternalSwap(CMsgGCMsgSetOptions_MessageRange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCMsgSetOptions_MessageRange, _impl_.high_)
      + sizeof(CMsgGCMsgSetOptions_MessageRange::_impl_.high_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCMsgSetOptions_MessageRange, _impl_.low_)>(
          reinterpret_cast<char*>(&_impl_.low_),
          reinterpret_cast<char*>(&other->_impl_.low_));
}

std::string CMsgGCMsgSetOptions_MessageRange::GetTypeName() const {
  return "CMsgGCMsgSetOptions.MessageRange";
}


// ===================================================================

class CMsgGCMsgSetOptions::_Internal {
 public:
};

CMsgGCMsgSetOptions::CMsgGCMsgSetOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCMsgSetOptions)
}
CMsgGCMsgSetOptions::CMsgGCMsgSetOptions(const CMsgGCMsgSetOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCMsgSetOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.options_){from._impl_.options_}
    , decltype(_impl_.client_msg_ranges_){from._impl_.client_msg_ranges_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgGCMsgSetOptions)
}

inline void CMsgGCMsgSetOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.options_){arena}
    , decltype(_impl_.client_msg_ranges_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgGCMsgSetOptions::~CMsgGCMsgSetOptions() {
  // @@protoc_insertion_point(destructor:CMsgGCMsgSetOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCMsgSetOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.options_.~RepeatedField();
  _impl_.client_msg_ranges_.~RepeatedPtrField();
}

void CMsgGCMsgSetOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCMsgSetOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCMsgSetOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.options_.Clear();
  _impl_.client_msg_ranges_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCMsgSetOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgGCMsgSetOptions.Option options = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::CMsgGCMsgSetOptions_Option_IsValid(val))) {
              _internal_add_options(static_cast<::CMsgGCMsgSetOptions_Option>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_options(), ptr, ctx, ::CMsgGCMsgSetOptions_Option_IsValid, &_internal_metadata_, 1);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgGCMsgSetOptions.MessageRange client_msg_ranges = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_client_msg_ranges(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCMsgSetOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCMsgSetOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgGCMsgSetOptions.Option options = 1;
  for (int i = 0, n = this->_internal_options_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_options(i), target);
  }

  // repeated .CMsgGCMsgSetOptions.MessageRange client_msg_ranges = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_client_msg_ranges_size()); i < n; i++) {
    const auto& repfield = this->_internal_client_msg_ranges(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCMsgSetOptions)
  return target;
}

size_t CMsgGCMsgSetOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCMsgSetOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgGCMsgSetOptions.Option options = 1;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_options_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_options(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .CMsgGCMsgSetOptions.MessageRange client_msg_ranges = 2;
  total_size += 1UL * this->_internal_client_msg_ranges_size();
  for (const auto& msg : this->_impl_.client_msg_ranges_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCMsgSetOptions::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCMsgSetOptions*>(
      &from));
}

void CMsgGCMsgSetOptions::MergeFrom(const CMsgGCMsgSetOptions& from) {
  CMsgGCMsgSetOptions* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCMsgSetOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.options_.MergeFrom(from._impl_.options_);
  _this->_impl_.client_msg_ranges_.MergeFrom(from._impl_.client_msg_ranges_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCMsgSetOptions::CopyFrom(const CMsgGCMsgSetOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCMsgSetOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCMsgSetOptions::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.client_msg_ranges_))
    return false;
  return true;
}

void CMsgGCMsgSetOptions::InternalSwap(CMsgGCMsgSetOptions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.options_.InternalSwap(&other->_impl_.options_);
  _impl_.client_msg_ranges_.InternalSwap(&other->_impl_.client_msg_ranges_);
}

std::string CMsgGCMsgSetOptions::GetTypeName() const {
  return "CMsgGCMsgSetOptions";
}


// ===================================================================

class CMsgGCHUpdateSession_ExtraField::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCHUpdateSession_ExtraField>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgGCHUpdateSession_ExtraField::CMsgGCHUpdateSession_ExtraField(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCHUpdateSession.ExtraField)
}
CMsgGCHUpdateSession_ExtraField::CMsgGCHUpdateSession_ExtraField(const CMsgGCHUpdateSession_ExtraField& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCHUpdateSession_ExtraField* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgGCHUpdateSession.ExtraField)
}

inline void CMsgGCHUpdateSession_ExtraField::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCHUpdateSession_ExtraField::~CMsgGCHUpdateSession_ExtraField() {
  // @@protoc_insertion_point(destructor:CMsgGCHUpdateSession.ExtraField)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCHUpdateSession_ExtraField::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.value_.Destroy();
}

void CMsgGCHUpdateSession_ExtraField::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCHUpdateSession_ExtraField::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCHUpdateSession.ExtraField)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCHUpdateSession_ExtraField::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCHUpdateSession_ExtraField::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCHUpdateSession.ExtraField)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCHUpdateSession.ExtraField)
  return target;
}

size_t CMsgGCHUpdateSession_ExtraField::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCHUpdateSession.ExtraField)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCHUpdateSession_ExtraField::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCHUpdateSession_ExtraField*>(
      &from));
}

void CMsgGCHUpdateSession_ExtraField::MergeFrom(const CMsgGCHUpdateSession_ExtraField& from) {
  CMsgGCHUpdateSession_ExtraField* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCHUpdateSession.ExtraField)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCHUpdateSession_ExtraField::CopyFrom(const CMsgGCHUpdateSession_ExtraField& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCHUpdateSession.ExtraField)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCHUpdateSession_ExtraField::IsInitialized() const {
  return true;
}

void CMsgGCHUpdateSession_ExtraField::InternalSwap(CMsgGCHUpdateSession_ExtraField* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

std::string CMsgGCHUpdateSession_ExtraField::GetTypeName() const {
  return "CMsgGCHUpdateSession.ExtraField";
}


// ===================================================================

class CMsgGCHUpdateSession::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCHUpdateSession>()._impl_._has_bits_);
  static void set_has_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_app_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_online(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_server_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_server_addr(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_server_port(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_os_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_client_addr(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_owner_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_cm_session_sysid(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_cm_session_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

CMsgGCHUpdateSession::CMsgGCHUpdateSession(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCHUpdateSession)
}
CMsgGCHUpdateSession::CMsgGCHUpdateSession(const CMsgGCHUpdateSession& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCHUpdateSession* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.extra_fields_){from._impl_.extra_fields_}
    , decltype(_impl_.depot_ids_){from._impl_.depot_ids_}
    , decltype(_impl_.steam_id_){}
    , decltype(_impl_.app_id_){}
    , decltype(_impl_.online_){}
    , decltype(_impl_.server_steam_id_){}
    , decltype(_impl_.server_addr_){}
    , decltype(_impl_.server_port_){}
    , decltype(_impl_.os_type_){}
    , decltype(_impl_.client_addr_){}
    , decltype(_impl_.owner_id_){}
    , decltype(_impl_.cm_session_sysid_){}
    , decltype(_impl_.cm_session_identifier_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.steam_id_, &from._impl_.steam_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cm_session_identifier_) -
    reinterpret_cast<char*>(&_impl_.steam_id_)) + sizeof(_impl_.cm_session_identifier_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCHUpdateSession)
}

inline void CMsgGCHUpdateSession::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.extra_fields_){arena}
    , decltype(_impl_.depot_ids_){arena}
    , decltype(_impl_.steam_id_){uint64_t{0u}}
    , decltype(_impl_.app_id_){0u}
    , decltype(_impl_.online_){false}
    , decltype(_impl_.server_steam_id_){uint64_t{0u}}
    , decltype(_impl_.server_addr_){0u}
    , decltype(_impl_.server_port_){0u}
    , decltype(_impl_.os_type_){0u}
    , decltype(_impl_.client_addr_){0u}
    , decltype(_impl_.owner_id_){uint64_t{0u}}
    , decltype(_impl_.cm_session_sysid_){0u}
    , decltype(_impl_.cm_session_identifier_){0u}
  };
}

CMsgGCHUpdateSession::~CMsgGCHUpdateSession() {
  // @@protoc_insertion_point(destructor:CMsgGCHUpdateSession)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCHUpdateSession::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.extra_fields_.~RepeatedPtrField();
  _impl_.depot_ids_.~RepeatedField();
}

void CMsgGCHUpdateSession::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCHUpdateSession::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCHUpdateSession)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extra_fields_.Clear();
  _impl_.depot_ids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.steam_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.client_addr_) -
        reinterpret_cast<char*>(&_impl_.steam_id_)) + sizeof(_impl_.client_addr_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.owner_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.cm_session_identifier_) -
        reinterpret_cast<char*>(&_impl_.owner_id_)) + sizeof(_impl_.cm_session_identifier_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCHUpdateSession::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steam_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steam_id(&has_bits);
          _impl_.steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 app_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_app_id(&has_bits);
          _impl_.app_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool online = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_online(&has_bits);
          _impl_.online_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 server_steam_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_server_steam_id(&has_bits);
          _impl_.server_steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 server_addr = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_server_addr(&has_bits);
          _impl_.server_addr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 server_port = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_server_port(&has_bits);
          _impl_.server_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 os_type = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_os_type(&has_bits);
          _impl_.os_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_addr = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_client_addr(&has_bits);
          _impl_.client_addr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgGCHUpdateSession.ExtraField extra_fields = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_extra_fields(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 owner_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has_owner_id(&has_bits);
          _impl_.owner_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cm_session_sysid = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_cm_session_sysid(&has_bits);
          _impl_.cm_session_sysid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cm_session_identifier = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_cm_session_identifier(&has_bits);
          _impl_.cm_session_identifier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 depot_ids = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_depot_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<104>(ptr));
        } else if (static_cast<uint8_t>(tag) == 106) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_depot_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCHUpdateSession::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCHUpdateSession)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steam_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steam_id(), target);
  }

  // optional uint32 app_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_app_id(), target);
  }

  // optional bool online = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_online(), target);
  }

  // optional fixed64 server_steam_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(4, this->_internal_server_steam_id(), target);
  }

  // optional uint32 server_addr = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_server_addr(), target);
  }

  // optional uint32 server_port = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_server_port(), target);
  }

  // optional uint32 os_type = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_os_type(), target);
  }

  // optional uint32 client_addr = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_client_addr(), target);
  }

  // repeated .CMsgGCHUpdateSession.ExtraField extra_fields = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_extra_fields_size()); i < n; i++) {
    const auto& repfield = this->_internal_extra_fields(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional fixed64 owner_id = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(10, this->_internal_owner_id(), target);
  }

  // optional uint32 cm_session_sysid = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_cm_session_sysid(), target);
  }

  // optional uint32 cm_session_identifier = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_cm_session_identifier(), target);
  }

  // repeated uint32 depot_ids = 13;
  for (int i = 0, n = this->_internal_depot_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_depot_ids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCHUpdateSession)
  return target;
}

size_t CMsgGCHUpdateSession::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCHUpdateSession)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgGCHUpdateSession.ExtraField extra_fields = 9;
  total_size += 1UL * this->_internal_extra_fields_size();
  for (const auto& msg : this->_impl_.extra_fields_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 depot_ids = 13;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.depot_ids_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_depot_ids_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional fixed64 steam_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional uint32 app_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_app_id());
    }

    // optional bool online = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional fixed64 server_steam_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional uint32 server_addr = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_server_addr());
    }

    // optional uint32 server_port = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_server_port());
    }

    // optional uint32 os_type = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_os_type());
    }

    // optional uint32 client_addr = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_addr());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional fixed64 owner_id = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional uint32 cm_session_sysid = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cm_session_sysid());
    }

    // optional uint32 cm_session_identifier = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cm_session_identifier());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCHUpdateSession::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCHUpdateSession*>(
      &from));
}

void CMsgGCHUpdateSession::MergeFrom(const CMsgGCHUpdateSession& from) {
  CMsgGCHUpdateSession* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCHUpdateSession)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.extra_fields_.MergeFrom(from._impl_.extra_fields_);
  _this->_impl_.depot_ids_.MergeFrom(from._impl_.depot_ids_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.steam_id_ = from._impl_.steam_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.app_id_ = from._impl_.app_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.online_ = from._impl_.online_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.server_steam_id_ = from._impl_.server_steam_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.server_addr_ = from._impl_.server_addr_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.server_port_ = from._impl_.server_port_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.os_type_ = from._impl_.os_type_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.client_addr_ = from._impl_.client_addr_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.owner_id_ = from._impl_.owner_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.cm_session_sysid_ = from._impl_.cm_session_sysid_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.cm_session_identifier_ = from._impl_.cm_session_identifier_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCHUpdateSession::CopyFrom(const CMsgGCHUpdateSession& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCHUpdateSession)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCHUpdateSession::IsInitialized() const {
  return true;
}

void CMsgGCHUpdateSession::InternalSwap(CMsgGCHUpdateSession* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.extra_fields_.InternalSwap(&other->_impl_.extra_fields_);
  _impl_.depot_ids_.InternalSwap(&other->_impl_.depot_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCHUpdateSession, _impl_.cm_session_identifier_)
      + sizeof(CMsgGCHUpdateSession::_impl_.cm_session_identifier_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCHUpdateSession, _impl_.steam_id_)>(
          reinterpret_cast<char*>(&_impl_.steam_id_),
          reinterpret_cast<char*>(&other->_impl_.steam_id_));
}

std::string CMsgGCHUpdateSession::GetTypeName() const {
  return "CMsgGCHUpdateSession";
}


// ===================================================================

class CMsgNotificationOfSuspiciousActivity_MultipleGameInstances::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgNotificationOfSuspiciousActivity_MultipleGameInstances>()._impl_._has_bits_);
  static void set_has_app_instance_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgNotificationOfSuspiciousActivity_MultipleGameInstances::CMsgNotificationOfSuspiciousActivity_MultipleGameInstances(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgNotificationOfSuspiciousActivity.MultipleGameInstances)
}
CMsgNotificationOfSuspiciousActivity_MultipleGameInstances::CMsgNotificationOfSuspiciousActivity_MultipleGameInstances(const CMsgNotificationOfSuspiciousActivity_MultipleGameInstances& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgNotificationOfSuspiciousActivity_MultipleGameInstances* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.other_steamids_){from._impl_.other_steamids_}
    , decltype(_impl_.app_instance_count_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.app_instance_count_ = from._impl_.app_instance_count_;
  // @@protoc_insertion_point(copy_constructor:CMsgNotificationOfSuspiciousActivity.MultipleGameInstances)
}

inline void CMsgNotificationOfSuspiciousActivity_MultipleGameInstances::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.other_steamids_){arena}
    , decltype(_impl_.app_instance_count_){0u}
  };
}

CMsgNotificationOfSuspiciousActivity_MultipleGameInstances::~CMsgNotificationOfSuspiciousActivity_MultipleGameInstances() {
  // @@protoc_insertion_point(destructor:CMsgNotificationOfSuspiciousActivity.MultipleGameInstances)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgNotificationOfSuspiciousActivity_MultipleGameInstances::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.other_steamids_.~RepeatedField();
}

void CMsgNotificationOfSuspiciousActivity_MultipleGameInstances::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgNotificationOfSuspiciousActivity_MultipleGameInstances::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgNotificationOfSuspiciousActivity.MultipleGameInstances)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.other_steamids_.Clear();
  _impl_.app_instance_count_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgNotificationOfSuspiciousActivity_MultipleGameInstances::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 app_instance_count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_app_instance_count(&has_bits);
          _impl_.app_instance_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated fixed64 other_steamids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_other_steamids(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr));
            ptr += sizeof(uint64_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<17>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed64Parser(_internal_mutable_other_steamids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgNotificationOfSuspiciousActivity_MultipleGameInstances::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgNotificationOfSuspiciousActivity.MultipleGameInstances)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 app_instance_count = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_app_instance_count(), target);
  }

  // repeated fixed64 other_steamids = 2;
  for (int i = 0, n = this->_internal_other_steamids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_other_steamids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgNotificationOfSuspiciousActivity.MultipleGameInstances)
  return target;
}

size_t CMsgNotificationOfSuspiciousActivity_MultipleGameInstances::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgNotificationOfSuspiciousActivity.MultipleGameInstances)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed64 other_steamids = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_other_steamids_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_other_steamids_size());
    total_size += data_size;
  }

  // optional uint32 app_instance_count = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_app_instance_count());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgNotificationOfSuspiciousActivity_MultipleGameInstances::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgNotificationOfSuspiciousActivity_MultipleGameInstances*>(
      &from));
}

void CMsgNotificationOfSuspiciousActivity_MultipleGameInstances::MergeFrom(const CMsgNotificationOfSuspiciousActivity_MultipleGameInstances& from) {
  CMsgNotificationOfSuspiciousActivity_MultipleGameInstances* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgNotificationOfSuspiciousActivity.MultipleGameInstances)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.other_steamids_.MergeFrom(from._impl_.other_steamids_);
  if (from._internal_has_app_instance_count()) {
    _this->_internal_set_app_instance_count(from._internal_app_instance_count());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgNotificationOfSuspiciousActivity_MultipleGameInstances::CopyFrom(const CMsgNotificationOfSuspiciousActivity_MultipleGameInstances& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgNotificationOfSuspiciousActivity.MultipleGameInstances)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgNotificationOfSuspiciousActivity_MultipleGameInstances::IsInitialized() const {
  return true;
}

void CMsgNotificationOfSuspiciousActivity_MultipleGameInstances::InternalSwap(CMsgNotificationOfSuspiciousActivity_MultipleGameInstances* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.other_steamids_.InternalSwap(&other->_impl_.other_steamids_);
  swap(_impl_.app_instance_count_, other->_impl_.app_instance_count_);
}

std::string CMsgNotificationOfSuspiciousActivity_MultipleGameInstances::GetTypeName() const {
  return "CMsgNotificationOfSuspiciousActivity.MultipleGameInstances";
}


// ===================================================================

class CMsgNotificationOfSuspiciousActivity::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgNotificationOfSuspiciousActivity>()._impl_._has_bits_);
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgNotificationOfSuspiciousActivity_MultipleGameInstances& multiple_instances(const CMsgNotificationOfSuspiciousActivity* msg);
  static void set_has_multiple_instances(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgNotificationOfSuspiciousActivity_MultipleGameInstances&
CMsgNotificationOfSuspiciousActivity::_Internal::multiple_instances(const CMsgNotificationOfSuspiciousActivity* msg) {
  return *msg->_impl_.multiple_instances_;
}
CMsgNotificationOfSuspiciousActivity::CMsgNotificationOfSuspiciousActivity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgNotificationOfSuspiciousActivity)
}
CMsgNotificationOfSuspiciousActivity::CMsgNotificationOfSuspiciousActivity(const CMsgNotificationOfSuspiciousActivity& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgNotificationOfSuspiciousActivity* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.multiple_instances_){nullptr}
    , decltype(_impl_.steamid_){}
    , decltype(_impl_.appid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_multiple_instances()) {
    _this->_impl_.multiple_instances_ = new ::CMsgNotificationOfSuspiciousActivity_MultipleGameInstances(*from._impl_.multiple_instances_);
  }
  ::memcpy(&_impl_.steamid_, &from._impl_.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.appid_) -
    reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.appid_));
  // @@protoc_insertion_point(copy_constructor:CMsgNotificationOfSuspiciousActivity)
}

inline void CMsgNotificationOfSuspiciousActivity::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.multiple_instances_){nullptr}
    , decltype(_impl_.steamid_){uint64_t{0u}}
    , decltype(_impl_.appid_){0u}
  };
}

CMsgNotificationOfSuspiciousActivity::~CMsgNotificationOfSuspiciousActivity() {
  // @@protoc_insertion_point(destructor:CMsgNotificationOfSuspiciousActivity)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgNotificationOfSuspiciousActivity::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.multiple_instances_;
}

void CMsgNotificationOfSuspiciousActivity::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgNotificationOfSuspiciousActivity::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgNotificationOfSuspiciousActivity)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.multiple_instances_ != nullptr);
    _impl_.multiple_instances_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.appid_) -
        reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.appid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgNotificationOfSuspiciousActivity::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steamid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steamid(&has_bits);
          _impl_.steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 appid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_appid(&has_bits);
          _impl_.appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgNotificationOfSuspiciousActivity.MultipleGameInstances multiple_instances = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_multiple_instances(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgNotificationOfSuspiciousActivity::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgNotificationOfSuspiciousActivity)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steamid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steamid(), target);
  }

  // optional uint32 appid = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_appid(), target);
  }

  // optional .CMsgNotificationOfSuspiciousActivity.MultipleGameInstances multiple_instances = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::multiple_instances(this),
        _Internal::multiple_instances(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgNotificationOfSuspiciousActivity)
  return target;
}

size_t CMsgNotificationOfSuspiciousActivity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgNotificationOfSuspiciousActivity)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgNotificationOfSuspiciousActivity.MultipleGameInstances multiple_instances = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.multiple_instances_);
    }

    // optional fixed64 steamid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 appid = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgNotificationOfSuspiciousActivity::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgNotificationOfSuspiciousActivity*>(
      &from));
}

void CMsgNotificationOfSuspiciousActivity::MergeFrom(const CMsgNotificationOfSuspiciousActivity& from) {
  CMsgNotificationOfSuspiciousActivity* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgNotificationOfSuspiciousActivity)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_multiple_instances()->::CMsgNotificationOfSuspiciousActivity_MultipleGameInstances::MergeFrom(
          from._internal_multiple_instances());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.steamid_ = from._impl_.steamid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.appid_ = from._impl_.appid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgNotificationOfSuspiciousActivity::CopyFrom(const CMsgNotificationOfSuspiciousActivity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgNotificationOfSuspiciousActivity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgNotificationOfSuspiciousActivity::IsInitialized() const {
  return true;
}

void CMsgNotificationOfSuspiciousActivity::InternalSwap(CMsgNotificationOfSuspiciousActivity* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgNotificationOfSuspiciousActivity, _impl_.appid_)
      + sizeof(CMsgNotificationOfSuspiciousActivity::_impl_.appid_)
      - PROTOBUF_FIELD_OFFSET(CMsgNotificationOfSuspiciousActivity, _impl_.multiple_instances_)>(
          reinterpret_cast<char*>(&_impl_.multiple_instances_),
          reinterpret_cast<char*>(&other->_impl_.multiple_instances_));
}

std::string CMsgNotificationOfSuspiciousActivity::GetTypeName() const {
  return "CMsgNotificationOfSuspiciousActivity";
}


// ===================================================================

class CMsgDPPartnerMicroTxns_PartnerInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDPPartnerMicroTxns_PartnerInfo>()._impl_._has_bits_);
  static void set_has_partner_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_partner_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_currency_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_currency_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgDPPartnerMicroTxns_PartnerInfo::CMsgDPPartnerMicroTxns_PartnerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDPPartnerMicroTxns.PartnerInfo)
}
CMsgDPPartnerMicroTxns_PartnerInfo::CMsgDPPartnerMicroTxns_PartnerInfo(const CMsgDPPartnerMicroTxns_PartnerInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgDPPartnerMicroTxns_PartnerInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.partner_name_){}
    , decltype(_impl_.currency_code_){}
    , decltype(_impl_.currency_name_){}
    , decltype(_impl_.partner_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.partner_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.partner_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_partner_name()) {
    _this->_impl_.partner_name_.Set(from._internal_partner_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.currency_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currency_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_currency_code()) {
    _this->_impl_.currency_code_.Set(from._internal_currency_code(), 
      _this->GetArenaForAllocation());
  }
  _impl_.currency_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currency_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_currency_name()) {
    _this->_impl_.currency_name_.Set(from._internal_currency_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.partner_id_ = from._impl_.partner_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgDPPartnerMicroTxns.PartnerInfo)
}

inline void CMsgDPPartnerMicroTxns_PartnerInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.partner_name_){}
    , decltype(_impl_.currency_code_){}
    , decltype(_impl_.currency_name_){}
    , decltype(_impl_.partner_id_){0u}
  };
  _impl_.partner_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.partner_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.currency_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currency_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.currency_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currency_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDPPartnerMicroTxns_PartnerInfo::~CMsgDPPartnerMicroTxns_PartnerInfo() {
  // @@protoc_insertion_point(destructor:CMsgDPPartnerMicroTxns.PartnerInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDPPartnerMicroTxns_PartnerInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.partner_name_.Destroy();
  _impl_.currency_code_.Destroy();
  _impl_.currency_name_.Destroy();
}

void CMsgDPPartnerMicroTxns_PartnerInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDPPartnerMicroTxns_PartnerInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDPPartnerMicroTxns.PartnerInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.partner_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.currency_code_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.currency_name_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.partner_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgDPPartnerMicroTxns_PartnerInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 partner_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_partner_id(&has_bits);
          _impl_.partner_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string partner_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_partner_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string currency_code = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_currency_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string currency_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_currency_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDPPartnerMicroTxns_PartnerInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDPPartnerMicroTxns.PartnerInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 partner_id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_partner_id(), target);
  }

  // optional string partner_name = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_partner_name(), target);
  }

  // optional string currency_code = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_currency_code(), target);
  }

  // optional string currency_name = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_currency_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDPPartnerMicroTxns.PartnerInfo)
  return target;
}

size_t CMsgDPPartnerMicroTxns_PartnerInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDPPartnerMicroTxns.PartnerInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string partner_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_partner_name());
    }

    // optional string currency_code = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_currency_code());
    }

    // optional string currency_name = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_currency_name());
    }

    // optional uint32 partner_id = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_partner_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgDPPartnerMicroTxns_PartnerInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgDPPartnerMicroTxns_PartnerInfo*>(
      &from));
}

void CMsgDPPartnerMicroTxns_PartnerInfo::MergeFrom(const CMsgDPPartnerMicroTxns_PartnerInfo& from) {
  CMsgDPPartnerMicroTxns_PartnerInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDPPartnerMicroTxns.PartnerInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_partner_name(from._internal_partner_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_currency_code(from._internal_currency_code());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_currency_name(from._internal_currency_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.partner_id_ = from._impl_.partner_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgDPPartnerMicroTxns_PartnerInfo::CopyFrom(const CMsgDPPartnerMicroTxns_PartnerInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDPPartnerMicroTxns.PartnerInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDPPartnerMicroTxns_PartnerInfo::IsInitialized() const {
  return true;
}

void CMsgDPPartnerMicroTxns_PartnerInfo::InternalSwap(CMsgDPPartnerMicroTxns_PartnerInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.partner_name_, lhs_arena,
      &other->_impl_.partner_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.currency_code_, lhs_arena,
      &other->_impl_.currency_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.currency_name_, lhs_arena,
      &other->_impl_.currency_name_, rhs_arena
  );
  swap(_impl_.partner_id_, other->_impl_.partner_id_);
}

std::string CMsgDPPartnerMicroTxns_PartnerInfo::GetTypeName() const {
  return "CMsgDPPartnerMicroTxns.PartnerInfo";
}


// ===================================================================

class CMsgDPPartnerMicroTxns_PartnerMicroTxn::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDPPartnerMicroTxns_PartnerMicroTxn>()._impl_._has_bits_);
  static void set_has_init_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_last_update_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_txn_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_line_item(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_def_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_price(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_tax(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_price_usd(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_tax_usd(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_purchase_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_steam_txn_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_country_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_region_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_quantity(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_ref_trans_id(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
};

CMsgDPPartnerMicroTxns_PartnerMicroTxn::CMsgDPPartnerMicroTxns_PartnerMicroTxn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDPPartnerMicroTxns.PartnerMicroTxn)
}
CMsgDPPartnerMicroTxns_PartnerMicroTxn::CMsgDPPartnerMicroTxns_PartnerMicroTxn(const CMsgDPPartnerMicroTxns_PartnerMicroTxn& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgDPPartnerMicroTxns_PartnerMicroTxn* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.country_code_){}
    , decltype(_impl_.region_code_){}
    , decltype(_impl_.init_time_){}
    , decltype(_impl_.last_update_time_){}
    , decltype(_impl_.txn_id_){}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.line_item_){}
    , decltype(_impl_.item_id_){}
    , decltype(_impl_.price_){}
    , decltype(_impl_.tax_){}
    , decltype(_impl_.def_index_){}
    , decltype(_impl_.purchase_type_){}
    , decltype(_impl_.price_usd_){}
    , decltype(_impl_.tax_usd_){}
    , decltype(_impl_.steam_txn_type_){}
    , decltype(_impl_.quantity_){}
    , decltype(_impl_.ref_trans_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.country_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.country_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_country_code()) {
    _this->_impl_.country_code_.Set(from._internal_country_code(), 
      _this->GetArenaForAllocation());
  }
  _impl_.region_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.region_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_region_code()) {
    _this->_impl_.region_code_.Set(from._internal_region_code(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.init_time_, &from._impl_.init_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ref_trans_id_) -
    reinterpret_cast<char*>(&_impl_.init_time_)) + sizeof(_impl_.ref_trans_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgDPPartnerMicroTxns.PartnerMicroTxn)
}

inline void CMsgDPPartnerMicroTxns_PartnerMicroTxn::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.country_code_){}
    , decltype(_impl_.region_code_){}
    , decltype(_impl_.init_time_){0u}
    , decltype(_impl_.last_update_time_){0u}
    , decltype(_impl_.txn_id_){uint64_t{0u}}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.line_item_){0u}
    , decltype(_impl_.item_id_){uint64_t{0u}}
    , decltype(_impl_.price_){uint64_t{0u}}
    , decltype(_impl_.tax_){uint64_t{0u}}
    , decltype(_impl_.def_index_){0u}
    , decltype(_impl_.purchase_type_){0u}
    , decltype(_impl_.price_usd_){uint64_t{0u}}
    , decltype(_impl_.tax_usd_){uint64_t{0u}}
    , decltype(_impl_.steam_txn_type_){0u}
    , decltype(_impl_.quantity_){0}
    , decltype(_impl_.ref_trans_id_){uint64_t{0u}}
  };
  _impl_.country_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.country_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.region_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.region_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDPPartnerMicroTxns_PartnerMicroTxn::~CMsgDPPartnerMicroTxns_PartnerMicroTxn() {
  // @@protoc_insertion_point(destructor:CMsgDPPartnerMicroTxns.PartnerMicroTxn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDPPartnerMicroTxns_PartnerMicroTxn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.country_code_.Destroy();
  _impl_.region_code_.Destroy();
}

void CMsgDPPartnerMicroTxns_PartnerMicroTxn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDPPartnerMicroTxns_PartnerMicroTxn::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDPPartnerMicroTxns.PartnerMicroTxn)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.country_code_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.region_code_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.init_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.item_id_) -
        reinterpret_cast<char*>(&_impl_.init_time_)) + sizeof(_impl_.item_id_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.price_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.quantity_) -
        reinterpret_cast<char*>(&_impl_.price_)) + sizeof(_impl_.quantity_));
  }
  _impl_.ref_trans_id_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgDPPartnerMicroTxns_PartnerMicroTxn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 init_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_init_time(&has_bits);
          _impl_.init_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 last_update_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_last_update_time(&has_bits);
          _impl_.last_update_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 txn_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_txn_id(&has_bits);
          _impl_.txn_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 account_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 line_item = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_line_item(&has_bits);
          _impl_.line_item_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 item_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_item_id(&has_bits);
          _impl_.item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 def_index = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_def_index(&has_bits);
          _impl_.def_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 price = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_price(&has_bits);
          _impl_.price_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 tax = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_tax(&has_bits);
          _impl_.tax_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 price_usd = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_price_usd(&has_bits);
          _impl_.price_usd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 tax_usd = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_tax_usd(&has_bits);
          _impl_.tax_usd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 purchase_type = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_purchase_type(&has_bits);
          _impl_.purchase_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 steam_txn_type = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_steam_txn_type(&has_bits);
          _impl_.steam_txn_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string country_code = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_country_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string region_code = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_region_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 quantity = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_quantity(&has_bits);
          _impl_.quantity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ref_trans_id = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_ref_trans_id(&has_bits);
          _impl_.ref_trans_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDPPartnerMicroTxns_PartnerMicroTxn::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDPPartnerMicroTxns.PartnerMicroTxn)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 init_time = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_init_time(), target);
  }

  // optional uint32 last_update_time = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_last_update_time(), target);
  }

  // optional uint64 txn_id = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_txn_id(), target);
  }

  // optional uint32 account_id = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_account_id(), target);
  }

  // optional uint32 line_item = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_line_item(), target);
  }

  // optional uint64 item_id = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_item_id(), target);
  }

  // optional uint32 def_index = 7;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_def_index(), target);
  }

  // optional uint64 price = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_price(), target);
  }

  // optional uint64 tax = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal_tax(), target);
  }

  // optional uint64 price_usd = 10;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(10, this->_internal_price_usd(), target);
  }

  // optional uint64 tax_usd = 11;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(11, this->_internal_tax_usd(), target);
  }

  // optional uint32 purchase_type = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_purchase_type(), target);
  }

  // optional uint32 steam_txn_type = 13;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_steam_txn_type(), target);
  }

  // optional string country_code = 14;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_country_code(), target);
  }

  // optional string region_code = 15;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        15, this->_internal_region_code(), target);
  }

  // optional int32 quantity = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(16, this->_internal_quantity(), target);
  }

  // optional uint64 ref_trans_id = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(17, this->_internal_ref_trans_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDPPartnerMicroTxns.PartnerMicroTxn)
  return target;
}

size_t CMsgDPPartnerMicroTxns_PartnerMicroTxn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDPPartnerMicroTxns.PartnerMicroTxn)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string country_code = 14;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_country_code());
    }

    // optional string region_code = 15;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_region_code());
    }

    // optional uint32 init_time = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_init_time());
    }

    // optional uint32 last_update_time = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_last_update_time());
    }

    // optional uint64 txn_id = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_txn_id());
    }

    // optional uint32 account_id = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 line_item = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_line_item());
    }

    // optional uint64 item_id = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_id());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint64 price = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_price());
    }

    // optional uint64 tax = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_tax());
    }

    // optional uint32 def_index = 7;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_def_index());
    }

    // optional uint32 purchase_type = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_purchase_type());
    }

    // optional uint64 price_usd = 10;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_price_usd());
    }

    // optional uint64 tax_usd = 11;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_tax_usd());
    }

    // optional uint32 steam_txn_type = 13;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_steam_txn_type());
    }

    // optional int32 quantity = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_quantity());
    }

  }
  // optional uint64 ref_trans_id = 17;
  if (cached_has_bits & 0x00010000u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt64Size(
        this->_internal_ref_trans_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgDPPartnerMicroTxns_PartnerMicroTxn::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgDPPartnerMicroTxns_PartnerMicroTxn*>(
      &from));
}

void CMsgDPPartnerMicroTxns_PartnerMicroTxn::MergeFrom(const CMsgDPPartnerMicroTxns_PartnerMicroTxn& from) {
  CMsgDPPartnerMicroTxns_PartnerMicroTxn* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDPPartnerMicroTxns.PartnerMicroTxn)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_country_code(from._internal_country_code());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_region_code(from._internal_region_code());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.init_time_ = from._impl_.init_time_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.last_update_time_ = from._impl_.last_update_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.txn_id_ = from._impl_.txn_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.line_item_ = from._impl_.line_item_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.item_id_ = from._impl_.item_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.price_ = from._impl_.price_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.tax_ = from._impl_.tax_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.def_index_ = from._impl_.def_index_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.purchase_type_ = from._impl_.purchase_type_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.price_usd_ = from._impl_.price_usd_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.tax_usd_ = from._impl_.tax_usd_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.steam_txn_type_ = from._impl_.steam_txn_type_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.quantity_ = from._impl_.quantity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00010000u) {
    _this->_internal_set_ref_trans_id(from._internal_ref_trans_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgDPPartnerMicroTxns_PartnerMicroTxn::CopyFrom(const CMsgDPPartnerMicroTxns_PartnerMicroTxn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDPPartnerMicroTxns.PartnerMicroTxn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDPPartnerMicroTxns_PartnerMicroTxn::IsInitialized() const {
  return true;
}

void CMsgDPPartnerMicroTxns_PartnerMicroTxn::InternalSwap(CMsgDPPartnerMicroTxns_PartnerMicroTxn* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.country_code_, lhs_arena,
      &other->_impl_.country_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.region_code_, lhs_arena,
      &other->_impl_.region_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDPPartnerMicroTxns_PartnerMicroTxn, _impl_.ref_trans_id_)
      + sizeof(CMsgDPPartnerMicroTxns_PartnerMicroTxn::_impl_.ref_trans_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgDPPartnerMicroTxns_PartnerMicroTxn, _impl_.init_time_)>(
          reinterpret_cast<char*>(&_impl_.init_time_),
          reinterpret_cast<char*>(&other->_impl_.init_time_));
}

std::string CMsgDPPartnerMicroTxns_PartnerMicroTxn::GetTypeName() const {
  return "CMsgDPPartnerMicroTxns.PartnerMicroTxn";
}


// ===================================================================

class CMsgDPPartnerMicroTxns::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDPPartnerMicroTxns>()._impl_._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gc_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgDPPartnerMicroTxns_PartnerInfo& partner(const CMsgDPPartnerMicroTxns* msg);
  static void set_has_partner(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgDPPartnerMicroTxns_PartnerInfo&
CMsgDPPartnerMicroTxns::_Internal::partner(const CMsgDPPartnerMicroTxns* msg) {
  return *msg->_impl_.partner_;
}
CMsgDPPartnerMicroTxns::CMsgDPPartnerMicroTxns(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDPPartnerMicroTxns)
}
CMsgDPPartnerMicroTxns::CMsgDPPartnerMicroTxns(const CMsgDPPartnerMicroTxns& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgDPPartnerMicroTxns* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.transactions_){from._impl_.transactions_}
    , decltype(_impl_.gc_name_){}
    , decltype(_impl_.partner_){nullptr}
    , decltype(_impl_.appid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.gc_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gc_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gc_name()) {
    _this->_impl_.gc_name_.Set(from._internal_gc_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_partner()) {
    _this->_impl_.partner_ = new ::CMsgDPPartnerMicroTxns_PartnerInfo(*from._impl_.partner_);
  }
  _this->_impl_.appid_ = from._impl_.appid_;
  // @@protoc_insertion_point(copy_constructor:CMsgDPPartnerMicroTxns)
}

inline void CMsgDPPartnerMicroTxns::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.transactions_){arena}
    , decltype(_impl_.gc_name_){}
    , decltype(_impl_.partner_){nullptr}
    , decltype(_impl_.appid_){0u}
  };
  _impl_.gc_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gc_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDPPartnerMicroTxns::~CMsgDPPartnerMicroTxns() {
  // @@protoc_insertion_point(destructor:CMsgDPPartnerMicroTxns)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDPPartnerMicroTxns::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.transactions_.~RepeatedPtrField();
  _impl_.gc_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.partner_;
}

void CMsgDPPartnerMicroTxns::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDPPartnerMicroTxns::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDPPartnerMicroTxns)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.transactions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.gc_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.partner_ != nullptr);
      _impl_.partner_->Clear();
    }
  }
  _impl_.appid_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgDPPartnerMicroTxns::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          _impl_.appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string gc_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_gc_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDPPartnerMicroTxns.PartnerInfo partner = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_partner(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDPPartnerMicroTxns.PartnerMicroTxn transactions = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_transactions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDPPartnerMicroTxns::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDPPartnerMicroTxns)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional string gc_name = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_gc_name(), target);
  }

  // optional .CMsgDPPartnerMicroTxns.PartnerInfo partner = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::partner(this),
        _Internal::partner(this).GetCachedSize(), target, stream);
  }

  // repeated .CMsgDPPartnerMicroTxns.PartnerMicroTxn transactions = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_transactions_size()); i < n; i++) {
    const auto& repfield = this->_internal_transactions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDPPartnerMicroTxns)
  return target;
}

size_t CMsgDPPartnerMicroTxns::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDPPartnerMicroTxns)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDPPartnerMicroTxns.PartnerMicroTxn transactions = 4;
  total_size += 1UL * this->_internal_transactions_size();
  for (const auto& msg : this->_impl_.transactions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string gc_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_gc_name());
    }

    // optional .CMsgDPPartnerMicroTxns.PartnerInfo partner = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.partner_);
    }

    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgDPPartnerMicroTxns::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgDPPartnerMicroTxns*>(
      &from));
}

void CMsgDPPartnerMicroTxns::MergeFrom(const CMsgDPPartnerMicroTxns& from) {
  CMsgDPPartnerMicroTxns* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDPPartnerMicroTxns)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.transactions_.MergeFrom(from._impl_.transactions_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_gc_name(from._internal_gc_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_partner()->::CMsgDPPartnerMicroTxns_PartnerInfo::MergeFrom(
          from._internal_partner());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.appid_ = from._impl_.appid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgDPPartnerMicroTxns::CopyFrom(const CMsgDPPartnerMicroTxns& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDPPartnerMicroTxns)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDPPartnerMicroTxns::IsInitialized() const {
  return true;
}

void CMsgDPPartnerMicroTxns::InternalSwap(CMsgDPPartnerMicroTxns* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.transactions_.InternalSwap(&other->_impl_.transactions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.gc_name_, lhs_arena,
      &other->_impl_.gc_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDPPartnerMicroTxns, _impl_.appid_)
      + sizeof(CMsgDPPartnerMicroTxns::_impl_.appid_)
      - PROTOBUF_FIELD_OFFSET(CMsgDPPartnerMicroTxns, _impl_.partner_)>(
          reinterpret_cast<char*>(&_impl_.partner_),
          reinterpret_cast<char*>(&other->_impl_.partner_));
}

std::string CMsgDPPartnerMicroTxns::GetTypeName() const {
  return "CMsgDPPartnerMicroTxns";
}


// ===================================================================

class CMsgDPPartnerMicroTxnsResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDPPartnerMicroTxnsResponse>()._impl_._has_bits_);
  static void set_has_eresult(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_eerrorcode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgDPPartnerMicroTxnsResponse::CMsgDPPartnerMicroTxnsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDPPartnerMicroTxnsResponse)
}
CMsgDPPartnerMicroTxnsResponse::CMsgDPPartnerMicroTxnsResponse(const CMsgDPPartnerMicroTxnsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgDPPartnerMicroTxnsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.eerrorcode_){}
    , decltype(_impl_.eresult_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.eerrorcode_, &from._impl_.eerrorcode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.eresult_) -
    reinterpret_cast<char*>(&_impl_.eerrorcode_)) + sizeof(_impl_.eresult_));
  // @@protoc_insertion_point(copy_constructor:CMsgDPPartnerMicroTxnsResponse)
}

inline void CMsgDPPartnerMicroTxnsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.eerrorcode_){0}
    , decltype(_impl_.eresult_){2u}
  };
}

CMsgDPPartnerMicroTxnsResponse::~CMsgDPPartnerMicroTxnsResponse() {
  // @@protoc_insertion_point(destructor:CMsgDPPartnerMicroTxnsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDPPartnerMicroTxnsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDPPartnerMicroTxnsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDPPartnerMicroTxnsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDPPartnerMicroTxnsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.eerrorcode_ = 0;
    _impl_.eresult_ = 2u;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgDPPartnerMicroTxnsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 eresult = 1 [default = 2];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_eresult(&has_bits);
          _impl_.eresult_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDPPartnerMicroTxnsResponse.EErrorCode eerrorcode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgDPPartnerMicroTxnsResponse_EErrorCode_IsValid(val))) {
            _internal_set_eerrorcode(static_cast<::CMsgDPPartnerMicroTxnsResponse_EErrorCode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDPPartnerMicroTxnsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDPPartnerMicroTxnsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 eresult = 1 [default = 2];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_eresult(), target);
  }

  // optional .CMsgDPPartnerMicroTxnsResponse.EErrorCode eerrorcode = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_eerrorcode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDPPartnerMicroTxnsResponse)
  return target;
}

size_t CMsgDPPartnerMicroTxnsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDPPartnerMicroTxnsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgDPPartnerMicroTxnsResponse.EErrorCode eerrorcode = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_eerrorcode());
    }

    // optional uint32 eresult = 1 [default = 2];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_eresult());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgDPPartnerMicroTxnsResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgDPPartnerMicroTxnsResponse*>(
      &from));
}

void CMsgDPPartnerMicroTxnsResponse::MergeFrom(const CMsgDPPartnerMicroTxnsResponse& from) {
  CMsgDPPartnerMicroTxnsResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDPPartnerMicroTxnsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.eerrorcode_ = from._impl_.eerrorcode_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.eresult_ = from._impl_.eresult_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgDPPartnerMicroTxnsResponse::CopyFrom(const CMsgDPPartnerMicroTxnsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDPPartnerMicroTxnsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDPPartnerMicroTxnsResponse::IsInitialized() const {
  return true;
}

void CMsgDPPartnerMicroTxnsResponse::InternalSwap(CMsgDPPartnerMicroTxnsResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.eerrorcode_, other->_impl_.eerrorcode_);
  swap(_impl_.eresult_, other->_impl_.eresult_);
}

std::string CMsgDPPartnerMicroTxnsResponse::GetTypeName() const {
  return "CMsgDPPartnerMicroTxnsResponse";
}


// ===================================================================

class CChinaAgreementSessions_StartAgreementSessionInGame_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CChinaAgreementSessions_StartAgreementSessionInGame_Request>()._impl_._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_client_ipaddress(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CChinaAgreementSessions_StartAgreementSessionInGame_Request::CChinaAgreementSessions_StartAgreementSessionInGame_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CChinaAgreementSessions_StartAgreementSessionInGame_Request)
}
CChinaAgreementSessions_StartAgreementSessionInGame_Request::CChinaAgreementSessions_StartAgreementSessionInGame_Request(const CChinaAgreementSessions_StartAgreementSessionInGame_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CChinaAgreementSessions_StartAgreementSessionInGame_Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_ipaddress_){}
    , decltype(_impl_.steamid_){}
    , decltype(_impl_.appid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.client_ipaddress_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_ipaddress_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_client_ipaddress()) {
    _this->_impl_.client_ipaddress_.Set(from._internal_client_ipaddress(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.steamid_, &from._impl_.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.appid_) -
    reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.appid_));
  // @@protoc_insertion_point(copy_constructor:CChinaAgreementSessions_StartAgreementSessionInGame_Request)
}

inline void CChinaAgreementSessions_StartAgreementSessionInGame_Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_ipaddress_){}
    , decltype(_impl_.steamid_){uint64_t{0u}}
    , decltype(_impl_.appid_){0u}
  };
  _impl_.client_ipaddress_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_ipaddress_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CChinaAgreementSessions_StartAgreementSessionInGame_Request::~CChinaAgreementSessions_StartAgreementSessionInGame_Request() {
  // @@protoc_insertion_point(destructor:CChinaAgreementSessions_StartAgreementSessionInGame_Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CChinaAgreementSessions_StartAgreementSessionInGame_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.client_ipaddress_.Destroy();
}

void CChinaAgreementSessions_StartAgreementSessionInGame_Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CChinaAgreementSessions_StartAgreementSessionInGame_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CChinaAgreementSessions_StartAgreementSessionInGame_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.client_ipaddress_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.appid_) -
        reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.appid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CChinaAgreementSessions_StartAgreementSessionInGame_Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          _impl_.appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 steamid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_steamid(&has_bits);
          _impl_.steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional string client_ipaddress = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_client_ipaddress();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CChinaAgreementSessions_StartAgreementSessionInGame_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CChinaAgreementSessions_StartAgreementSessionInGame_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional fixed64 steamid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_steamid(), target);
  }

  // optional string client_ipaddress = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_client_ipaddress(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CChinaAgreementSessions_StartAgreementSessionInGame_Request)
  return target;
}

size_t CChinaAgreementSessions_StartAgreementSessionInGame_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CChinaAgreementSessions_StartAgreementSessionInGame_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string client_ipaddress = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_client_ipaddress());
    }

    // optional fixed64 steamid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CChinaAgreementSessions_StartAgreementSessionInGame_Request::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CChinaAgreementSessions_StartAgreementSessionInGame_Request*>(
      &from));
}

void CChinaAgreementSessions_StartAgreementSessionInGame_Request::MergeFrom(const CChinaAgreementSessions_StartAgreementSessionInGame_Request& from) {
  CChinaAgreementSessions_StartAgreementSessionInGame_Request* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CChinaAgreementSessions_StartAgreementSessionInGame_Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_client_ipaddress(from._internal_client_ipaddress());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.steamid_ = from._impl_.steamid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.appid_ = from._impl_.appid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CChinaAgreementSessions_StartAgreementSessionInGame_Request::CopyFrom(const CChinaAgreementSessions_StartAgreementSessionInGame_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CChinaAgreementSessions_StartAgreementSessionInGame_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CChinaAgreementSessions_StartAgreementSessionInGame_Request::IsInitialized() const {
  return true;
}

void CChinaAgreementSessions_StartAgreementSessionInGame_Request::InternalSwap(CChinaAgreementSessions_StartAgreementSessionInGame_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.client_ipaddress_, lhs_arena,
      &other->_impl_.client_ipaddress_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CChinaAgreementSessions_StartAgreementSessionInGame_Request, _impl_.appid_)
      + sizeof(CChinaAgreementSessions_StartAgreementSessionInGame_Request::_impl_.appid_)
      - PROTOBUF_FIELD_OFFSET(CChinaAgreementSessions_StartAgreementSessionInGame_Request, _impl_.steamid_)>(
          reinterpret_cast<char*>(&_impl_.steamid_),
          reinterpret_cast<char*>(&other->_impl_.steamid_));
}

std::string CChinaAgreementSessions_StartAgreementSessionInGame_Request::GetTypeName() const {
  return "CChinaAgreementSessions_StartAgreementSessionInGame_Request";
}


// ===================================================================

class CChinaAgreementSessions_StartAgreementSessionInGame_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CChinaAgreementSessions_StartAgreementSessionInGame_Response>()._impl_._has_bits_);
  static void set_has_agreement_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CChinaAgreementSessions_StartAgreementSessionInGame_Response::CChinaAgreementSessions_StartAgreementSessionInGame_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CChinaAgreementSessions_StartAgreementSessionInGame_Response)
}
CChinaAgreementSessions_StartAgreementSessionInGame_Response::CChinaAgreementSessions_StartAgreementSessionInGame_Response(const CChinaAgreementSessions_StartAgreementSessionInGame_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CChinaAgreementSessions_StartAgreementSessionInGame_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.agreement_url_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.agreement_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.agreement_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_agreement_url()) {
    _this->_impl_.agreement_url_.Set(from._internal_agreement_url(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CChinaAgreementSessions_StartAgreementSessionInGame_Response)
}

inline void CChinaAgreementSessions_StartAgreementSessionInGame_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.agreement_url_){}
  };
  _impl_.agreement_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.agreement_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CChinaAgreementSessions_StartAgreementSessionInGame_Response::~CChinaAgreementSessions_StartAgreementSessionInGame_Response() {
  // @@protoc_insertion_point(destructor:CChinaAgreementSessions_StartAgreementSessionInGame_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CChinaAgreementSessions_StartAgreementSessionInGame_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.agreement_url_.Destroy();
}

void CChinaAgreementSessions_StartAgreementSessionInGame_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CChinaAgreementSessions_StartAgreementSessionInGame_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CChinaAgreementSessions_StartAgreementSessionInGame_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.agreement_url_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CChinaAgreementSessions_StartAgreementSessionInGame_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string agreement_url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_agreement_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CChinaAgreementSessions_StartAgreementSessionInGame_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CChinaAgreementSessions_StartAgreementSessionInGame_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string agreement_url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_agreement_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CChinaAgreementSessions_StartAgreementSessionInGame_Response)
  return target;
}

size_t CChinaAgreementSessions_StartAgreementSessionInGame_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CChinaAgreementSessions_StartAgreementSessionInGame_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string agreement_url = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_agreement_url());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CChinaAgreementSessions_StartAgreementSessionInGame_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CChinaAgreementSessions_StartAgreementSessionInGame_Response*>(
      &from));
}

void CChinaAgreementSessions_StartAgreementSessionInGame_Response::MergeFrom(const CChinaAgreementSessions_StartAgreementSessionInGame_Response& from) {
  CChinaAgreementSessions_StartAgreementSessionInGame_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CChinaAgreementSessions_StartAgreementSessionInGame_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_agreement_url()) {
    _this->_internal_set_agreement_url(from._internal_agreement_url());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CChinaAgreementSessions_StartAgreementSessionInGame_Response::CopyFrom(const CChinaAgreementSessions_StartAgreementSessionInGame_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CChinaAgreementSessions_StartAgreementSessionInGame_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CChinaAgreementSessions_StartAgreementSessionInGame_Response::IsInitialized() const {
  return true;
}

void CChinaAgreementSessions_StartAgreementSessionInGame_Response::InternalSwap(CChinaAgreementSessions_StartAgreementSessionInGame_Response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.agreement_url_, lhs_arena,
      &other->_impl_.agreement_url_, rhs_arena
  );
}

std::string CChinaAgreementSessions_StartAgreementSessionInGame_Response::GetTypeName() const {
  return "CChinaAgreementSessions_StartAgreementSessionInGame_Response";
}


// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CMsgProtoBufHeader*
Arena::CreateMaybeMessage< ::CMsgProtoBufHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgProtoBufHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgWebAPIKey*
Arena::CreateMaybeMessage< ::CMsgWebAPIKey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgWebAPIKey >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgHttpRequest_RequestHeader*
Arena::CreateMaybeMessage< ::CMsgHttpRequest_RequestHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgHttpRequest_RequestHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgHttpRequest_QueryParam*
Arena::CreateMaybeMessage< ::CMsgHttpRequest_QueryParam >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgHttpRequest_QueryParam >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgHttpRequest*
Arena::CreateMaybeMessage< ::CMsgHttpRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgHttpRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgWebAPIRequest*
Arena::CreateMaybeMessage< ::CMsgWebAPIRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgWebAPIRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgHttpResponse_ResponseHeader*
Arena::CreateMaybeMessage< ::CMsgHttpResponse_ResponseHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgHttpResponse_ResponseHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgHttpResponse*
Arena::CreateMaybeMessage< ::CMsgHttpResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgHttpResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgAMFindAccounts*
Arena::CreateMaybeMessage< ::CMsgAMFindAccounts >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgAMFindAccounts >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgAMFindAccountsResponse*
Arena::CreateMaybeMessage< ::CMsgAMFindAccountsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgAMFindAccountsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgNotifyWatchdog*
Arena::CreateMaybeMessage< ::CMsgNotifyWatchdog >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgNotifyWatchdog >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgAMGetLicenses*
Arena::CreateMaybeMessage< ::CMsgAMGetLicenses >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgAMGetLicenses >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgPackageLicense*
Arena::CreateMaybeMessage< ::CMsgPackageLicense >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgPackageLicense >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgAMGetLicensesResponse*
Arena::CreateMaybeMessage< ::CMsgAMGetLicensesResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgAMGetLicensesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgAMGetUserGameStats*
Arena::CreateMaybeMessage< ::CMsgAMGetUserGameStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgAMGetUserGameStats >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgAMGetUserGameStatsResponse_Stats*
Arena::CreateMaybeMessage< ::CMsgAMGetUserGameStatsResponse_Stats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgAMGetUserGameStatsResponse_Stats >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgAMGetUserGameStatsResponse_Achievement_Blocks*
Arena::CreateMaybeMessage< ::CMsgAMGetUserGameStatsResponse_Achievement_Blocks >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgAMGetUserGameStatsResponse_Achievement_Blocks >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgAMGetUserGameStatsResponse*
Arena::CreateMaybeMessage< ::CMsgAMGetUserGameStatsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgAMGetUserGameStatsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCGetCommandList*
Arena::CreateMaybeMessage< ::CMsgGCGetCommandList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCGetCommandList >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCGetCommandListResponse*
Arena::CreateMaybeMessage< ::CMsgGCGetCommandListResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCGetCommandListResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCMsgMemCachedGet*
Arena::CreateMaybeMessage< ::CGCMsgMemCachedGet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCMsgMemCachedGet >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCMsgMemCachedGetResponse_ValueTag*
Arena::CreateMaybeMessage< ::CGCMsgMemCachedGetResponse_ValueTag >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCMsgMemCachedGetResponse_ValueTag >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCMsgMemCachedGetResponse*
Arena::CreateMaybeMessage< ::CGCMsgMemCachedGetResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCMsgMemCachedGetResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCMsgMemCachedSet_KeyPair*
Arena::CreateMaybeMessage< ::CGCMsgMemCachedSet_KeyPair >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCMsgMemCachedSet_KeyPair >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCMsgMemCachedSet*
Arena::CreateMaybeMessage< ::CGCMsgMemCachedSet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCMsgMemCachedSet >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCMsgMemCachedDelete*
Arena::CreateMaybeMessage< ::CGCMsgMemCachedDelete >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCMsgMemCachedDelete >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCMsgMemCachedStats*
Arena::CreateMaybeMessage< ::CGCMsgMemCachedStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCMsgMemCachedStats >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCMsgMemCachedStatsResponse*
Arena::CreateMaybeMessage< ::CGCMsgMemCachedStatsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCMsgMemCachedStatsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCMsgSQLStats*
Arena::CreateMaybeMessage< ::CGCMsgSQLStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCMsgSQLStats >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCMsgSQLStatsResponse*
Arena::CreateMaybeMessage< ::CGCMsgSQLStatsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCMsgSQLStatsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgAMAddFreeLicense*
Arena::CreateMaybeMessage< ::CMsgAMAddFreeLicense >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgAMAddFreeLicense >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgAMAddFreeLicenseResponse*
Arena::CreateMaybeMessage< ::CMsgAMAddFreeLicenseResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgAMAddFreeLicenseResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCMsgGetIPLocation*
Arena::CreateMaybeMessage< ::CGCMsgGetIPLocation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCMsgGetIPLocation >(arena);
}
template<> PROTOBUF_NOINLINE ::CIPLocationInfo*
Arena::CreateMaybeMessage< ::CIPLocationInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CIPLocationInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCMsgGetIPLocationResponse*
Arena::CreateMaybeMessage< ::CGCMsgGetIPLocationResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCMsgGetIPLocationResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCMsgSystemStatsSchema*
Arena::CreateMaybeMessage< ::CGCMsgSystemStatsSchema >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCMsgSystemStatsSchema >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCMsgGetSystemStats*
Arena::CreateMaybeMessage< ::CGCMsgGetSystemStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCMsgGetSystemStats >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCMsgGetSystemStatsResponse*
Arena::CreateMaybeMessage< ::CGCMsgGetSystemStatsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCMsgGetSystemStatsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgAMSendEmail_PersonaNameReplacementToken*
Arena::CreateMaybeMessage< ::CMsgAMSendEmail_PersonaNameReplacementToken >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgAMSendEmail_PersonaNameReplacementToken >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgAMSendEmail_ReplacementToken*
Arena::CreateMaybeMessage< ::CMsgAMSendEmail_ReplacementToken >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgAMSendEmail_ReplacementToken >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgAMSendEmail*
Arena::CreateMaybeMessage< ::CMsgAMSendEmail >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgAMSendEmail >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgAMSendEmailResponse*
Arena::CreateMaybeMessage< ::CMsgAMSendEmailResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgAMSendEmailResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCGetEmailTemplate*
Arena::CreateMaybeMessage< ::CMsgGCGetEmailTemplate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCGetEmailTemplate >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCGetEmailTemplateResponse*
Arena::CreateMaybeMessage< ::CMsgGCGetEmailTemplateResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCGetEmailTemplateResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgAMGrantGuestPasses2*
Arena::CreateMaybeMessage< ::CMsgAMGrantGuestPasses2 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgAMGrantGuestPasses2 >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgAMGrantGuestPasses2Response*
Arena::CreateMaybeMessage< ::CMsgAMGrantGuestPasses2Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgAMGrantGuestPasses2Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCSystemMsg_GetAccountDetails*
Arena::CreateMaybeMessage< ::CGCSystemMsg_GetAccountDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCSystemMsg_GetAccountDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCSystemMsg_GetAccountDetails_Response*
Arena::CreateMaybeMessage< ::CGCSystemMsg_GetAccountDetails_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCSystemMsg_GetAccountDetails_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCGetPersonaNames*
Arena::CreateMaybeMessage< ::CMsgGCGetPersonaNames >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCGetPersonaNames >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCGetPersonaNames_Response_PersonaName*
Arena::CreateMaybeMessage< ::CMsgGCGetPersonaNames_Response_PersonaName >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCGetPersonaNames_Response_PersonaName >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCGetPersonaNames_Response*
Arena::CreateMaybeMessage< ::CMsgGCGetPersonaNames_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCGetPersonaNames_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCCheckFriendship*
Arena::CreateMaybeMessage< ::CMsgGCCheckFriendship >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCCheckFriendship >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCCheckFriendship_Response*
Arena::CreateMaybeMessage< ::CMsgGCCheckFriendship_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCCheckFriendship_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCMsgMasterSetDirectory_SubGC*
Arena::CreateMaybeMessage< ::CMsgGCMsgMasterSetDirectory_SubGC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCMsgMasterSetDirectory_SubGC >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCMsgMasterSetDirectory*
Arena::CreateMaybeMessage< ::CMsgGCMsgMasterSetDirectory >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCMsgMasterSetDirectory >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCMsgMasterSetDirectory_Response*
Arena::CreateMaybeMessage< ::CMsgGCMsgMasterSetDirectory_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCMsgMasterSetDirectory_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCMsgWebAPIJobRequestForwardResponse*
Arena::CreateMaybeMessage< ::CMsgGCMsgWebAPIJobRequestForwardResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCMsgWebAPIJobRequestForwardResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCSystemMsg_GetPurchaseTrust_Request*
Arena::CreateMaybeMessage< ::CGCSystemMsg_GetPurchaseTrust_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCSystemMsg_GetPurchaseTrust_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCSystemMsg_GetPurchaseTrust_Response*
Arena::CreateMaybeMessage< ::CGCSystemMsg_GetPurchaseTrust_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCSystemMsg_GetPurchaseTrust_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCHAccountVacStatusChange*
Arena::CreateMaybeMessage< ::CMsgGCHAccountVacStatusChange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCHAccountVacStatusChange >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCGetPartnerAccountLink*
Arena::CreateMaybeMessage< ::CMsgGCGetPartnerAccountLink >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCGetPartnerAccountLink >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCGetPartnerAccountLink_Response*
Arena::CreateMaybeMessage< ::CMsgGCGetPartnerAccountLink_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCGetPartnerAccountLink_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCAddressMask*
Arena::CreateMaybeMessage< ::CMsgGCAddressMask >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCAddressMask >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCAddressMaskGroup*
Arena::CreateMaybeMessage< ::CMsgGCAddressMaskGroup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCAddressMaskGroup >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCRoutingInfo_PolicyRule*
Arena::CreateMaybeMessage< ::CMsgGCRoutingInfo_PolicyRule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCRoutingInfo_PolicyRule >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCRoutingInfo_TokenBucketConfiguration*
Arena::CreateMaybeMessage< ::CMsgGCRoutingInfo_TokenBucketConfiguration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCRoutingInfo_TokenBucketConfiguration >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCRoutingInfo*
Arena::CreateMaybeMessage< ::CMsgGCRoutingInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCRoutingInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCMsgMasterSetWebAPIRouting_Entry*
Arena::CreateMaybeMessage< ::CMsgGCMsgMasterSetWebAPIRouting_Entry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCMsgMasterSetWebAPIRouting_Entry >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCMsgMasterSetWebAPIRouting*
Arena::CreateMaybeMessage< ::CMsgGCMsgMasterSetWebAPIRouting >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCMsgMasterSetWebAPIRouting >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCMsgMasterSetClientMsgRouting_Entry*
Arena::CreateMaybeMessage< ::CMsgGCMsgMasterSetClientMsgRouting_Entry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCMsgMasterSetClientMsgRouting_Entry >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCMsgMasterSetClientMsgRouting*
Arena::CreateMaybeMessage< ::CMsgGCMsgMasterSetClientMsgRouting >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCMsgMasterSetClientMsgRouting >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCMsgMasterSetWebAPIRouting_Response*
Arena::CreateMaybeMessage< ::CMsgGCMsgMasterSetWebAPIRouting_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCMsgMasterSetWebAPIRouting_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCMsgMasterSetClientMsgRouting_Response*
Arena::CreateMaybeMessage< ::CMsgGCMsgMasterSetClientMsgRouting_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCMsgMasterSetClientMsgRouting_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCMsgSetOptions_MessageRange*
Arena::CreateMaybeMessage< ::CMsgGCMsgSetOptions_MessageRange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCMsgSetOptions_MessageRange >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCMsgSetOptions*
Arena::CreateMaybeMessage< ::CMsgGCMsgSetOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCMsgSetOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCHUpdateSession_ExtraField*
Arena::CreateMaybeMessage< ::CMsgGCHUpdateSession_ExtraField >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCHUpdateSession_ExtraField >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCHUpdateSession*
Arena::CreateMaybeMessage< ::CMsgGCHUpdateSession >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCHUpdateSession >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgNotificationOfSuspiciousActivity_MultipleGameInstances*
Arena::CreateMaybeMessage< ::CMsgNotificationOfSuspiciousActivity_MultipleGameInstances >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgNotificationOfSuspiciousActivity_MultipleGameInstances >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgNotificationOfSuspiciousActivity*
Arena::CreateMaybeMessage< ::CMsgNotificationOfSuspiciousActivity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgNotificationOfSuspiciousActivity >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDPPartnerMicroTxns_PartnerInfo*
Arena::CreateMaybeMessage< ::CMsgDPPartnerMicroTxns_PartnerInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDPPartnerMicroTxns_PartnerInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDPPartnerMicroTxns_PartnerMicroTxn*
Arena::CreateMaybeMessage< ::CMsgDPPartnerMicroTxns_PartnerMicroTxn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDPPartnerMicroTxns_PartnerMicroTxn >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDPPartnerMicroTxns*
Arena::CreateMaybeMessage< ::CMsgDPPartnerMicroTxns >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDPPartnerMicroTxns >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDPPartnerMicroTxnsResponse*
Arena::CreateMaybeMessage< ::CMsgDPPartnerMicroTxnsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDPPartnerMicroTxnsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CChinaAgreementSessions_StartAgreementSessionInGame_Request*
Arena::CreateMaybeMessage< ::CChinaAgreementSessions_StartAgreementSessionInGame_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CChinaAgreementSessions_StartAgreementSessionInGame_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CChinaAgreementSessions_StartAgreementSessionInGame_Response*
Arena::CreateMaybeMessage< ::CChinaAgreementSessions_StartAgreementSessionInGame_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CChinaAgreementSessions_StartAgreementSessionInGame_Response >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
