// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gcsdk_gcmessages.proto

#include "gcsdk_gcmessages.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR CMsgSOIDOwner::CMsgSOIDOwner(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_.type_)*/0u} {}
struct CMsgSOIDOwnerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSOIDOwnerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSOIDOwnerDefaultTypeInternal() {}
  union {
    CMsgSOIDOwner _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSOIDOwnerDefaultTypeInternal _CMsgSOIDOwner_default_instance_;
PROTOBUF_CONSTEXPR CMsgSOSingleObject::CMsgSOSingleObject(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.object_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.owner_soid_)*/nullptr
  , /*decltype(_impl_.version_)*/uint64_t{0u}
  , /*decltype(_impl_.type_id_)*/0} {}
struct CMsgSOSingleObjectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSOSingleObjectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSOSingleObjectDefaultTypeInternal() {}
  union {
    CMsgSOSingleObject _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSOSingleObjectDefaultTypeInternal _CMsgSOSingleObject_default_instance_;
PROTOBUF_CONSTEXPR CMsgSOMultipleObjects_SingleObject::CMsgSOMultipleObjects_SingleObject(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.object_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_id_)*/0} {}
struct CMsgSOMultipleObjects_SingleObjectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSOMultipleObjects_SingleObjectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSOMultipleObjects_SingleObjectDefaultTypeInternal() {}
  union {
    CMsgSOMultipleObjects_SingleObject _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSOMultipleObjects_SingleObjectDefaultTypeInternal _CMsgSOMultipleObjects_SingleObject_default_instance_;
PROTOBUF_CONSTEXPR CMsgSOMultipleObjects::CMsgSOMultipleObjects(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.objects_modified_)*/{}
  , /*decltype(_impl_.owner_soid_)*/nullptr
  , /*decltype(_impl_.version_)*/uint64_t{0u}} {}
struct CMsgSOMultipleObjectsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSOMultipleObjectsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSOMultipleObjectsDefaultTypeInternal() {}
  union {
    CMsgSOMultipleObjects _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSOMultipleObjectsDefaultTypeInternal _CMsgSOMultipleObjects_default_instance_;
PROTOBUF_CONSTEXPR CMsgSOCacheSubscribed_SubscribedType::CMsgSOCacheSubscribed_SubscribedType(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.object_data_)*/{}
  , /*decltype(_impl_.type_id_)*/0} {}
struct CMsgSOCacheSubscribed_SubscribedTypeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSOCacheSubscribed_SubscribedTypeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSOCacheSubscribed_SubscribedTypeDefaultTypeInternal() {}
  union {
    CMsgSOCacheSubscribed_SubscribedType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSOCacheSubscribed_SubscribedTypeDefaultTypeInternal _CMsgSOCacheSubscribed_SubscribedType_default_instance_;
PROTOBUF_CONSTEXPR CMsgSOCacheSubscribed::CMsgSOCacheSubscribed(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.objects_)*/{}
  , /*decltype(_impl_.owner_soid_)*/nullptr
  , /*decltype(_impl_.version_)*/uint64_t{0u}} {}
struct CMsgSOCacheSubscribedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSOCacheSubscribedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSOCacheSubscribedDefaultTypeInternal() {}
  union {
    CMsgSOCacheSubscribed _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSOCacheSubscribedDefaultTypeInternal _CMsgSOCacheSubscribed_default_instance_;
PROTOBUF_CONSTEXPR CMsgSOCacheUnsubscribed::CMsgSOCacheUnsubscribed(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.owner_soid_)*/nullptr} {}
struct CMsgSOCacheUnsubscribedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSOCacheUnsubscribedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSOCacheUnsubscribedDefaultTypeInternal() {}
  union {
    CMsgSOCacheUnsubscribed _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSOCacheUnsubscribedDefaultTypeInternal _CMsgSOCacheUnsubscribed_default_instance_;
PROTOBUF_CONSTEXPR CMsgSOCacheSubscriptionCheck::CMsgSOCacheSubscriptionCheck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.owner_soid_)*/nullptr
  , /*decltype(_impl_.version_)*/uint64_t{0u}} {}
struct CMsgSOCacheSubscriptionCheckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSOCacheSubscriptionCheckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSOCacheSubscriptionCheckDefaultTypeInternal() {}
  union {
    CMsgSOCacheSubscriptionCheck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSOCacheSubscriptionCheckDefaultTypeInternal _CMsgSOCacheSubscriptionCheck_default_instance_;
PROTOBUF_CONSTEXPR CMsgSOCacheSubscriptionRefresh::CMsgSOCacheSubscriptionRefresh(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.owner_soid_)*/nullptr} {}
struct CMsgSOCacheSubscriptionRefreshDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSOCacheSubscriptionRefreshDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSOCacheSubscriptionRefreshDefaultTypeInternal() {}
  union {
    CMsgSOCacheSubscriptionRefresh _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSOCacheSubscriptionRefreshDefaultTypeInternal _CMsgSOCacheSubscriptionRefresh_default_instance_;
PROTOBUF_CONSTEXPR CMsgSOCacheVersion::CMsgSOCacheVersion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.version_)*/uint64_t{0u}} {}
struct CMsgSOCacheVersionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSOCacheVersionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSOCacheVersionDefaultTypeInternal() {}
  union {
    CMsgSOCacheVersion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSOCacheVersionDefaultTypeInternal _CMsgSOCacheVersion_default_instance_;
PROTOBUF_CONSTEXPR CMsgAccountDetails::CMsgAccountDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.valid_)*/false
  , /*decltype(_impl_.public_profile_)*/false
  , /*decltype(_impl_.public_inventory_)*/false
  , /*decltype(_impl_.vac_banned_)*/false
  , /*decltype(_impl_.cyber_cafe_)*/false
  , /*decltype(_impl_.school_account_)*/false
  , /*decltype(_impl_.free_trial_account_)*/false
  , /*decltype(_impl_.subscribed_)*/false
  , /*decltype(_impl_.low_violence_)*/false
  , /*decltype(_impl_.limited_)*/false
  , /*decltype(_impl_.trusted_)*/false
  , /*decltype(_impl_.account_locked_)*/false
  , /*decltype(_impl_.package_)*/0u
  , /*decltype(_impl_.time_cached_)*/0u
  , /*decltype(_impl_.community_banned_)*/false
  , /*decltype(_impl_.trade_banned_)*/false
  , /*decltype(_impl_.eligible_for_community_market_)*/false} {}
struct CMsgAccountDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgAccountDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgAccountDetailsDefaultTypeInternal() {}
  union {
    CMsgAccountDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgAccountDetailsDefaultTypeInternal _CMsgAccountDetails_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCMultiplexMessage::CMsgGCMultiplexMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.steamids_)*/{}
  , /*decltype(_impl_.payload_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.msgtype_)*/0u
  , /*decltype(_impl_.replytogc_)*/false} {}
struct CMsgGCMultiplexMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCMultiplexMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCMultiplexMessageDefaultTypeInternal() {}
  union {
    CMsgGCMultiplexMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCMultiplexMessageDefaultTypeInternal _CMsgGCMultiplexMessage_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCMultiplexMessage_Response::CMsgGCMultiplexMessage_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.msgtype_)*/0u} {}
struct CMsgGCMultiplexMessage_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCMultiplexMessage_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCMultiplexMessage_ResponseDefaultTypeInternal() {}
  union {
    CMsgGCMultiplexMessage_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCMultiplexMessage_ResponseDefaultTypeInternal _CMsgGCMultiplexMessage_Response_default_instance_;
PROTOBUF_CONSTEXPR CGCToGCMsgMasterAck::CGCToGCMsgMasterAck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dir_index_)*/0u
  , /*decltype(_impl_.gc_type_)*/0u} {}
struct CGCToGCMsgMasterAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCToGCMsgMasterAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCToGCMsgMasterAckDefaultTypeInternal() {}
  union {
    CGCToGCMsgMasterAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCToGCMsgMasterAckDefaultTypeInternal _CGCToGCMsgMasterAck_default_instance_;
PROTOBUF_CONSTEXPR CGCToGCMsgMasterAck_Response::CGCToGCMsgMasterAck_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.eresult_)*/2} {}
struct CGCToGCMsgMasterAck_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCToGCMsgMasterAck_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCToGCMsgMasterAck_ResponseDefaultTypeInternal() {}
  union {
    CGCToGCMsgMasterAck_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCToGCMsgMasterAck_ResponseDefaultTypeInternal _CGCToGCMsgMasterAck_Response_default_instance_;
PROTOBUF_CONSTEXPR CGCToGCMsgMasterStartupComplete::CGCToGCMsgMasterStartupComplete(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct CGCToGCMsgMasterStartupCompleteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCToGCMsgMasterStartupCompleteDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCToGCMsgMasterStartupCompleteDefaultTypeInternal() {}
  union {
    CGCToGCMsgMasterStartupComplete _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCToGCMsgMasterStartupCompleteDefaultTypeInternal _CGCToGCMsgMasterStartupComplete_default_instance_;
PROTOBUF_CONSTEXPR CGCToGCMsgRouted::CGCToGCMsgRouted(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.net_message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sender_id_)*/uint64_t{0u}
  , /*decltype(_impl_.msg_type_)*/0u
  , /*decltype(_impl_.ip_)*/0u} {}
struct CGCToGCMsgRoutedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCToGCMsgRoutedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCToGCMsgRoutedDefaultTypeInternal() {}
  union {
    CGCToGCMsgRouted _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCToGCMsgRoutedDefaultTypeInternal _CGCToGCMsgRouted_default_instance_;
PROTOBUF_CONSTEXPR CGCToGCMsgRoutedReply::CGCToGCMsgRoutedReply(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.net_message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.msg_type_)*/0u} {}
struct CGCToGCMsgRoutedReplyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCToGCMsgRoutedReplyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCToGCMsgRoutedReplyDefaultTypeInternal() {}
  union {
    CGCToGCMsgRoutedReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCToGCMsgRoutedReplyDefaultTypeInternal _CGCToGCMsgRoutedReply_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCUpdateSessionIP::CMsgGCUpdateSessionIP(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.steamid_)*/uint64_t{0u}
  , /*decltype(_impl_.ip_)*/0u} {}
struct CMsgGCUpdateSessionIPDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCUpdateSessionIPDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCUpdateSessionIPDefaultTypeInternal() {}
  union {
    CMsgGCUpdateSessionIP _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCUpdateSessionIPDefaultTypeInternal _CMsgGCUpdateSessionIP_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCRequestSessionIP::CMsgGCRequestSessionIP(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.steamid_)*/uint64_t{0u}} {}
struct CMsgGCRequestSessionIPDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCRequestSessionIPDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCRequestSessionIPDefaultTypeInternal() {}
  union {
    CMsgGCRequestSessionIP _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCRequestSessionIPDefaultTypeInternal _CMsgGCRequestSessionIP_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCRequestSessionIPResponse::CMsgGCRequestSessionIPResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ip_)*/0u} {}
struct CMsgGCRequestSessionIPResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCRequestSessionIPResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCRequestSessionIPResponseDefaultTypeInternal() {}
  union {
    CMsgGCRequestSessionIPResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCRequestSessionIPResponseDefaultTypeInternal _CMsgGCRequestSessionIPResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgSOCacheHaveVersion::CMsgSOCacheHaveVersion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.soid_)*/nullptr
  , /*decltype(_impl_.version_)*/uint64_t{0u}} {}
struct CMsgSOCacheHaveVersionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSOCacheHaveVersionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSOCacheHaveVersionDefaultTypeInternal() {}
  union {
    CMsgSOCacheHaveVersion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSOCacheHaveVersionDefaultTypeInternal _CMsgSOCacheHaveVersion_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientHello::CMsgClientHello(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.socache_have_versions_)*/{}
  , /*decltype(_impl_.version_)*/0u
  , /*decltype(_impl_.client_session_need_)*/0u
  , /*decltype(_impl_.client_launcher_)*/0u
  , /*decltype(_impl_.partner_srcid_)*/0u
  , /*decltype(_impl_.partner_accountid_)*/0u
  , /*decltype(_impl_.partner_accountflags_)*/0u
  , /*decltype(_impl_.partner_accountbalance_)*/0u
  , /*decltype(_impl_.steam_launcher_)*/0u} {}
struct CMsgClientHelloDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientHelloDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientHelloDefaultTypeInternal() {}
  union {
    CMsgClientHello _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientHelloDefaultTypeInternal _CMsgClientHello_default_instance_;
PROTOBUF_CONSTEXPR CMsgServerHello::CMsgServerHello(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.socache_have_versions_)*/{}
  , /*decltype(_impl_.legacy_steamdatagram_routing_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.steamdatagram_login_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_)*/0u
  , /*decltype(_impl_.legacy_client_session_need_)*/0u
  , /*decltype(_impl_.client_launcher_)*/0u
  , /*decltype(_impl_.required_internal_addr_)*/0u} {}
struct CMsgServerHelloDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgServerHelloDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgServerHelloDefaultTypeInternal() {}
  union {
    CMsgServerHello _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgServerHelloDefaultTypeInternal _CMsgServerHello_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientWelcome_Location::CMsgClientWelcome_Location(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.country_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.latitude_)*/0
  , /*decltype(_impl_.longitude_)*/0} {}
struct CMsgClientWelcome_LocationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientWelcome_LocationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientWelcome_LocationDefaultTypeInternal() {}
  union {
    CMsgClientWelcome_Location _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientWelcome_LocationDefaultTypeInternal _CMsgClientWelcome_Location_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientWelcome::CMsgClientWelcome(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.outofdate_subscribed_caches_)*/{}
  , /*decltype(_impl_.uptodate_subscribed_caches_)*/{}
  , /*decltype(_impl_.game_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.game_data2_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.balance_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.txn_country_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.location_)*/nullptr
  , /*decltype(_impl_.version_)*/0u
  , /*decltype(_impl_.rtime32_gc_welcome_timestamp_)*/0u
  , /*decltype(_impl_.currency_)*/0u
  , /*decltype(_impl_.balance_)*/0u} {}
struct CMsgClientWelcomeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientWelcomeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientWelcomeDefaultTypeInternal() {}
  union {
    CMsgClientWelcome _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientWelcomeDefaultTypeInternal _CMsgClientWelcome_default_instance_;
PROTOBUF_CONSTEXPR CMsgConnectionStatus::CMsgConnectionStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.status_)*/0
  , /*decltype(_impl_.client_session_need_)*/0u
  , /*decltype(_impl_.queue_position_)*/0
  , /*decltype(_impl_.queue_size_)*/0
  , /*decltype(_impl_.wait_seconds_)*/0
  , /*decltype(_impl_.estimated_wait_seconds_remaining_)*/0} {}
struct CMsgConnectionStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgConnectionStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgConnectionStatusDefaultTypeInternal() {}
  union {
    CMsgConnectionStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgConnectionStatusDefaultTypeInternal _CMsgConnectionStatus_default_instance_;
PROTOBUF_CONSTEXPR CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.descriptions_)*/{}
  , /*decltype(_impl_.language_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlockDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlockDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlockDefaultTypeInternal() {}
  union {
    CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlockDefaultTypeInternal _CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock_default_instance_;
PROTOBUF_CONSTEXPR CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.item_description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.gameitemid_)*/0u
  , /*decltype(_impl_.one_per_account_)*/false} {}
struct CWorkshop_PopulateItemDescriptions_Request_SingleItemDescriptionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CWorkshop_PopulateItemDescriptions_Request_SingleItemDescriptionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CWorkshop_PopulateItemDescriptions_Request_SingleItemDescriptionDefaultTypeInternal() {}
  union {
    CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CWorkshop_PopulateItemDescriptions_Request_SingleItemDescriptionDefaultTypeInternal _CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription_default_instance_;
PROTOBUF_CONSTEXPR CWorkshop_PopulateItemDescriptions_Request::CWorkshop_PopulateItemDescriptions_Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.languages_)*/{}
  , /*decltype(_impl_.appid_)*/0u} {}
struct CWorkshop_PopulateItemDescriptions_RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CWorkshop_PopulateItemDescriptions_RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CWorkshop_PopulateItemDescriptions_RequestDefaultTypeInternal() {}
  union {
    CWorkshop_PopulateItemDescriptions_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CWorkshop_PopulateItemDescriptions_RequestDefaultTypeInternal _CWorkshop_PopulateItemDescriptions_Request_default_instance_;
PROTOBUF_CONSTEXPR CWorkshop_GetContributors_Request::CWorkshop_GetContributors_Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.appid_)*/0u
  , /*decltype(_impl_.gameitemid_)*/0u} {}
struct CWorkshop_GetContributors_RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CWorkshop_GetContributors_RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CWorkshop_GetContributors_RequestDefaultTypeInternal() {}
  union {
    CWorkshop_GetContributors_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CWorkshop_GetContributors_RequestDefaultTypeInternal _CWorkshop_GetContributors_Request_default_instance_;
PROTOBUF_CONSTEXPR CWorkshop_GetContributors_Response::CWorkshop_GetContributors_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.contributors_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CWorkshop_GetContributors_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CWorkshop_GetContributors_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CWorkshop_GetContributors_ResponseDefaultTypeInternal() {}
  union {
    CWorkshop_GetContributors_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CWorkshop_GetContributors_ResponseDefaultTypeInternal _CWorkshop_GetContributors_Response_default_instance_;
PROTOBUF_CONSTEXPR CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rule_description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.workshop_file_id_)*/uint64_t{0u}
  , /*decltype(_impl_.revenue_percentage_)*/0
  , /*decltype(_impl_.rule_type_)*/1u} {}
struct CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRuleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRuleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRuleDefaultTypeInternal() {}
  union {
    CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRuleDefaultTypeInternal _CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule_default_instance_;
PROTOBUF_CONSTEXPR CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rule_description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.revenue_percentage_)*/0} {}
struct CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRuleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRuleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRuleDefaultTypeInternal() {}
  union {
    CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRuleDefaultTypeInternal _CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule_default_instance_;
PROTOBUF_CONSTEXPR CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rule_description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.workshop_file_id_)*/uint64_t{0u}} {}
struct CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRuleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRuleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRuleDefaultTypeInternal() {}
  union {
    CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRuleDefaultTypeInternal _CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule_default_instance_;
PROTOBUF_CONSTEXPR CWorkshop_SetItemPaymentRules_Request::CWorkshop_SetItemPaymentRules_Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.associated_workshop_files_)*/{}
  , /*decltype(_impl_.partner_accounts_)*/{}
  , /*decltype(_impl_.associated_workshop_file_for_direct_payments_)*/nullptr
  , /*decltype(_impl_.appid_)*/0u
  , /*decltype(_impl_.gameitemid_)*/0u
  , /*decltype(_impl_.validate_only_)*/false
  , /*decltype(_impl_.make_workshop_files_subscribable_)*/false} {}
struct CWorkshop_SetItemPaymentRules_RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CWorkshop_SetItemPaymentRules_RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CWorkshop_SetItemPaymentRules_RequestDefaultTypeInternal() {}
  union {
    CWorkshop_SetItemPaymentRules_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CWorkshop_SetItemPaymentRules_RequestDefaultTypeInternal _CWorkshop_SetItemPaymentRules_Request_default_instance_;
PROTOBUF_CONSTEXPR CWorkshop_SetItemPaymentRules_Response::CWorkshop_SetItemPaymentRules_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct CWorkshop_SetItemPaymentRules_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CWorkshop_SetItemPaymentRules_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CWorkshop_SetItemPaymentRules_ResponseDefaultTypeInternal() {}
  union {
    CWorkshop_SetItemPaymentRules_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CWorkshop_SetItemPaymentRules_ResponseDefaultTypeInternal _CWorkshop_SetItemPaymentRules_Response_default_instance_;
PROTOBUF_CONSTEXPR CGameServers_AggregationQuery_Request::CGameServers_AggregationQuery_Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.group_fields_)*/{}
  , /*decltype(_impl_.filter_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CGameServers_AggregationQuery_RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGameServers_AggregationQuery_RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGameServers_AggregationQuery_RequestDefaultTypeInternal() {}
  union {
    CGameServers_AggregationQuery_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGameServers_AggregationQuery_RequestDefaultTypeInternal _CGameServers_AggregationQuery_Request_default_instance_;
PROTOBUF_CONSTEXPR CGameServers_AggregationQuery_Response_Group::CGameServers_AggregationQuery_Response_Group(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.group_values_)*/{}
  , /*decltype(_impl_.servers_empty_)*/0u
  , /*decltype(_impl_.servers_full_)*/0u
  , /*decltype(_impl_.servers_total_)*/0u
  , /*decltype(_impl_.players_humans_)*/0u
  , /*decltype(_impl_.players_bots_)*/0u
  , /*decltype(_impl_.player_capacity_)*/0u} {}
struct CGameServers_AggregationQuery_Response_GroupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGameServers_AggregationQuery_Response_GroupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGameServers_AggregationQuery_Response_GroupDefaultTypeInternal() {}
  union {
    CGameServers_AggregationQuery_Response_Group _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGameServers_AggregationQuery_Response_GroupDefaultTypeInternal _CGameServers_AggregationQuery_Response_Group_default_instance_;
PROTOBUF_CONSTEXPR CGameServers_AggregationQuery_Response::CGameServers_AggregationQuery_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.groups_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CGameServers_AggregationQuery_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGameServers_AggregationQuery_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGameServers_AggregationQuery_ResponseDefaultTypeInternal() {}
  union {
    CGameServers_AggregationQuery_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGameServers_AggregationQuery_ResponseDefaultTypeInternal _CGameServers_AggregationQuery_Response_default_instance_;
PROTOBUF_CONSTEXPR CWorkshop_AddSpecialPayment_Request::CWorkshop_AddSpecialPayment_Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.date_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.appid_)*/0u
  , /*decltype(_impl_.gameitemid_)*/0u
  , /*decltype(_impl_.payment_us_usd_)*/uint64_t{0u}
  , /*decltype(_impl_.payment_row_usd_)*/uint64_t{0u}} {}
struct CWorkshop_AddSpecialPayment_RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CWorkshop_AddSpecialPayment_RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CWorkshop_AddSpecialPayment_RequestDefaultTypeInternal() {}
  union {
    CWorkshop_AddSpecialPayment_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CWorkshop_AddSpecialPayment_RequestDefaultTypeInternal _CWorkshop_AddSpecialPayment_Request_default_instance_;
PROTOBUF_CONSTEXPR CWorkshop_AddSpecialPayment_Response::CWorkshop_AddSpecialPayment_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct CWorkshop_AddSpecialPayment_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CWorkshop_AddSpecialPayment_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CWorkshop_AddSpecialPayment_ResponseDefaultTypeInternal() {}
  union {
    CWorkshop_AddSpecialPayment_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CWorkshop_AddSpecialPayment_ResponseDefaultTypeInternal _CWorkshop_AddSpecialPayment_Response_default_instance_;
PROTOBUF_CONSTEXPR CProductInfo_SetRichPresenceLocalization_Request_LanguageSection::CProductInfo_SetRichPresenceLocalization_Request_LanguageSection(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tokens_)*/{}
  , /*decltype(_impl_.language_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CProductInfo_SetRichPresenceLocalization_Request_LanguageSectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CProductInfo_SetRichPresenceLocalization_Request_LanguageSectionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CProductInfo_SetRichPresenceLocalization_Request_LanguageSectionDefaultTypeInternal() {}
  union {
    CProductInfo_SetRichPresenceLocalization_Request_LanguageSection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CProductInfo_SetRichPresenceLocalization_Request_LanguageSectionDefaultTypeInternal _CProductInfo_SetRichPresenceLocalization_Request_LanguageSection_default_instance_;
PROTOBUF_CONSTEXPR CProductInfo_SetRichPresenceLocalization_Request_Token::CProductInfo_SetRichPresenceLocalization_Request_Token(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CProductInfo_SetRichPresenceLocalization_Request_TokenDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CProductInfo_SetRichPresenceLocalization_Request_TokenDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CProductInfo_SetRichPresenceLocalization_Request_TokenDefaultTypeInternal() {}
  union {
    CProductInfo_SetRichPresenceLocalization_Request_Token _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CProductInfo_SetRichPresenceLocalization_Request_TokenDefaultTypeInternal _CProductInfo_SetRichPresenceLocalization_Request_Token_default_instance_;
PROTOBUF_CONSTEXPR CProductInfo_SetRichPresenceLocalization_Request::CProductInfo_SetRichPresenceLocalization_Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.languages_)*/{}
  , /*decltype(_impl_.steamid_)*/uint64_t{0u}
  , /*decltype(_impl_.appid_)*/0u} {}
struct CProductInfo_SetRichPresenceLocalization_RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CProductInfo_SetRichPresenceLocalization_RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CProductInfo_SetRichPresenceLocalization_RequestDefaultTypeInternal() {}
  union {
    CProductInfo_SetRichPresenceLocalization_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CProductInfo_SetRichPresenceLocalization_RequestDefaultTypeInternal _CProductInfo_SetRichPresenceLocalization_Request_default_instance_;
PROTOBUF_CONSTEXPR CProductInfo_SetRichPresenceLocalization_Response::CProductInfo_SetRichPresenceLocalization_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct CProductInfo_SetRichPresenceLocalization_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CProductInfo_SetRichPresenceLocalization_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CProductInfo_SetRichPresenceLocalization_ResponseDefaultTypeInternal() {}
  union {
    CProductInfo_SetRichPresenceLocalization_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CProductInfo_SetRichPresenceLocalization_ResponseDefaultTypeInternal _CProductInfo_SetRichPresenceLocalization_Response_default_instance_;
bool GCClientLauncherType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GCClientLauncherType_strings[4] = {};

static const char GCClientLauncherType_names[] =
  "GCClientLauncherType_DEFAULT"
  "GCClientLauncherType_PERFECTWORLD"
  "GCClientLauncherType_SOURCE2"
  "GCClientLauncherType_STEAMCHINA";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GCClientLauncherType_entries[] = {
  { {GCClientLauncherType_names + 0, 28}, 0 },
  { {GCClientLauncherType_names + 28, 33}, 1 },
  { {GCClientLauncherType_names + 61, 28}, 3 },
  { {GCClientLauncherType_names + 89, 31}, 2 },
};

static const int GCClientLauncherType_entries_by_number[] = {
  0, // 0 -> GCClientLauncherType_DEFAULT
  1, // 1 -> GCClientLauncherType_PERFECTWORLD
  3, // 2 -> GCClientLauncherType_STEAMCHINA
  2, // 3 -> GCClientLauncherType_SOURCE2
};

const std::string& GCClientLauncherType_Name(
    GCClientLauncherType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GCClientLauncherType_entries,
          GCClientLauncherType_entries_by_number,
          4, GCClientLauncherType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GCClientLauncherType_entries,
      GCClientLauncherType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GCClientLauncherType_strings[idx].get();
}
bool GCClientLauncherType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GCClientLauncherType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GCClientLauncherType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<GCClientLauncherType>(int_value);
  }
  return success;
}
bool GCConnectionStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GCConnectionStatus_strings[5] = {};

static const char GCConnectionStatus_names[] =
  "GCConnectionStatus_GC_GOING_DOWN"
  "GCConnectionStatus_HAVE_SESSION"
  "GCConnectionStatus_NO_SESSION"
  "GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE"
  "GCConnectionStatus_NO_STEAM";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GCConnectionStatus_entries[] = {
  { {GCConnectionStatus_names + 0, 32}, 1 },
  { {GCConnectionStatus_names + 32, 31}, 0 },
  { {GCConnectionStatus_names + 63, 29}, 2 },
  { {GCConnectionStatus_names + 92, 44}, 3 },
  { {GCConnectionStatus_names + 136, 27}, 4 },
};

static const int GCConnectionStatus_entries_by_number[] = {
  1, // 0 -> GCConnectionStatus_HAVE_SESSION
  0, // 1 -> GCConnectionStatus_GC_GOING_DOWN
  2, // 2 -> GCConnectionStatus_NO_SESSION
  3, // 3 -> GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE
  4, // 4 -> GCConnectionStatus_NO_STEAM
};

const std::string& GCConnectionStatus_Name(
    GCConnectionStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GCConnectionStatus_entries,
          GCConnectionStatus_entries_by_number,
          5, GCConnectionStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GCConnectionStatus_entries,
      GCConnectionStatus_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GCConnectionStatus_strings[idx].get();
}
bool GCConnectionStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GCConnectionStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GCConnectionStatus_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<GCConnectionStatus>(int_value);
  }
  return success;
}

// ===================================================================

class CMsgSOIDOwner::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSOIDOwner>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSOIDOwner::CMsgSOIDOwner(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSOIDOwner)
}
CMsgSOIDOwner::CMsgSOIDOwner(const CMsgSOIDOwner& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgSOIDOwner* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:CMsgSOIDOwner)
}

inline void CMsgSOIDOwner::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_.type_){0u}
  };
}

CMsgSOIDOwner::~CMsgSOIDOwner() {
  // @@protoc_insertion_point(destructor:CMsgSOIDOwner)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSOIDOwner::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSOIDOwner::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSOIDOwner::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSOIDOwner)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgSOIDOwner::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSOIDOwner::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSOIDOwner)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
  }

  // optional uint64 id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSOIDOwner)
  return target;
}

size_t CMsgSOIDOwner::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSOIDOwner)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
    }

    // optional uint32 type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgSOIDOwner::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgSOIDOwner*>(
      &from));
}

void CMsgSOIDOwner::MergeFrom(const CMsgSOIDOwner& from) {
  CMsgSOIDOwner* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSOIDOwner)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgSOIDOwner::CopyFrom(const CMsgSOIDOwner& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSOIDOwner)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSOIDOwner::IsInitialized() const {
  return true;
}

void CMsgSOIDOwner::InternalSwap(CMsgSOIDOwner* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSOIDOwner, _impl_.type_)
      + sizeof(CMsgSOIDOwner::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(CMsgSOIDOwner, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

std::string CMsgSOIDOwner::GetTypeName() const {
  return "CMsgSOIDOwner";
}


// ===================================================================

class CMsgSOSingleObject::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSOSingleObject>()._impl_._has_bits_);
  static void set_has_type_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_object_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgSOIDOwner& owner_soid(const CMsgSOSingleObject* msg);
  static void set_has_owner_soid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgSOIDOwner&
CMsgSOSingleObject::_Internal::owner_soid(const CMsgSOSingleObject* msg) {
  return *msg->_impl_.owner_soid_;
}
CMsgSOSingleObject::CMsgSOSingleObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSOSingleObject)
}
CMsgSOSingleObject::CMsgSOSingleObject(const CMsgSOSingleObject& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgSOSingleObject* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_data_){}
    , decltype(_impl_.owner_soid_){nullptr}
    , decltype(_impl_.version_){}
    , decltype(_impl_.type_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.object_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.object_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_object_data()) {
    _this->_impl_.object_data_.Set(from._internal_object_data(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_owner_soid()) {
    _this->_impl_.owner_soid_ = new ::CMsgSOIDOwner(*from._impl_.owner_soid_);
  }
  ::memcpy(&_impl_.version_, &from._impl_.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_id_) -
    reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.type_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgSOSingleObject)
}

inline void CMsgSOSingleObject::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_data_){}
    , decltype(_impl_.owner_soid_){nullptr}
    , decltype(_impl_.version_){uint64_t{0u}}
    , decltype(_impl_.type_id_){0}
  };
  _impl_.object_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.object_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSOSingleObject::~CMsgSOSingleObject() {
  // @@protoc_insertion_point(destructor:CMsgSOSingleObject)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSOSingleObject::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.object_data_.Destroy();
  if (this != internal_default_instance()) delete _impl_.owner_soid_;
}

void CMsgSOSingleObject::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSOSingleObject::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSOSingleObject)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.object_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.owner_soid_ != nullptr);
      _impl_.owner_soid_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_id_) -
        reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.type_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgSOSingleObject::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 type_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_type_id(&has_bits);
          _impl_.type_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes object_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_object_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 version = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSOIDOwner owner_soid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner_soid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSOSingleObject::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSOSingleObject)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 type_id = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_type_id(), target);
  }

  // optional bytes object_data = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_object_data(), target);
  }

  // optional fixed64 version = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(4, this->_internal_version(), target);
  }

  // optional .CMsgSOIDOwner owner_soid = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::owner_soid(this),
        _Internal::owner_soid(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSOSingleObject)
  return target;
}

size_t CMsgSOSingleObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSOSingleObject)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes object_data = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_object_data());
    }

    // optional .CMsgSOIDOwner owner_soid = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.owner_soid_);
    }

    // optional fixed64 version = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional int32 type_id = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgSOSingleObject::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgSOSingleObject*>(
      &from));
}

void CMsgSOSingleObject::MergeFrom(const CMsgSOSingleObject& from) {
  CMsgSOSingleObject* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSOSingleObject)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_object_data(from._internal_object_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_owner_soid()->::CMsgSOIDOwner::MergeFrom(
          from._internal_owner_soid());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.type_id_ = from._impl_.type_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgSOSingleObject::CopyFrom(const CMsgSOSingleObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSOSingleObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSOSingleObject::IsInitialized() const {
  return true;
}

void CMsgSOSingleObject::InternalSwap(CMsgSOSingleObject* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.object_data_, lhs_arena,
      &other->_impl_.object_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSOSingleObject, _impl_.type_id_)
      + sizeof(CMsgSOSingleObject::_impl_.type_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgSOSingleObject, _impl_.owner_soid_)>(
          reinterpret_cast<char*>(&_impl_.owner_soid_),
          reinterpret_cast<char*>(&other->_impl_.owner_soid_));
}

std::string CMsgSOSingleObject::GetTypeName() const {
  return "CMsgSOSingleObject";
}


// ===================================================================

class CMsgSOMultipleObjects_SingleObject::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSOMultipleObjects_SingleObject>()._impl_._has_bits_);
  static void set_has_type_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_object_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSOMultipleObjects_SingleObject::CMsgSOMultipleObjects_SingleObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSOMultipleObjects.SingleObject)
}
CMsgSOMultipleObjects_SingleObject::CMsgSOMultipleObjects_SingleObject(const CMsgSOMultipleObjects_SingleObject& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgSOMultipleObjects_SingleObject* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_data_){}
    , decltype(_impl_.type_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.object_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.object_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_object_data()) {
    _this->_impl_.object_data_.Set(from._internal_object_data(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.type_id_ = from._impl_.type_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgSOMultipleObjects.SingleObject)
}

inline void CMsgSOMultipleObjects_SingleObject::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_data_){}
    , decltype(_impl_.type_id_){0}
  };
  _impl_.object_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.object_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSOMultipleObjects_SingleObject::~CMsgSOMultipleObjects_SingleObject() {
  // @@protoc_insertion_point(destructor:CMsgSOMultipleObjects.SingleObject)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSOMultipleObjects_SingleObject::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.object_data_.Destroy();
}

void CMsgSOMultipleObjects_SingleObject::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSOMultipleObjects_SingleObject::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSOMultipleObjects.SingleObject)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.object_data_.ClearNonDefaultToEmpty();
  }
  _impl_.type_id_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgSOMultipleObjects_SingleObject::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 type_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type_id(&has_bits);
          _impl_.type_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes object_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_object_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSOMultipleObjects_SingleObject::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSOMultipleObjects.SingleObject)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 type_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_type_id(), target);
  }

  // optional bytes object_data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_object_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSOMultipleObjects.SingleObject)
  return target;
}

size_t CMsgSOMultipleObjects_SingleObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSOMultipleObjects.SingleObject)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes object_data = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_object_data());
    }

    // optional int32 type_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgSOMultipleObjects_SingleObject::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgSOMultipleObjects_SingleObject*>(
      &from));
}

void CMsgSOMultipleObjects_SingleObject::MergeFrom(const CMsgSOMultipleObjects_SingleObject& from) {
  CMsgSOMultipleObjects_SingleObject* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSOMultipleObjects.SingleObject)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_object_data(from._internal_object_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_id_ = from._impl_.type_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgSOMultipleObjects_SingleObject::CopyFrom(const CMsgSOMultipleObjects_SingleObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSOMultipleObjects.SingleObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSOMultipleObjects_SingleObject::IsInitialized() const {
  return true;
}

void CMsgSOMultipleObjects_SingleObject::InternalSwap(CMsgSOMultipleObjects_SingleObject* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.object_data_, lhs_arena,
      &other->_impl_.object_data_, rhs_arena
  );
  swap(_impl_.type_id_, other->_impl_.type_id_);
}

std::string CMsgSOMultipleObjects_SingleObject::GetTypeName() const {
  return "CMsgSOMultipleObjects.SingleObject";
}


// ===================================================================

class CMsgSOMultipleObjects::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSOMultipleObjects>()._impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgSOIDOwner& owner_soid(const CMsgSOMultipleObjects* msg);
  static void set_has_owner_soid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgSOIDOwner&
CMsgSOMultipleObjects::_Internal::owner_soid(const CMsgSOMultipleObjects* msg) {
  return *msg->_impl_.owner_soid_;
}
CMsgSOMultipleObjects::CMsgSOMultipleObjects(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSOMultipleObjects)
}
CMsgSOMultipleObjects::CMsgSOMultipleObjects(const CMsgSOMultipleObjects& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgSOMultipleObjects* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.objects_modified_){from._impl_.objects_modified_}
    , decltype(_impl_.owner_soid_){nullptr}
    , decltype(_impl_.version_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_owner_soid()) {
    _this->_impl_.owner_soid_ = new ::CMsgSOIDOwner(*from._impl_.owner_soid_);
  }
  _this->_impl_.version_ = from._impl_.version_;
  // @@protoc_insertion_point(copy_constructor:CMsgSOMultipleObjects)
}

inline void CMsgSOMultipleObjects::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.objects_modified_){arena}
    , decltype(_impl_.owner_soid_){nullptr}
    , decltype(_impl_.version_){uint64_t{0u}}
  };
}

CMsgSOMultipleObjects::~CMsgSOMultipleObjects() {
  // @@protoc_insertion_point(destructor:CMsgSOMultipleObjects)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSOMultipleObjects::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.objects_modified_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.owner_soid_;
}

void CMsgSOMultipleObjects::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSOMultipleObjects::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSOMultipleObjects)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.objects_modified_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.owner_soid_ != nullptr);
    _impl_.owner_soid_->Clear();
  }
  _impl_.version_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgSOMultipleObjects::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgSOMultipleObjects.SingleObject objects_modified = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_objects_modified(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSOIDOwner owner_soid = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner_soid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSOMultipleObjects::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSOMultipleObjects)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgSOMultipleObjects.SingleObject objects_modified = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_objects_modified_size()); i < n; i++) {
    const auto& repfield = this->_internal_objects_modified(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 version = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(3, this->_internal_version(), target);
  }

  // optional .CMsgSOIDOwner owner_soid = 6;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::owner_soid(this),
        _Internal::owner_soid(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSOMultipleObjects)
  return target;
}

size_t CMsgSOMultipleObjects::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSOMultipleObjects)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgSOMultipleObjects.SingleObject objects_modified = 2;
  total_size += 1UL * this->_internal_objects_modified_size();
  for (const auto& msg : this->_impl_.objects_modified_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgSOIDOwner owner_soid = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.owner_soid_);
    }

    // optional fixed64 version = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgSOMultipleObjects::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgSOMultipleObjects*>(
      &from));
}

void CMsgSOMultipleObjects::MergeFrom(const CMsgSOMultipleObjects& from) {
  CMsgSOMultipleObjects* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSOMultipleObjects)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.objects_modified_.MergeFrom(from._impl_.objects_modified_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_owner_soid()->::CMsgSOIDOwner::MergeFrom(
          from._internal_owner_soid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgSOMultipleObjects::CopyFrom(const CMsgSOMultipleObjects& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSOMultipleObjects)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSOMultipleObjects::IsInitialized() const {
  return true;
}

void CMsgSOMultipleObjects::InternalSwap(CMsgSOMultipleObjects* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.objects_modified_.InternalSwap(&other->_impl_.objects_modified_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSOMultipleObjects, _impl_.version_)
      + sizeof(CMsgSOMultipleObjects::_impl_.version_)
      - PROTOBUF_FIELD_OFFSET(CMsgSOMultipleObjects, _impl_.owner_soid_)>(
          reinterpret_cast<char*>(&_impl_.owner_soid_),
          reinterpret_cast<char*>(&other->_impl_.owner_soid_));
}

std::string CMsgSOMultipleObjects::GetTypeName() const {
  return "CMsgSOMultipleObjects";
}


// ===================================================================

class CMsgSOCacheSubscribed_SubscribedType::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSOCacheSubscribed_SubscribedType>()._impl_._has_bits_);
  static void set_has_type_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSOCacheSubscribed_SubscribedType::CMsgSOCacheSubscribed_SubscribedType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSOCacheSubscribed.SubscribedType)
}
CMsgSOCacheSubscribed_SubscribedType::CMsgSOCacheSubscribed_SubscribedType(const CMsgSOCacheSubscribed_SubscribedType& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgSOCacheSubscribed_SubscribedType* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_data_){from._impl_.object_data_}
    , decltype(_impl_.type_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.type_id_ = from._impl_.type_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgSOCacheSubscribed.SubscribedType)
}

inline void CMsgSOCacheSubscribed_SubscribedType::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_data_){arena}
    , decltype(_impl_.type_id_){0}
  };
}

CMsgSOCacheSubscribed_SubscribedType::~CMsgSOCacheSubscribed_SubscribedType() {
  // @@protoc_insertion_point(destructor:CMsgSOCacheSubscribed.SubscribedType)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSOCacheSubscribed_SubscribedType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.object_data_.~RepeatedPtrField();
}

void CMsgSOCacheSubscribed_SubscribedType::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSOCacheSubscribed_SubscribedType::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSOCacheSubscribed.SubscribedType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.object_data_.Clear();
  _impl_.type_id_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgSOCacheSubscribed_SubscribedType::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 type_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type_id(&has_bits);
          _impl_.type_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes object_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_object_data();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSOCacheSubscribed_SubscribedType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSOCacheSubscribed.SubscribedType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 type_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_type_id(), target);
  }

  // repeated bytes object_data = 2;
  for (int i = 0, n = this->_internal_object_data_size(); i < n; i++) {
    const auto& s = this->_internal_object_data(i);
    target = stream->WriteBytes(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSOCacheSubscribed.SubscribedType)
  return target;
}

size_t CMsgSOCacheSubscribed_SubscribedType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSOCacheSubscribed.SubscribedType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes object_data = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.object_data_.size());
  for (int i = 0, n = _impl_.object_data_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.object_data_.Get(i));
  }

  // optional int32 type_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgSOCacheSubscribed_SubscribedType::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgSOCacheSubscribed_SubscribedType*>(
      &from));
}

void CMsgSOCacheSubscribed_SubscribedType::MergeFrom(const CMsgSOCacheSubscribed_SubscribedType& from) {
  CMsgSOCacheSubscribed_SubscribedType* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSOCacheSubscribed.SubscribedType)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.object_data_.MergeFrom(from._impl_.object_data_);
  if (from._internal_has_type_id()) {
    _this->_internal_set_type_id(from._internal_type_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgSOCacheSubscribed_SubscribedType::CopyFrom(const CMsgSOCacheSubscribed_SubscribedType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSOCacheSubscribed.SubscribedType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSOCacheSubscribed_SubscribedType::IsInitialized() const {
  return true;
}

void CMsgSOCacheSubscribed_SubscribedType::InternalSwap(CMsgSOCacheSubscribed_SubscribedType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.object_data_.InternalSwap(&other->_impl_.object_data_);
  swap(_impl_.type_id_, other->_impl_.type_id_);
}

std::string CMsgSOCacheSubscribed_SubscribedType::GetTypeName() const {
  return "CMsgSOCacheSubscribed.SubscribedType";
}


// ===================================================================

class CMsgSOCacheSubscribed::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSOCacheSubscribed>()._impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgSOIDOwner& owner_soid(const CMsgSOCacheSubscribed* msg);
  static void set_has_owner_soid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgSOIDOwner&
CMsgSOCacheSubscribed::_Internal::owner_soid(const CMsgSOCacheSubscribed* msg) {
  return *msg->_impl_.owner_soid_;
}
CMsgSOCacheSubscribed::CMsgSOCacheSubscribed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSOCacheSubscribed)
}
CMsgSOCacheSubscribed::CMsgSOCacheSubscribed(const CMsgSOCacheSubscribed& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgSOCacheSubscribed* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.objects_){from._impl_.objects_}
    , decltype(_impl_.owner_soid_){nullptr}
    , decltype(_impl_.version_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_owner_soid()) {
    _this->_impl_.owner_soid_ = new ::CMsgSOIDOwner(*from._impl_.owner_soid_);
  }
  _this->_impl_.version_ = from._impl_.version_;
  // @@protoc_insertion_point(copy_constructor:CMsgSOCacheSubscribed)
}

inline void CMsgSOCacheSubscribed::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.objects_){arena}
    , decltype(_impl_.owner_soid_){nullptr}
    , decltype(_impl_.version_){uint64_t{0u}}
  };
}

CMsgSOCacheSubscribed::~CMsgSOCacheSubscribed() {
  // @@protoc_insertion_point(destructor:CMsgSOCacheSubscribed)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSOCacheSubscribed::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.objects_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.owner_soid_;
}

void CMsgSOCacheSubscribed::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSOCacheSubscribed::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSOCacheSubscribed)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.objects_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.owner_soid_ != nullptr);
    _impl_.owner_soid_->Clear();
  }
  _impl_.version_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgSOCacheSubscribed::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgSOCacheSubscribed.SubscribedType objects = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_objects(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSOIDOwner owner_soid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner_soid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSOCacheSubscribed::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSOCacheSubscribed)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgSOCacheSubscribed.SubscribedType objects = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_objects_size()); i < n; i++) {
    const auto& repfield = this->_internal_objects(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 version = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(3, this->_internal_version(), target);
  }

  // optional .CMsgSOIDOwner owner_soid = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::owner_soid(this),
        _Internal::owner_soid(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSOCacheSubscribed)
  return target;
}

size_t CMsgSOCacheSubscribed::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSOCacheSubscribed)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgSOCacheSubscribed.SubscribedType objects = 2;
  total_size += 1UL * this->_internal_objects_size();
  for (const auto& msg : this->_impl_.objects_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgSOIDOwner owner_soid = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.owner_soid_);
    }

    // optional fixed64 version = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgSOCacheSubscribed::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgSOCacheSubscribed*>(
      &from));
}

void CMsgSOCacheSubscribed::MergeFrom(const CMsgSOCacheSubscribed& from) {
  CMsgSOCacheSubscribed* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSOCacheSubscribed)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.objects_.MergeFrom(from._impl_.objects_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_owner_soid()->::CMsgSOIDOwner::MergeFrom(
          from._internal_owner_soid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgSOCacheSubscribed::CopyFrom(const CMsgSOCacheSubscribed& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSOCacheSubscribed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSOCacheSubscribed::IsInitialized() const {
  return true;
}

void CMsgSOCacheSubscribed::InternalSwap(CMsgSOCacheSubscribed* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.objects_.InternalSwap(&other->_impl_.objects_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSOCacheSubscribed, _impl_.version_)
      + sizeof(CMsgSOCacheSubscribed::_impl_.version_)
      - PROTOBUF_FIELD_OFFSET(CMsgSOCacheSubscribed, _impl_.owner_soid_)>(
          reinterpret_cast<char*>(&_impl_.owner_soid_),
          reinterpret_cast<char*>(&other->_impl_.owner_soid_));
}

std::string CMsgSOCacheSubscribed::GetTypeName() const {
  return "CMsgSOCacheSubscribed";
}


// ===================================================================

class CMsgSOCacheUnsubscribed::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSOCacheUnsubscribed>()._impl_._has_bits_);
  static const ::CMsgSOIDOwner& owner_soid(const CMsgSOCacheUnsubscribed* msg);
  static void set_has_owner_soid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgSOIDOwner&
CMsgSOCacheUnsubscribed::_Internal::owner_soid(const CMsgSOCacheUnsubscribed* msg) {
  return *msg->_impl_.owner_soid_;
}
CMsgSOCacheUnsubscribed::CMsgSOCacheUnsubscribed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSOCacheUnsubscribed)
}
CMsgSOCacheUnsubscribed::CMsgSOCacheUnsubscribed(const CMsgSOCacheUnsubscribed& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgSOCacheUnsubscribed* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.owner_soid_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_owner_soid()) {
    _this->_impl_.owner_soid_ = new ::CMsgSOIDOwner(*from._impl_.owner_soid_);
  }
  // @@protoc_insertion_point(copy_constructor:CMsgSOCacheUnsubscribed)
}

inline void CMsgSOCacheUnsubscribed::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.owner_soid_){nullptr}
  };
}

CMsgSOCacheUnsubscribed::~CMsgSOCacheUnsubscribed() {
  // @@protoc_insertion_point(destructor:CMsgSOCacheUnsubscribed)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSOCacheUnsubscribed::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.owner_soid_;
}

void CMsgSOCacheUnsubscribed::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSOCacheUnsubscribed::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSOCacheUnsubscribed)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.owner_soid_ != nullptr);
    _impl_.owner_soid_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgSOCacheUnsubscribed::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgSOIDOwner owner_soid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner_soid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSOCacheUnsubscribed::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSOCacheUnsubscribed)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgSOIDOwner owner_soid = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::owner_soid(this),
        _Internal::owner_soid(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSOCacheUnsubscribed)
  return target;
}

size_t CMsgSOCacheUnsubscribed::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSOCacheUnsubscribed)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CMsgSOIDOwner owner_soid = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.owner_soid_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgSOCacheUnsubscribed::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgSOCacheUnsubscribed*>(
      &from));
}

void CMsgSOCacheUnsubscribed::MergeFrom(const CMsgSOCacheUnsubscribed& from) {
  CMsgSOCacheUnsubscribed* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSOCacheUnsubscribed)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_owner_soid()) {
    _this->_internal_mutable_owner_soid()->::CMsgSOIDOwner::MergeFrom(
        from._internal_owner_soid());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgSOCacheUnsubscribed::CopyFrom(const CMsgSOCacheUnsubscribed& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSOCacheUnsubscribed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSOCacheUnsubscribed::IsInitialized() const {
  return true;
}

void CMsgSOCacheUnsubscribed::InternalSwap(CMsgSOCacheUnsubscribed* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.owner_soid_, other->_impl_.owner_soid_);
}

std::string CMsgSOCacheUnsubscribed::GetTypeName() const {
  return "CMsgSOCacheUnsubscribed";
}


// ===================================================================

class CMsgSOCacheSubscriptionCheck::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSOCacheSubscriptionCheck>()._impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgSOIDOwner& owner_soid(const CMsgSOCacheSubscriptionCheck* msg);
  static void set_has_owner_soid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgSOIDOwner&
CMsgSOCacheSubscriptionCheck::_Internal::owner_soid(const CMsgSOCacheSubscriptionCheck* msg) {
  return *msg->_impl_.owner_soid_;
}
CMsgSOCacheSubscriptionCheck::CMsgSOCacheSubscriptionCheck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSOCacheSubscriptionCheck)
}
CMsgSOCacheSubscriptionCheck::CMsgSOCacheSubscriptionCheck(const CMsgSOCacheSubscriptionCheck& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgSOCacheSubscriptionCheck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.owner_soid_){nullptr}
    , decltype(_impl_.version_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_owner_soid()) {
    _this->_impl_.owner_soid_ = new ::CMsgSOIDOwner(*from._impl_.owner_soid_);
  }
  _this->_impl_.version_ = from._impl_.version_;
  // @@protoc_insertion_point(copy_constructor:CMsgSOCacheSubscriptionCheck)
}

inline void CMsgSOCacheSubscriptionCheck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.owner_soid_){nullptr}
    , decltype(_impl_.version_){uint64_t{0u}}
  };
}

CMsgSOCacheSubscriptionCheck::~CMsgSOCacheSubscriptionCheck() {
  // @@protoc_insertion_point(destructor:CMsgSOCacheSubscriptionCheck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSOCacheSubscriptionCheck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.owner_soid_;
}

void CMsgSOCacheSubscriptionCheck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSOCacheSubscriptionCheck::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSOCacheSubscriptionCheck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.owner_soid_ != nullptr);
    _impl_.owner_soid_->Clear();
  }
  _impl_.version_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgSOCacheSubscriptionCheck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSOIDOwner owner_soid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner_soid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSOCacheSubscriptionCheck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSOCacheSubscriptionCheck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_version(), target);
  }

  // optional .CMsgSOIDOwner owner_soid = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::owner_soid(this),
        _Internal::owner_soid(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSOCacheSubscriptionCheck)
  return target;
}

size_t CMsgSOCacheSubscriptionCheck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSOCacheSubscriptionCheck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgSOIDOwner owner_soid = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.owner_soid_);
    }

    // optional fixed64 version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgSOCacheSubscriptionCheck::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgSOCacheSubscriptionCheck*>(
      &from));
}

void CMsgSOCacheSubscriptionCheck::MergeFrom(const CMsgSOCacheSubscriptionCheck& from) {
  CMsgSOCacheSubscriptionCheck* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSOCacheSubscriptionCheck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_owner_soid()->::CMsgSOIDOwner::MergeFrom(
          from._internal_owner_soid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgSOCacheSubscriptionCheck::CopyFrom(const CMsgSOCacheSubscriptionCheck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSOCacheSubscriptionCheck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSOCacheSubscriptionCheck::IsInitialized() const {
  return true;
}

void CMsgSOCacheSubscriptionCheck::InternalSwap(CMsgSOCacheSubscriptionCheck* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSOCacheSubscriptionCheck, _impl_.version_)
      + sizeof(CMsgSOCacheSubscriptionCheck::_impl_.version_)
      - PROTOBUF_FIELD_OFFSET(CMsgSOCacheSubscriptionCheck, _impl_.owner_soid_)>(
          reinterpret_cast<char*>(&_impl_.owner_soid_),
          reinterpret_cast<char*>(&other->_impl_.owner_soid_));
}

std::string CMsgSOCacheSubscriptionCheck::GetTypeName() const {
  return "CMsgSOCacheSubscriptionCheck";
}


// ===================================================================

class CMsgSOCacheSubscriptionRefresh::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSOCacheSubscriptionRefresh>()._impl_._has_bits_);
  static const ::CMsgSOIDOwner& owner_soid(const CMsgSOCacheSubscriptionRefresh* msg);
  static void set_has_owner_soid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgSOIDOwner&
CMsgSOCacheSubscriptionRefresh::_Internal::owner_soid(const CMsgSOCacheSubscriptionRefresh* msg) {
  return *msg->_impl_.owner_soid_;
}
CMsgSOCacheSubscriptionRefresh::CMsgSOCacheSubscriptionRefresh(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSOCacheSubscriptionRefresh)
}
CMsgSOCacheSubscriptionRefresh::CMsgSOCacheSubscriptionRefresh(const CMsgSOCacheSubscriptionRefresh& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgSOCacheSubscriptionRefresh* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.owner_soid_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_owner_soid()) {
    _this->_impl_.owner_soid_ = new ::CMsgSOIDOwner(*from._impl_.owner_soid_);
  }
  // @@protoc_insertion_point(copy_constructor:CMsgSOCacheSubscriptionRefresh)
}

inline void CMsgSOCacheSubscriptionRefresh::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.owner_soid_){nullptr}
  };
}

CMsgSOCacheSubscriptionRefresh::~CMsgSOCacheSubscriptionRefresh() {
  // @@protoc_insertion_point(destructor:CMsgSOCacheSubscriptionRefresh)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSOCacheSubscriptionRefresh::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.owner_soid_;
}

void CMsgSOCacheSubscriptionRefresh::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSOCacheSubscriptionRefresh::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSOCacheSubscriptionRefresh)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.owner_soid_ != nullptr);
    _impl_.owner_soid_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgSOCacheSubscriptionRefresh::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgSOIDOwner owner_soid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner_soid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSOCacheSubscriptionRefresh::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSOCacheSubscriptionRefresh)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgSOIDOwner owner_soid = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::owner_soid(this),
        _Internal::owner_soid(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSOCacheSubscriptionRefresh)
  return target;
}

size_t CMsgSOCacheSubscriptionRefresh::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSOCacheSubscriptionRefresh)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CMsgSOIDOwner owner_soid = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.owner_soid_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgSOCacheSubscriptionRefresh::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgSOCacheSubscriptionRefresh*>(
      &from));
}

void CMsgSOCacheSubscriptionRefresh::MergeFrom(const CMsgSOCacheSubscriptionRefresh& from) {
  CMsgSOCacheSubscriptionRefresh* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSOCacheSubscriptionRefresh)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_owner_soid()) {
    _this->_internal_mutable_owner_soid()->::CMsgSOIDOwner::MergeFrom(
        from._internal_owner_soid());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgSOCacheSubscriptionRefresh::CopyFrom(const CMsgSOCacheSubscriptionRefresh& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSOCacheSubscriptionRefresh)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSOCacheSubscriptionRefresh::IsInitialized() const {
  return true;
}

void CMsgSOCacheSubscriptionRefresh::InternalSwap(CMsgSOCacheSubscriptionRefresh* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.owner_soid_, other->_impl_.owner_soid_);
}

std::string CMsgSOCacheSubscriptionRefresh::GetTypeName() const {
  return "CMsgSOCacheSubscriptionRefresh";
}


// ===================================================================

class CMsgSOCacheVersion::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSOCacheVersion>()._impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSOCacheVersion::CMsgSOCacheVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSOCacheVersion)
}
CMsgSOCacheVersion::CMsgSOCacheVersion(const CMsgSOCacheVersion& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgSOCacheVersion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.version_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.version_ = from._impl_.version_;
  // @@protoc_insertion_point(copy_constructor:CMsgSOCacheVersion)
}

inline void CMsgSOCacheVersion::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.version_){uint64_t{0u}}
  };
}

CMsgSOCacheVersion::~CMsgSOCacheVersion() {
  // @@protoc_insertion_point(destructor:CMsgSOCacheVersion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSOCacheVersion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSOCacheVersion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSOCacheVersion::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSOCacheVersion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.version_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgSOCacheVersion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSOCacheVersion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSOCacheVersion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSOCacheVersion)
  return target;
}

size_t CMsgSOCacheVersion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSOCacheVersion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional fixed64 version = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 8;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgSOCacheVersion::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgSOCacheVersion*>(
      &from));
}

void CMsgSOCacheVersion::MergeFrom(const CMsgSOCacheVersion& from) {
  CMsgSOCacheVersion* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSOCacheVersion)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_version()) {
    _this->_internal_set_version(from._internal_version());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgSOCacheVersion::CopyFrom(const CMsgSOCacheVersion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSOCacheVersion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSOCacheVersion::IsInitialized() const {
  return true;
}

void CMsgSOCacheVersion::InternalSwap(CMsgSOCacheVersion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.version_, other->_impl_.version_);
}

std::string CMsgSOCacheVersion::GetTypeName() const {
  return "CMsgSOCacheVersion";
}


// ===================================================================

class CMsgAccountDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgAccountDetails>()._impl_._has_bits_);
  static void set_has_valid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_account_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_public_profile(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_public_inventory(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_vac_banned(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_cyber_cafe(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_school_account(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_free_trial_account(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_subscribed(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_low_violence(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_limited(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_trusted(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_package(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_time_cached(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_account_locked(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_community_banned(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_trade_banned(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_eligible_for_community_market(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
};

CMsgAccountDetails::CMsgAccountDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgAccountDetails)
}
CMsgAccountDetails::CMsgAccountDetails(const CMsgAccountDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgAccountDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_name_){}
    , decltype(_impl_.valid_){}
    , decltype(_impl_.public_profile_){}
    , decltype(_impl_.public_inventory_){}
    , decltype(_impl_.vac_banned_){}
    , decltype(_impl_.cyber_cafe_){}
    , decltype(_impl_.school_account_){}
    , decltype(_impl_.free_trial_account_){}
    , decltype(_impl_.subscribed_){}
    , decltype(_impl_.low_violence_){}
    , decltype(_impl_.limited_){}
    , decltype(_impl_.trusted_){}
    , decltype(_impl_.account_locked_){}
    , decltype(_impl_.package_){}
    , decltype(_impl_.time_cached_){}
    , decltype(_impl_.community_banned_){}
    , decltype(_impl_.trade_banned_){}
    , decltype(_impl_.eligible_for_community_market_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.account_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_account_name()) {
    _this->_impl_.account_name_.Set(from._internal_account_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.valid_, &from._impl_.valid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.eligible_for_community_market_) -
    reinterpret_cast<char*>(&_impl_.valid_)) + sizeof(_impl_.eligible_for_community_market_));
  // @@protoc_insertion_point(copy_constructor:CMsgAccountDetails)
}

inline void CMsgAccountDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_name_){}
    , decltype(_impl_.valid_){false}
    , decltype(_impl_.public_profile_){false}
    , decltype(_impl_.public_inventory_){false}
    , decltype(_impl_.vac_banned_){false}
    , decltype(_impl_.cyber_cafe_){false}
    , decltype(_impl_.school_account_){false}
    , decltype(_impl_.free_trial_account_){false}
    , decltype(_impl_.subscribed_){false}
    , decltype(_impl_.low_violence_){false}
    , decltype(_impl_.limited_){false}
    , decltype(_impl_.trusted_){false}
    , decltype(_impl_.account_locked_){false}
    , decltype(_impl_.package_){0u}
    , decltype(_impl_.time_cached_){0u}
    , decltype(_impl_.community_banned_){false}
    , decltype(_impl_.trade_banned_){false}
    , decltype(_impl_.eligible_for_community_market_){false}
  };
  _impl_.account_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgAccountDetails::~CMsgAccountDetails() {
  // @@protoc_insertion_point(destructor:CMsgAccountDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgAccountDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_name_.Destroy();
}

void CMsgAccountDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgAccountDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgAccountDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.account_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.valid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.free_trial_account_) -
        reinterpret_cast<char*>(&_impl_.valid_)) + sizeof(_impl_.free_trial_account_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.subscribed_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.community_banned_) -
        reinterpret_cast<char*>(&_impl_.subscribed_)) + sizeof(_impl_.community_banned_));
  }
  if (cached_has_bits & 0x00030000u) {
    ::memset(&_impl_.trade_banned_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.eligible_for_community_market_) -
        reinterpret_cast<char*>(&_impl_.trade_banned_)) + sizeof(_impl_.eligible_for_community_market_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgAccountDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool valid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_valid(&has_bits);
          _impl_.valid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string account_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_account_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool public_profile = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_public_profile(&has_bits);
          _impl_.public_profile_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool public_inventory = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_public_inventory(&has_bits);
          _impl_.public_inventory_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool vac_banned = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_vac_banned(&has_bits);
          _impl_.vac_banned_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool cyber_cafe = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_cyber_cafe(&has_bits);
          _impl_.cyber_cafe_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool school_account = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_school_account(&has_bits);
          _impl_.school_account_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool free_trial_account = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_free_trial_account(&has_bits);
          _impl_.free_trial_account_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool subscribed = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_subscribed(&has_bits);
          _impl_.subscribed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool low_violence = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_low_violence(&has_bits);
          _impl_.low_violence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool limited = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_limited(&has_bits);
          _impl_.limited_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool trusted = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_trusted(&has_bits);
          _impl_.trusted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 package = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_package(&has_bits);
          _impl_.package_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 time_cached = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          _Internal::set_has_time_cached(&has_bits);
          _impl_.time_cached_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional bool account_locked = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_account_locked(&has_bits);
          _impl_.account_locked_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool community_banned = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_community_banned(&has_bits);
          _impl_.community_banned_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool trade_banned = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_trade_banned(&has_bits);
          _impl_.trade_banned_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool eligible_for_community_market = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_eligible_for_community_market(&has_bits);
          _impl_.eligible_for_community_market_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgAccountDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgAccountDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool valid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_valid(), target);
  }

  // optional string account_name = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_account_name(), target);
  }

  // optional bool public_profile = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_public_profile(), target);
  }

  // optional bool public_inventory = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_public_inventory(), target);
  }

  // optional bool vac_banned = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_vac_banned(), target);
  }

  // optional bool cyber_cafe = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_cyber_cafe(), target);
  }

  // optional bool school_account = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_school_account(), target);
  }

  // optional bool free_trial_account = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_free_trial_account(), target);
  }

  // optional bool subscribed = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_subscribed(), target);
  }

  // optional bool low_violence = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_low_violence(), target);
  }

  // optional bool limited = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_limited(), target);
  }

  // optional bool trusted = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_trusted(), target);
  }

  // optional uint32 package = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_package(), target);
  }

  // optional fixed32 time_cached = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(15, this->_internal_time_cached(), target);
  }

  // optional bool account_locked = 16;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_account_locked(), target);
  }

  // optional bool community_banned = 17;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_community_banned(), target);
  }

  // optional bool trade_banned = 18;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_trade_banned(), target);
  }

  // optional bool eligible_for_community_market = 19;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(19, this->_internal_eligible_for_community_market(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgAccountDetails)
  return target;
}

size_t CMsgAccountDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgAccountDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string account_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_account_name());
    }

    // optional bool valid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool public_profile = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool public_inventory = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool vac_banned = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool cyber_cafe = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool school_account = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool free_trial_account = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool subscribed = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool low_violence = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool limited = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool trusted = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool account_locked = 16;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 1;
    }

    // optional uint32 package = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_package());
    }

    // optional fixed32 time_cached = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 4;
    }

    // optional bool community_banned = 17;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x00030000u) {
    // optional bool trade_banned = 18;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional bool eligible_for_community_market = 19;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgAccountDetails::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgAccountDetails*>(
      &from));
}

void CMsgAccountDetails::MergeFrom(const CMsgAccountDetails& from) {
  CMsgAccountDetails* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgAccountDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_account_name(from._internal_account_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.valid_ = from._impl_.valid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.public_profile_ = from._impl_.public_profile_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.public_inventory_ = from._impl_.public_inventory_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.vac_banned_ = from._impl_.vac_banned_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.cyber_cafe_ = from._impl_.cyber_cafe_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.school_account_ = from._impl_.school_account_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.free_trial_account_ = from._impl_.free_trial_account_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.subscribed_ = from._impl_.subscribed_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.low_violence_ = from._impl_.low_violence_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.limited_ = from._impl_.limited_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.trusted_ = from._impl_.trusted_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.account_locked_ = from._impl_.account_locked_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.package_ = from._impl_.package_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.time_cached_ = from._impl_.time_cached_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.community_banned_ = from._impl_.community_banned_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00030000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.trade_banned_ = from._impl_.trade_banned_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.eligible_for_community_market_ = from._impl_.eligible_for_community_market_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgAccountDetails::CopyFrom(const CMsgAccountDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgAccountDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgAccountDetails::IsInitialized() const {
  return true;
}

void CMsgAccountDetails::InternalSwap(CMsgAccountDetails* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.account_name_, lhs_arena,
      &other->_impl_.account_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgAccountDetails, _impl_.eligible_for_community_market_)
      + sizeof(CMsgAccountDetails::_impl_.eligible_for_community_market_)
      - PROTOBUF_FIELD_OFFSET(CMsgAccountDetails, _impl_.valid_)>(
          reinterpret_cast<char*>(&_impl_.valid_),
          reinterpret_cast<char*>(&other->_impl_.valid_));
}

std::string CMsgAccountDetails::GetTypeName() const {
  return "CMsgAccountDetails";
}


// ===================================================================

class CMsgGCMultiplexMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCMultiplexMessage>()._impl_._has_bits_);
  static void set_has_msgtype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_payload(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_replytogc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgGCMultiplexMessage::CMsgGCMultiplexMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCMultiplexMessage)
}
CMsgGCMultiplexMessage::CMsgGCMultiplexMessage(const CMsgGCMultiplexMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCMultiplexMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steamids_){from._impl_.steamids_}
    , decltype(_impl_.payload_){}
    , decltype(_impl_.msgtype_){}
    , decltype(_impl_.replytogc_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_payload()) {
    _this->_impl_.payload_.Set(from._internal_payload(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.msgtype_, &from._impl_.msgtype_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.replytogc_) -
    reinterpret_cast<char*>(&_impl_.msgtype_)) + sizeof(_impl_.replytogc_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCMultiplexMessage)
}

inline void CMsgGCMultiplexMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steamids_){arena}
    , decltype(_impl_.payload_){}
    , decltype(_impl_.msgtype_){0u}
    , decltype(_impl_.replytogc_){false}
  };
  _impl_.payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCMultiplexMessage::~CMsgGCMultiplexMessage() {
  // @@protoc_insertion_point(destructor:CMsgGCMultiplexMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCMultiplexMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.steamids_.~RepeatedField();
  _impl_.payload_.Destroy();
}

void CMsgGCMultiplexMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCMultiplexMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCMultiplexMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.steamids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.payload_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.msgtype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.replytogc_) -
        reinterpret_cast<char*>(&_impl_.msgtype_)) + sizeof(_impl_.replytogc_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCMultiplexMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 msgtype = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_msgtype(&has_bits);
          _impl_.msgtype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes payload = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_payload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated fixed64 steamids = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_steamids(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr));
            ptr += sizeof(uint64_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<25>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed64Parser(_internal_mutable_steamids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool replytogc = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_replytogc(&has_bits);
          _impl_.replytogc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCMultiplexMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCMultiplexMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 msgtype = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_msgtype(), target);
  }

  // optional bytes payload = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_payload(), target);
  }

  // repeated fixed64 steamids = 3;
  for (int i = 0, n = this->_internal_steamids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(3, this->_internal_steamids(i), target);
  }

  // optional bool replytogc = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_replytogc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCMultiplexMessage)
  return target;
}

size_t CMsgGCMultiplexMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCMultiplexMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed64 steamids = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_steamids_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_steamids_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes payload = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_payload());
    }

    // optional uint32 msgtype = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msgtype());
    }

    // optional bool replytogc = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCMultiplexMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCMultiplexMessage*>(
      &from));
}

void CMsgGCMultiplexMessage::MergeFrom(const CMsgGCMultiplexMessage& from) {
  CMsgGCMultiplexMessage* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCMultiplexMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.steamids_.MergeFrom(from._impl_.steamids_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_payload(from._internal_payload());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.msgtype_ = from._impl_.msgtype_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.replytogc_ = from._impl_.replytogc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCMultiplexMessage::CopyFrom(const CMsgGCMultiplexMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCMultiplexMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCMultiplexMessage::IsInitialized() const {
  return true;
}

void CMsgGCMultiplexMessage::InternalSwap(CMsgGCMultiplexMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.steamids_.InternalSwap(&other->_impl_.steamids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.payload_, lhs_arena,
      &other->_impl_.payload_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCMultiplexMessage, _impl_.replytogc_)
      + sizeof(CMsgGCMultiplexMessage::_impl_.replytogc_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCMultiplexMessage, _impl_.msgtype_)>(
          reinterpret_cast<char*>(&_impl_.msgtype_),
          reinterpret_cast<char*>(&other->_impl_.msgtype_));
}

std::string CMsgGCMultiplexMessage::GetTypeName() const {
  return "CMsgGCMultiplexMessage";
}


// ===================================================================

class CMsgGCMultiplexMessage_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCMultiplexMessage_Response>()._impl_._has_bits_);
  static void set_has_msgtype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCMultiplexMessage_Response::CMsgGCMultiplexMessage_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCMultiplexMessage_Response)
}
CMsgGCMultiplexMessage_Response::CMsgGCMultiplexMessage_Response(const CMsgGCMultiplexMessage_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCMultiplexMessage_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.msgtype_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.msgtype_ = from._impl_.msgtype_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCMultiplexMessage_Response)
}

inline void CMsgGCMultiplexMessage_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.msgtype_){0u}
  };
}

CMsgGCMultiplexMessage_Response::~CMsgGCMultiplexMessage_Response() {
  // @@protoc_insertion_point(destructor:CMsgGCMultiplexMessage_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCMultiplexMessage_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCMultiplexMessage_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCMultiplexMessage_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCMultiplexMessage_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.msgtype_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCMultiplexMessage_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 msgtype = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_msgtype(&has_bits);
          _impl_.msgtype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCMultiplexMessage_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCMultiplexMessage_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 msgtype = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_msgtype(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCMultiplexMessage_Response)
  return target;
}

size_t CMsgGCMultiplexMessage_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCMultiplexMessage_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 msgtype = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msgtype());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCMultiplexMessage_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCMultiplexMessage_Response*>(
      &from));
}

void CMsgGCMultiplexMessage_Response::MergeFrom(const CMsgGCMultiplexMessage_Response& from) {
  CMsgGCMultiplexMessage_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCMultiplexMessage_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_msgtype()) {
    _this->_internal_set_msgtype(from._internal_msgtype());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCMultiplexMessage_Response::CopyFrom(const CMsgGCMultiplexMessage_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCMultiplexMessage_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCMultiplexMessage_Response::IsInitialized() const {
  return true;
}

void CMsgGCMultiplexMessage_Response::InternalSwap(CMsgGCMultiplexMessage_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.msgtype_, other->_impl_.msgtype_);
}

std::string CMsgGCMultiplexMessage_Response::GetTypeName() const {
  return "CMsgGCMultiplexMessage_Response";
}


// ===================================================================

class CGCToGCMsgMasterAck::_Internal {
 public:
  using HasBits = decltype(std::declval<CGCToGCMsgMasterAck>()._impl_._has_bits_);
  static void set_has_dir_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_gc_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CGCToGCMsgMasterAck::CGCToGCMsgMasterAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCToGCMsgMasterAck)
}
CGCToGCMsgMasterAck::CGCToGCMsgMasterAck(const CGCToGCMsgMasterAck& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGCToGCMsgMasterAck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dir_index_){}
    , decltype(_impl_.gc_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dir_index_, &from._impl_.dir_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.gc_type_) -
    reinterpret_cast<char*>(&_impl_.dir_index_)) + sizeof(_impl_.gc_type_));
  // @@protoc_insertion_point(copy_constructor:CGCToGCMsgMasterAck)
}

inline void CGCToGCMsgMasterAck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dir_index_){0u}
    , decltype(_impl_.gc_type_){0u}
  };
}

CGCToGCMsgMasterAck::~CGCToGCMsgMasterAck() {
  // @@protoc_insertion_point(destructor:CGCToGCMsgMasterAck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCToGCMsgMasterAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CGCToGCMsgMasterAck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCToGCMsgMasterAck::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCToGCMsgMasterAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.dir_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.gc_type_) -
        reinterpret_cast<char*>(&_impl_.dir_index_)) + sizeof(_impl_.gc_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CGCToGCMsgMasterAck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 dir_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dir_index(&has_bits);
          _impl_.dir_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gc_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_gc_type(&has_bits);
          _impl_.gc_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCToGCMsgMasterAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCToGCMsgMasterAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 dir_index = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_dir_index(), target);
  }

  // optional uint32 gc_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_gc_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCToGCMsgMasterAck)
  return target;
}

size_t CGCToGCMsgMasterAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCToGCMsgMasterAck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 dir_index = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dir_index());
    }

    // optional uint32 gc_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gc_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGCToGCMsgMasterAck::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGCToGCMsgMasterAck*>(
      &from));
}

void CGCToGCMsgMasterAck::MergeFrom(const CGCToGCMsgMasterAck& from) {
  CGCToGCMsgMasterAck* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCToGCMsgMasterAck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dir_index_ = from._impl_.dir_index_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.gc_type_ = from._impl_.gc_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGCToGCMsgMasterAck::CopyFrom(const CGCToGCMsgMasterAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCToGCMsgMasterAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCToGCMsgMasterAck::IsInitialized() const {
  return true;
}

void CGCToGCMsgMasterAck::InternalSwap(CGCToGCMsgMasterAck* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CGCToGCMsgMasterAck, _impl_.gc_type_)
      + sizeof(CGCToGCMsgMasterAck::_impl_.gc_type_)
      - PROTOBUF_FIELD_OFFSET(CGCToGCMsgMasterAck, _impl_.dir_index_)>(
          reinterpret_cast<char*>(&_impl_.dir_index_),
          reinterpret_cast<char*>(&other->_impl_.dir_index_));
}

std::string CGCToGCMsgMasterAck::GetTypeName() const {
  return "CGCToGCMsgMasterAck";
}


// ===================================================================

class CGCToGCMsgMasterAck_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CGCToGCMsgMasterAck_Response>()._impl_._has_bits_);
  static void set_has_eresult(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CGCToGCMsgMasterAck_Response::CGCToGCMsgMasterAck_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCToGCMsgMasterAck_Response)
}
CGCToGCMsgMasterAck_Response::CGCToGCMsgMasterAck_Response(const CGCToGCMsgMasterAck_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGCToGCMsgMasterAck_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.eresult_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.eresult_ = from._impl_.eresult_;
  // @@protoc_insertion_point(copy_constructor:CGCToGCMsgMasterAck_Response)
}

inline void CGCToGCMsgMasterAck_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.eresult_){2}
  };
}

CGCToGCMsgMasterAck_Response::~CGCToGCMsgMasterAck_Response() {
  // @@protoc_insertion_point(destructor:CGCToGCMsgMasterAck_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCToGCMsgMasterAck_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CGCToGCMsgMasterAck_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCToGCMsgMasterAck_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCToGCMsgMasterAck_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.eresult_ = 2;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CGCToGCMsgMasterAck_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 eresult = 1 [default = 2];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_eresult(&has_bits);
          _impl_.eresult_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCToGCMsgMasterAck_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCToGCMsgMasterAck_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 eresult = 1 [default = 2];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_eresult(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCToGCMsgMasterAck_Response)
  return target;
}

size_t CGCToGCMsgMasterAck_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCToGCMsgMasterAck_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 eresult = 1 [default = 2];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_eresult());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGCToGCMsgMasterAck_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGCToGCMsgMasterAck_Response*>(
      &from));
}

void CGCToGCMsgMasterAck_Response::MergeFrom(const CGCToGCMsgMasterAck_Response& from) {
  CGCToGCMsgMasterAck_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCToGCMsgMasterAck_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_eresult()) {
    _this->_internal_set_eresult(from._internal_eresult());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGCToGCMsgMasterAck_Response::CopyFrom(const CGCToGCMsgMasterAck_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCToGCMsgMasterAck_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCToGCMsgMasterAck_Response::IsInitialized() const {
  return true;
}

void CGCToGCMsgMasterAck_Response::InternalSwap(CGCToGCMsgMasterAck_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.eresult_, other->_impl_.eresult_);
}

std::string CGCToGCMsgMasterAck_Response::GetTypeName() const {
  return "CGCToGCMsgMasterAck_Response";
}


// ===================================================================

class CGCToGCMsgMasterStartupComplete::_Internal {
 public:
};

CGCToGCMsgMasterStartupComplete::CGCToGCMsgMasterStartupComplete(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCToGCMsgMasterStartupComplete)
}
CGCToGCMsgMasterStartupComplete::CGCToGCMsgMasterStartupComplete(const CGCToGCMsgMasterStartupComplete& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGCToGCMsgMasterStartupComplete* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CGCToGCMsgMasterStartupComplete)
}

inline void CGCToGCMsgMasterStartupComplete::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

CGCToGCMsgMasterStartupComplete::~CGCToGCMsgMasterStartupComplete() {
  // @@protoc_insertion_point(destructor:CGCToGCMsgMasterStartupComplete)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCToGCMsgMasterStartupComplete::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CGCToGCMsgMasterStartupComplete::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCToGCMsgMasterStartupComplete::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCToGCMsgMasterStartupComplete)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* CGCToGCMsgMasterStartupComplete::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCToGCMsgMasterStartupComplete::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCToGCMsgMasterStartupComplete)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCToGCMsgMasterStartupComplete)
  return target;
}

size_t CGCToGCMsgMasterStartupComplete::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCToGCMsgMasterStartupComplete)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGCToGCMsgMasterStartupComplete::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGCToGCMsgMasterStartupComplete*>(
      &from));
}

void CGCToGCMsgMasterStartupComplete::MergeFrom(const CGCToGCMsgMasterStartupComplete& from) {
  CGCToGCMsgMasterStartupComplete* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCToGCMsgMasterStartupComplete)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGCToGCMsgMasterStartupComplete::CopyFrom(const CGCToGCMsgMasterStartupComplete& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCToGCMsgMasterStartupComplete)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCToGCMsgMasterStartupComplete::IsInitialized() const {
  return true;
}

void CGCToGCMsgMasterStartupComplete::InternalSwap(CGCToGCMsgMasterStartupComplete* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string CGCToGCMsgMasterStartupComplete::GetTypeName() const {
  return "CGCToGCMsgMasterStartupComplete";
}


// ===================================================================

class CGCToGCMsgRouted::_Internal {
 public:
  using HasBits = decltype(std::declval<CGCToGCMsgRouted>()._impl_._has_bits_);
  static void set_has_msg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sender_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_net_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CGCToGCMsgRouted::CGCToGCMsgRouted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCToGCMsgRouted)
}
CGCToGCMsgRouted::CGCToGCMsgRouted(const CGCToGCMsgRouted& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGCToGCMsgRouted* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.net_message_){}
    , decltype(_impl_.sender_id_){}
    , decltype(_impl_.msg_type_){}
    , decltype(_impl_.ip_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.net_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.net_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_net_message()) {
    _this->_impl_.net_message_.Set(from._internal_net_message(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.sender_id_, &from._impl_.sender_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ip_) -
    reinterpret_cast<char*>(&_impl_.sender_id_)) + sizeof(_impl_.ip_));
  // @@protoc_insertion_point(copy_constructor:CGCToGCMsgRouted)
}

inline void CGCToGCMsgRouted::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.net_message_){}
    , decltype(_impl_.sender_id_){uint64_t{0u}}
    , decltype(_impl_.msg_type_){0u}
    , decltype(_impl_.ip_){0u}
  };
  _impl_.net_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.net_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CGCToGCMsgRouted::~CGCToGCMsgRouted() {
  // @@protoc_insertion_point(destructor:CGCToGCMsgRouted)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCToGCMsgRouted::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.net_message_.Destroy();
}

void CGCToGCMsgRouted::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCToGCMsgRouted::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCToGCMsgRouted)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.net_message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.sender_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ip_) -
        reinterpret_cast<char*>(&_impl_.sender_id_)) + sizeof(_impl_.ip_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CGCToGCMsgRouted::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 msg_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_msg_type(&has_bits);
          _impl_.msg_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 sender_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_sender_id(&has_bits);
          _impl_.sender_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional bytes net_message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_net_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ip = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_ip(&has_bits);
          _impl_.ip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCToGCMsgRouted::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCToGCMsgRouted)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 msg_type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_msg_type(), target);
  }

  // optional fixed64 sender_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_sender_id(), target);
  }

  // optional bytes net_message = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_net_message(), target);
  }

  // optional uint32 ip = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_ip(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCToGCMsgRouted)
  return target;
}

size_t CGCToGCMsgRouted::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCToGCMsgRouted)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes net_message = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_net_message());
    }

    // optional fixed64 sender_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 msg_type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msg_type());
    }

    // optional uint32 ip = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ip());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGCToGCMsgRouted::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGCToGCMsgRouted*>(
      &from));
}

void CGCToGCMsgRouted::MergeFrom(const CGCToGCMsgRouted& from) {
  CGCToGCMsgRouted* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCToGCMsgRouted)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_net_message(from._internal_net_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.sender_id_ = from._impl_.sender_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.msg_type_ = from._impl_.msg_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.ip_ = from._impl_.ip_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGCToGCMsgRouted::CopyFrom(const CGCToGCMsgRouted& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCToGCMsgRouted)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCToGCMsgRouted::IsInitialized() const {
  return true;
}

void CGCToGCMsgRouted::InternalSwap(CGCToGCMsgRouted* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.net_message_, lhs_arena,
      &other->_impl_.net_message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CGCToGCMsgRouted, _impl_.ip_)
      + sizeof(CGCToGCMsgRouted::_impl_.ip_)
      - PROTOBUF_FIELD_OFFSET(CGCToGCMsgRouted, _impl_.sender_id_)>(
          reinterpret_cast<char*>(&_impl_.sender_id_),
          reinterpret_cast<char*>(&other->_impl_.sender_id_));
}

std::string CGCToGCMsgRouted::GetTypeName() const {
  return "CGCToGCMsgRouted";
}


// ===================================================================

class CGCToGCMsgRoutedReply::_Internal {
 public:
  using HasBits = decltype(std::declval<CGCToGCMsgRoutedReply>()._impl_._has_bits_);
  static void set_has_msg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_net_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CGCToGCMsgRoutedReply::CGCToGCMsgRoutedReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCToGCMsgRoutedReply)
}
CGCToGCMsgRoutedReply::CGCToGCMsgRoutedReply(const CGCToGCMsgRoutedReply& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGCToGCMsgRoutedReply* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.net_message_){}
    , decltype(_impl_.msg_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.net_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.net_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_net_message()) {
    _this->_impl_.net_message_.Set(from._internal_net_message(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.msg_type_ = from._impl_.msg_type_;
  // @@protoc_insertion_point(copy_constructor:CGCToGCMsgRoutedReply)
}

inline void CGCToGCMsgRoutedReply::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.net_message_){}
    , decltype(_impl_.msg_type_){0u}
  };
  _impl_.net_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.net_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CGCToGCMsgRoutedReply::~CGCToGCMsgRoutedReply() {
  // @@protoc_insertion_point(destructor:CGCToGCMsgRoutedReply)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCToGCMsgRoutedReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.net_message_.Destroy();
}

void CGCToGCMsgRoutedReply::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCToGCMsgRoutedReply::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCToGCMsgRoutedReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.net_message_.ClearNonDefaultToEmpty();
  }
  _impl_.msg_type_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CGCToGCMsgRoutedReply::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 msg_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_msg_type(&has_bits);
          _impl_.msg_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes net_message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_net_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCToGCMsgRoutedReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCToGCMsgRoutedReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 msg_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_msg_type(), target);
  }

  // optional bytes net_message = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_net_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCToGCMsgRoutedReply)
  return target;
}

size_t CGCToGCMsgRoutedReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCToGCMsgRoutedReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes net_message = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_net_message());
    }

    // optional uint32 msg_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msg_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGCToGCMsgRoutedReply::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGCToGCMsgRoutedReply*>(
      &from));
}

void CGCToGCMsgRoutedReply::MergeFrom(const CGCToGCMsgRoutedReply& from) {
  CGCToGCMsgRoutedReply* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCToGCMsgRoutedReply)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_net_message(from._internal_net_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.msg_type_ = from._impl_.msg_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGCToGCMsgRoutedReply::CopyFrom(const CGCToGCMsgRoutedReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCToGCMsgRoutedReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCToGCMsgRoutedReply::IsInitialized() const {
  return true;
}

void CGCToGCMsgRoutedReply::InternalSwap(CGCToGCMsgRoutedReply* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.net_message_, lhs_arena,
      &other->_impl_.net_message_, rhs_arena
  );
  swap(_impl_.msg_type_, other->_impl_.msg_type_);
}

std::string CGCToGCMsgRoutedReply::GetTypeName() const {
  return "CGCToGCMsgRoutedReply";
}


// ===================================================================

class CMsgGCUpdateSessionIP::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCUpdateSessionIP>()._impl_._has_bits_);
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgGCUpdateSessionIP::CMsgGCUpdateSessionIP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCUpdateSessionIP)
}
CMsgGCUpdateSessionIP::CMsgGCUpdateSessionIP(const CMsgGCUpdateSessionIP& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCUpdateSessionIP* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steamid_){}
    , decltype(_impl_.ip_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.steamid_, &from._impl_.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ip_) -
    reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.ip_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCUpdateSessionIP)
}

inline void CMsgGCUpdateSessionIP::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steamid_){uint64_t{0u}}
    , decltype(_impl_.ip_){0u}
  };
}

CMsgGCUpdateSessionIP::~CMsgGCUpdateSessionIP() {
  // @@protoc_insertion_point(destructor:CMsgGCUpdateSessionIP)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCUpdateSessionIP::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCUpdateSessionIP::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCUpdateSessionIP::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCUpdateSessionIP)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ip_) -
        reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.ip_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCUpdateSessionIP::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steamid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steamid(&has_bits);
          _impl_.steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 ip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_ip(&has_bits);
          _impl_.ip_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCUpdateSessionIP::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCUpdateSessionIP)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steamid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steamid(), target);
  }

  // optional fixed32 ip = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_ip(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCUpdateSessionIP)
  return target;
}

size_t CMsgGCUpdateSessionIP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCUpdateSessionIP)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional fixed64 steamid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional fixed32 ip = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCUpdateSessionIP::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCUpdateSessionIP*>(
      &from));
}

void CMsgGCUpdateSessionIP::MergeFrom(const CMsgGCUpdateSessionIP& from) {
  CMsgGCUpdateSessionIP* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCUpdateSessionIP)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.steamid_ = from._impl_.steamid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ip_ = from._impl_.ip_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCUpdateSessionIP::CopyFrom(const CMsgGCUpdateSessionIP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCUpdateSessionIP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCUpdateSessionIP::IsInitialized() const {
  return true;
}

void CMsgGCUpdateSessionIP::InternalSwap(CMsgGCUpdateSessionIP* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCUpdateSessionIP, _impl_.ip_)
      + sizeof(CMsgGCUpdateSessionIP::_impl_.ip_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCUpdateSessionIP, _impl_.steamid_)>(
          reinterpret_cast<char*>(&_impl_.steamid_),
          reinterpret_cast<char*>(&other->_impl_.steamid_));
}

std::string CMsgGCUpdateSessionIP::GetTypeName() const {
  return "CMsgGCUpdateSessionIP";
}


// ===================================================================

class CMsgGCRequestSessionIP::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCRequestSessionIP>()._impl_._has_bits_);
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCRequestSessionIP::CMsgGCRequestSessionIP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCRequestSessionIP)
}
CMsgGCRequestSessionIP::CMsgGCRequestSessionIP(const CMsgGCRequestSessionIP& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCRequestSessionIP* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steamid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.steamid_ = from._impl_.steamid_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCRequestSessionIP)
}

inline void CMsgGCRequestSessionIP::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steamid_){uint64_t{0u}}
  };
}

CMsgGCRequestSessionIP::~CMsgGCRequestSessionIP() {
  // @@protoc_insertion_point(destructor:CMsgGCRequestSessionIP)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCRequestSessionIP::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCRequestSessionIP::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCRequestSessionIP::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCRequestSessionIP)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.steamid_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCRequestSessionIP::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steamid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steamid(&has_bits);
          _impl_.steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCRequestSessionIP::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCRequestSessionIP)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steamid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steamid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCRequestSessionIP)
  return target;
}

size_t CMsgGCRequestSessionIP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCRequestSessionIP)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional fixed64 steamid = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 8;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCRequestSessionIP::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCRequestSessionIP*>(
      &from));
}

void CMsgGCRequestSessionIP::MergeFrom(const CMsgGCRequestSessionIP& from) {
  CMsgGCRequestSessionIP* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCRequestSessionIP)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_steamid()) {
    _this->_internal_set_steamid(from._internal_steamid());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCRequestSessionIP::CopyFrom(const CMsgGCRequestSessionIP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCRequestSessionIP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCRequestSessionIP::IsInitialized() const {
  return true;
}

void CMsgGCRequestSessionIP::InternalSwap(CMsgGCRequestSessionIP* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.steamid_, other->_impl_.steamid_);
}

std::string CMsgGCRequestSessionIP::GetTypeName() const {
  return "CMsgGCRequestSessionIP";
}


// ===================================================================

class CMsgGCRequestSessionIPResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCRequestSessionIPResponse>()._impl_._has_bits_);
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCRequestSessionIPResponse::CMsgGCRequestSessionIPResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCRequestSessionIPResponse)
}
CMsgGCRequestSessionIPResponse::CMsgGCRequestSessionIPResponse(const CMsgGCRequestSessionIPResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgGCRequestSessionIPResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ip_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.ip_ = from._impl_.ip_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCRequestSessionIPResponse)
}

inline void CMsgGCRequestSessionIPResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ip_){0u}
  };
}

CMsgGCRequestSessionIPResponse::~CMsgGCRequestSessionIPResponse() {
  // @@protoc_insertion_point(destructor:CMsgGCRequestSessionIPResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCRequestSessionIPResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCRequestSessionIPResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCRequestSessionIPResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCRequestSessionIPResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ip_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgGCRequestSessionIPResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 ip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_ip(&has_bits);
          _impl_.ip_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCRequestSessionIPResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCRequestSessionIPResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 ip = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_ip(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCRequestSessionIPResponse)
  return target;
}

size_t CMsgGCRequestSessionIPResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCRequestSessionIPResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional fixed32 ip = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgGCRequestSessionIPResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgGCRequestSessionIPResponse*>(
      &from));
}

void CMsgGCRequestSessionIPResponse::MergeFrom(const CMsgGCRequestSessionIPResponse& from) {
  CMsgGCRequestSessionIPResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCRequestSessionIPResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_ip()) {
    _this->_internal_set_ip(from._internal_ip());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgGCRequestSessionIPResponse::CopyFrom(const CMsgGCRequestSessionIPResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCRequestSessionIPResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCRequestSessionIPResponse::IsInitialized() const {
  return true;
}

void CMsgGCRequestSessionIPResponse::InternalSwap(CMsgGCRequestSessionIPResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.ip_, other->_impl_.ip_);
}

std::string CMsgGCRequestSessionIPResponse::GetTypeName() const {
  return "CMsgGCRequestSessionIPResponse";
}


// ===================================================================

class CMsgSOCacheHaveVersion::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSOCacheHaveVersion>()._impl_._has_bits_);
  static const ::CMsgSOIDOwner& soid(const CMsgSOCacheHaveVersion* msg);
  static void set_has_soid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgSOIDOwner&
CMsgSOCacheHaveVersion::_Internal::soid(const CMsgSOCacheHaveVersion* msg) {
  return *msg->_impl_.soid_;
}
CMsgSOCacheHaveVersion::CMsgSOCacheHaveVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSOCacheHaveVersion)
}
CMsgSOCacheHaveVersion::CMsgSOCacheHaveVersion(const CMsgSOCacheHaveVersion& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgSOCacheHaveVersion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.soid_){nullptr}
    , decltype(_impl_.version_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_soid()) {
    _this->_impl_.soid_ = new ::CMsgSOIDOwner(*from._impl_.soid_);
  }
  _this->_impl_.version_ = from._impl_.version_;
  // @@protoc_insertion_point(copy_constructor:CMsgSOCacheHaveVersion)
}

inline void CMsgSOCacheHaveVersion::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.soid_){nullptr}
    , decltype(_impl_.version_){uint64_t{0u}}
  };
}

CMsgSOCacheHaveVersion::~CMsgSOCacheHaveVersion() {
  // @@protoc_insertion_point(destructor:CMsgSOCacheHaveVersion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSOCacheHaveVersion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.soid_;
}

void CMsgSOCacheHaveVersion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSOCacheHaveVersion::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSOCacheHaveVersion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.soid_ != nullptr);
    _impl_.soid_->Clear();
  }
  _impl_.version_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgSOCacheHaveVersion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgSOIDOwner soid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_soid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSOCacheHaveVersion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSOCacheHaveVersion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgSOIDOwner soid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::soid(this),
        _Internal::soid(this).GetCachedSize(), target, stream);
  }

  // optional fixed64 version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSOCacheHaveVersion)
  return target;
}

size_t CMsgSOCacheHaveVersion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSOCacheHaveVersion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgSOIDOwner soid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.soid_);
    }

    // optional fixed64 version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgSOCacheHaveVersion::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgSOCacheHaveVersion*>(
      &from));
}

void CMsgSOCacheHaveVersion::MergeFrom(const CMsgSOCacheHaveVersion& from) {
  CMsgSOCacheHaveVersion* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSOCacheHaveVersion)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_soid()->::CMsgSOIDOwner::MergeFrom(
          from._internal_soid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgSOCacheHaveVersion::CopyFrom(const CMsgSOCacheHaveVersion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSOCacheHaveVersion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSOCacheHaveVersion::IsInitialized() const {
  return true;
}

void CMsgSOCacheHaveVersion::InternalSwap(CMsgSOCacheHaveVersion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSOCacheHaveVersion, _impl_.version_)
      + sizeof(CMsgSOCacheHaveVersion::_impl_.version_)
      - PROTOBUF_FIELD_OFFSET(CMsgSOCacheHaveVersion, _impl_.soid_)>(
          reinterpret_cast<char*>(&_impl_.soid_),
          reinterpret_cast<char*>(&other->_impl_.soid_));
}

std::string CMsgSOCacheHaveVersion::GetTypeName() const {
  return "CMsgSOCacheHaveVersion";
}


// ===================================================================

class CMsgClientHello::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientHello>()._impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_client_session_need(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_client_launcher(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_partner_srcid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_partner_accountid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_partner_accountflags(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_partner_accountbalance(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_steam_launcher(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

CMsgClientHello::CMsgClientHello(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientHello)
}
CMsgClientHello::CMsgClientHello(const CMsgClientHello& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgClientHello* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.socache_have_versions_){from._impl_.socache_have_versions_}
    , decltype(_impl_.version_){}
    , decltype(_impl_.client_session_need_){}
    , decltype(_impl_.client_launcher_){}
    , decltype(_impl_.partner_srcid_){}
    , decltype(_impl_.partner_accountid_){}
    , decltype(_impl_.partner_accountflags_){}
    , decltype(_impl_.partner_accountbalance_){}
    , decltype(_impl_.steam_launcher_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.version_, &from._impl_.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.steam_launcher_) -
    reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.steam_launcher_));
  // @@protoc_insertion_point(copy_constructor:CMsgClientHello)
}

inline void CMsgClientHello::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.socache_have_versions_){arena}
    , decltype(_impl_.version_){0u}
    , decltype(_impl_.client_session_need_){0u}
    , decltype(_impl_.client_launcher_){0u}
    , decltype(_impl_.partner_srcid_){0u}
    , decltype(_impl_.partner_accountid_){0u}
    , decltype(_impl_.partner_accountflags_){0u}
    , decltype(_impl_.partner_accountbalance_){0u}
    , decltype(_impl_.steam_launcher_){0u}
  };
}

CMsgClientHello::~CMsgClientHello() {
  // @@protoc_insertion_point(destructor:CMsgClientHello)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientHello::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.socache_have_versions_.~RepeatedPtrField();
}

void CMsgClientHello::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientHello::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientHello)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.socache_have_versions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.steam_launcher_) -
        reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.steam_launcher_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgClientHello::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSOCacheHaveVersion socache_have_versions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_socache_have_versions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_session_need = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_client_session_need(&has_bits);
          _impl_.client_session_need_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_launcher = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_client_launcher(&has_bits);
          _impl_.client_launcher_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 partner_srcid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_partner_srcid(&has_bits);
          _impl_.partner_srcid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 partner_accountid = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_partner_accountid(&has_bits);
          _impl_.partner_accountid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 partner_accountflags = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_partner_accountflags(&has_bits);
          _impl_.partner_accountflags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 partner_accountbalance = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_partner_accountbalance(&has_bits);
          _impl_.partner_accountbalance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 steam_launcher = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_steam_launcher(&has_bits);
          _impl_.steam_launcher_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientHello::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientHello)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_version(), target);
  }

  // repeated .CMsgSOCacheHaveVersion socache_have_versions = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_socache_have_versions_size()); i < n; i++) {
    const auto& repfield = this->_internal_socache_have_versions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 client_session_need = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_client_session_need(), target);
  }

  // optional uint32 client_launcher = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_client_launcher(), target);
  }

  // optional uint32 partner_srcid = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_partner_srcid(), target);
  }

  // optional uint32 partner_accountid = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_partner_accountid(), target);
  }

  // optional uint32 partner_accountflags = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_partner_accountflags(), target);
  }

  // optional uint32 partner_accountbalance = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_partner_accountbalance(), target);
  }

  // optional uint32 steam_launcher = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_steam_launcher(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientHello)
  return target;
}

size_t CMsgClientHello::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientHello)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgSOCacheHaveVersion socache_have_versions = 2;
  total_size += 1UL * this->_internal_socache_have_versions_size();
  for (const auto& msg : this->_impl_.socache_have_versions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 version = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
    }

    // optional uint32 client_session_need = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_session_need());
    }

    // optional uint32 client_launcher = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_launcher());
    }

    // optional uint32 partner_srcid = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_partner_srcid());
    }

    // optional uint32 partner_accountid = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_partner_accountid());
    }

    // optional uint32 partner_accountflags = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_partner_accountflags());
    }

    // optional uint32 partner_accountbalance = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_partner_accountbalance());
    }

    // optional uint32 steam_launcher = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_steam_launcher());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgClientHello::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgClientHello*>(
      &from));
}

void CMsgClientHello::MergeFrom(const CMsgClientHello& from) {
  CMsgClientHello* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientHello)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.socache_have_versions_.MergeFrom(from._impl_.socache_have_versions_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.client_session_need_ = from._impl_.client_session_need_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.client_launcher_ = from._impl_.client_launcher_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.partner_srcid_ = from._impl_.partner_srcid_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.partner_accountid_ = from._impl_.partner_accountid_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.partner_accountflags_ = from._impl_.partner_accountflags_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.partner_accountbalance_ = from._impl_.partner_accountbalance_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.steam_launcher_ = from._impl_.steam_launcher_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgClientHello::CopyFrom(const CMsgClientHello& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientHello)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientHello::IsInitialized() const {
  return true;
}

void CMsgClientHello::InternalSwap(CMsgClientHello* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.socache_have_versions_.InternalSwap(&other->_impl_.socache_have_versions_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgClientHello, _impl_.steam_launcher_)
      + sizeof(CMsgClientHello::_impl_.steam_launcher_)
      - PROTOBUF_FIELD_OFFSET(CMsgClientHello, _impl_.version_)>(
          reinterpret_cast<char*>(&_impl_.version_),
          reinterpret_cast<char*>(&other->_impl_.version_));
}

std::string CMsgClientHello::GetTypeName() const {
  return "CMsgClientHello";
}


// ===================================================================

class CMsgServerHello::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgServerHello>()._impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_legacy_client_session_need(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_client_launcher(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_legacy_steamdatagram_routing(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_required_internal_addr(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_steamdatagram_login(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgServerHello::CMsgServerHello(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgServerHello)
}
CMsgServerHello::CMsgServerHello(const CMsgServerHello& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgServerHello* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.socache_have_versions_){from._impl_.socache_have_versions_}
    , decltype(_impl_.legacy_steamdatagram_routing_){}
    , decltype(_impl_.steamdatagram_login_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.legacy_client_session_need_){}
    , decltype(_impl_.client_launcher_){}
    , decltype(_impl_.required_internal_addr_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.legacy_steamdatagram_routing_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.legacy_steamdatagram_routing_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_legacy_steamdatagram_routing()) {
    _this->_impl_.legacy_steamdatagram_routing_.Set(from._internal_legacy_steamdatagram_routing(), 
      _this->GetArenaForAllocation());
  }
  _impl_.steamdatagram_login_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.steamdatagram_login_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_steamdatagram_login()) {
    _this->_impl_.steamdatagram_login_.Set(from._internal_steamdatagram_login(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.version_, &from._impl_.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.required_internal_addr_) -
    reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.required_internal_addr_));
  // @@protoc_insertion_point(copy_constructor:CMsgServerHello)
}

inline void CMsgServerHello::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.socache_have_versions_){arena}
    , decltype(_impl_.legacy_steamdatagram_routing_){}
    , decltype(_impl_.steamdatagram_login_){}
    , decltype(_impl_.version_){0u}
    , decltype(_impl_.legacy_client_session_need_){0u}
    , decltype(_impl_.client_launcher_){0u}
    , decltype(_impl_.required_internal_addr_){0u}
  };
  _impl_.legacy_steamdatagram_routing_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.legacy_steamdatagram_routing_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.steamdatagram_login_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.steamdatagram_login_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgServerHello::~CMsgServerHello() {
  // @@protoc_insertion_point(destructor:CMsgServerHello)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgServerHello::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.socache_have_versions_.~RepeatedPtrField();
  _impl_.legacy_steamdatagram_routing_.Destroy();
  _impl_.steamdatagram_login_.Destroy();
}

void CMsgServerHello::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgServerHello::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgServerHello)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.socache_have_versions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.legacy_steamdatagram_routing_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.steamdatagram_login_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.required_internal_addr_) -
        reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.required_internal_addr_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgServerHello::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSOCacheHaveVersion socache_have_versions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_socache_have_versions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 legacy_client_session_need = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_legacy_client_session_need(&has_bits);
          _impl_.legacy_client_session_need_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_launcher = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_client_launcher(&has_bits);
          _impl_.client_launcher_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes legacy_steamdatagram_routing = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_legacy_steamdatagram_routing();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 required_internal_addr = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_required_internal_addr(&has_bits);
          _impl_.required_internal_addr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes steamdatagram_login = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_steamdatagram_login();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgServerHello::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgServerHello)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 version = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_version(), target);
  }

  // repeated .CMsgSOCacheHaveVersion socache_have_versions = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_socache_have_versions_size()); i < n; i++) {
    const auto& repfield = this->_internal_socache_have_versions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 legacy_client_session_need = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_legacy_client_session_need(), target);
  }

  // optional uint32 client_launcher = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_client_launcher(), target);
  }

  // optional bytes legacy_steamdatagram_routing = 6;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_legacy_steamdatagram_routing(), target);
  }

  // optional uint32 required_internal_addr = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_required_internal_addr(), target);
  }

  // optional bytes steamdatagram_login = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_steamdatagram_login(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgServerHello)
  return target;
}

size_t CMsgServerHello::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgServerHello)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgSOCacheHaveVersion socache_have_versions = 2;
  total_size += 1UL * this->_internal_socache_have_versions_size();
  for (const auto& msg : this->_impl_.socache_have_versions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes legacy_steamdatagram_routing = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_legacy_steamdatagram_routing());
    }

    // optional bytes steamdatagram_login = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_steamdatagram_login());
    }

    // optional uint32 version = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
    }

    // optional uint32 legacy_client_session_need = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_legacy_client_session_need());
    }

    // optional uint32 client_launcher = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_launcher());
    }

    // optional uint32 required_internal_addr = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_required_internal_addr());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgServerHello::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgServerHello*>(
      &from));
}

void CMsgServerHello::MergeFrom(const CMsgServerHello& from) {
  CMsgServerHello* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgServerHello)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.socache_have_versions_.MergeFrom(from._impl_.socache_have_versions_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_legacy_steamdatagram_routing(from._internal_legacy_steamdatagram_routing());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_steamdatagram_login(from._internal_steamdatagram_login());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.legacy_client_session_need_ = from._impl_.legacy_client_session_need_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.client_launcher_ = from._impl_.client_launcher_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.required_internal_addr_ = from._impl_.required_internal_addr_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgServerHello::CopyFrom(const CMsgServerHello& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgServerHello)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgServerHello::IsInitialized() const {
  return true;
}

void CMsgServerHello::InternalSwap(CMsgServerHello* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.socache_have_versions_.InternalSwap(&other->_impl_.socache_have_versions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.legacy_steamdatagram_routing_, lhs_arena,
      &other->_impl_.legacy_steamdatagram_routing_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.steamdatagram_login_, lhs_arena,
      &other->_impl_.steamdatagram_login_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgServerHello, _impl_.required_internal_addr_)
      + sizeof(CMsgServerHello::_impl_.required_internal_addr_)
      - PROTOBUF_FIELD_OFFSET(CMsgServerHello, _impl_.version_)>(
          reinterpret_cast<char*>(&_impl_.version_),
          reinterpret_cast<char*>(&other->_impl_.version_));
}

std::string CMsgServerHello::GetTypeName() const {
  return "CMsgServerHello";
}


// ===================================================================

class CMsgClientWelcome_Location::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientWelcome_Location>()._impl_._has_bits_);
  static void set_has_latitude(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_longitude(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_country(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgClientWelcome_Location::CMsgClientWelcome_Location(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientWelcome.Location)
}
CMsgClientWelcome_Location::CMsgClientWelcome_Location(const CMsgClientWelcome_Location& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgClientWelcome_Location* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.country_){}
    , decltype(_impl_.latitude_){}
    , decltype(_impl_.longitude_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.country_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.country_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_country()) {
    _this->_impl_.country_.Set(from._internal_country(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.latitude_, &from._impl_.latitude_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.longitude_) -
    reinterpret_cast<char*>(&_impl_.latitude_)) + sizeof(_impl_.longitude_));
  // @@protoc_insertion_point(copy_constructor:CMsgClientWelcome.Location)
}

inline void CMsgClientWelcome_Location::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.country_){}
    , decltype(_impl_.latitude_){0}
    , decltype(_impl_.longitude_){0}
  };
  _impl_.country_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.country_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgClientWelcome_Location::~CMsgClientWelcome_Location() {
  // @@protoc_insertion_point(destructor:CMsgClientWelcome.Location)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientWelcome_Location::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.country_.Destroy();
}

void CMsgClientWelcome_Location::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientWelcome_Location::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientWelcome.Location)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.country_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.latitude_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.longitude_) -
        reinterpret_cast<char*>(&_impl_.latitude_)) + sizeof(_impl_.longitude_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgClientWelcome_Location::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float latitude = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_latitude(&has_bits);
          _impl_.latitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float longitude = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_longitude(&has_bits);
          _impl_.longitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional string country = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_country();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientWelcome_Location::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientWelcome.Location)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float latitude = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_latitude(), target);
  }

  // optional float longitude = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_longitude(), target);
  }

  // optional string country = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_country(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientWelcome.Location)
  return target;
}

size_t CMsgClientWelcome_Location::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientWelcome.Location)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string country = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_country());
    }

    // optional float latitude = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float longitude = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgClientWelcome_Location::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgClientWelcome_Location*>(
      &from));
}

void CMsgClientWelcome_Location::MergeFrom(const CMsgClientWelcome_Location& from) {
  CMsgClientWelcome_Location* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientWelcome.Location)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_country(from._internal_country());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.latitude_ = from._impl_.latitude_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.longitude_ = from._impl_.longitude_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgClientWelcome_Location::CopyFrom(const CMsgClientWelcome_Location& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientWelcome.Location)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientWelcome_Location::IsInitialized() const {
  return true;
}

void CMsgClientWelcome_Location::InternalSwap(CMsgClientWelcome_Location* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.country_, lhs_arena,
      &other->_impl_.country_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgClientWelcome_Location, _impl_.longitude_)
      + sizeof(CMsgClientWelcome_Location::_impl_.longitude_)
      - PROTOBUF_FIELD_OFFSET(CMsgClientWelcome_Location, _impl_.latitude_)>(
          reinterpret_cast<char*>(&_impl_.latitude_),
          reinterpret_cast<char*>(&other->_impl_.latitude_));
}

std::string CMsgClientWelcome_Location::GetTypeName() const {
  return "CMsgClientWelcome.Location";
}


// ===================================================================

class CMsgClientWelcome::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientWelcome>()._impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_game_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgClientWelcome_Location& location(const CMsgClientWelcome* msg);
  static void set_has_location(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_game_data2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rtime32_gc_welcome_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_currency(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_balance(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_balance_url(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txn_country_code(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgClientWelcome_Location&
CMsgClientWelcome::_Internal::location(const CMsgClientWelcome* msg) {
  return *msg->_impl_.location_;
}
CMsgClientWelcome::CMsgClientWelcome(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientWelcome)
}
CMsgClientWelcome::CMsgClientWelcome(const CMsgClientWelcome& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgClientWelcome* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.outofdate_subscribed_caches_){from._impl_.outofdate_subscribed_caches_}
    , decltype(_impl_.uptodate_subscribed_caches_){from._impl_.uptodate_subscribed_caches_}
    , decltype(_impl_.game_data_){}
    , decltype(_impl_.game_data2_){}
    , decltype(_impl_.balance_url_){}
    , decltype(_impl_.txn_country_code_){}
    , decltype(_impl_.location_){nullptr}
    , decltype(_impl_.version_){}
    , decltype(_impl_.rtime32_gc_welcome_timestamp_){}
    , decltype(_impl_.currency_){}
    , decltype(_impl_.balance_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.game_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_game_data()) {
    _this->_impl_.game_data_.Set(from._internal_game_data(), 
      _this->GetArenaForAllocation());
  }
  _impl_.game_data2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_data2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_game_data2()) {
    _this->_impl_.game_data2_.Set(from._internal_game_data2(), 
      _this->GetArenaForAllocation());
  }
  _impl_.balance_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.balance_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_balance_url()) {
    _this->_impl_.balance_url_.Set(from._internal_balance_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.txn_country_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.txn_country_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_txn_country_code()) {
    _this->_impl_.txn_country_code_.Set(from._internal_txn_country_code(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_location()) {
    _this->_impl_.location_ = new ::CMsgClientWelcome_Location(*from._impl_.location_);
  }
  ::memcpy(&_impl_.version_, &from._impl_.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.balance_) -
    reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.balance_));
  // @@protoc_insertion_point(copy_constructor:CMsgClientWelcome)
}

inline void CMsgClientWelcome::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.outofdate_subscribed_caches_){arena}
    , decltype(_impl_.uptodate_subscribed_caches_){arena}
    , decltype(_impl_.game_data_){}
    , decltype(_impl_.game_data2_){}
    , decltype(_impl_.balance_url_){}
    , decltype(_impl_.txn_country_code_){}
    , decltype(_impl_.location_){nullptr}
    , decltype(_impl_.version_){0u}
    , decltype(_impl_.rtime32_gc_welcome_timestamp_){0u}
    , decltype(_impl_.currency_){0u}
    , decltype(_impl_.balance_){0u}
  };
  _impl_.game_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.game_data2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_data2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.balance_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.balance_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.txn_country_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.txn_country_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgClientWelcome::~CMsgClientWelcome() {
  // @@protoc_insertion_point(destructor:CMsgClientWelcome)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientWelcome::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.outofdate_subscribed_caches_.~RepeatedPtrField();
  _impl_.uptodate_subscribed_caches_.~RepeatedPtrField();
  _impl_.game_data_.Destroy();
  _impl_.game_data2_.Destroy();
  _impl_.balance_url_.Destroy();
  _impl_.txn_country_code_.Destroy();
  if (this != internal_default_instance()) delete _impl_.location_;
}

void CMsgClientWelcome::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientWelcome::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientWelcome)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.outofdate_subscribed_caches_.Clear();
  _impl_.uptodate_subscribed_caches_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.game_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.game_data2_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.balance_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.txn_country_code_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.location_ != nullptr);
      _impl_.location_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.currency_) -
        reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.currency_));
  }
  _impl_.balance_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgClientWelcome::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes game_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_game_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSOCacheSubscribed outofdate_subscribed_caches = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_outofdate_subscribed_caches(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSOCacheSubscriptionCheck uptodate_subscribed_caches = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_uptodate_subscribed_caches(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgClientWelcome.Location location = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_location(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes game_data2 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_game_data2();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rtime32_gc_welcome_timestamp = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_rtime32_gc_welcome_timestamp(&has_bits);
          _impl_.rtime32_gc_welcome_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 currency = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_currency(&has_bits);
          _impl_.currency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 balance = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_balance(&has_bits);
          _impl_.balance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string balance_url = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_balance_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string txn_country_code = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_txn_country_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientWelcome::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientWelcome)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 version = 1;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_version(), target);
  }

  // optional bytes game_data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_game_data(), target);
  }

  // repeated .CMsgSOCacheSubscribed outofdate_subscribed_caches = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_outofdate_subscribed_caches_size()); i < n; i++) {
    const auto& repfield = this->_internal_outofdate_subscribed_caches(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgSOCacheSubscriptionCheck uptodate_subscribed_caches = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_uptodate_subscribed_caches_size()); i < n; i++) {
    const auto& repfield = this->_internal_uptodate_subscribed_caches(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .CMsgClientWelcome.Location location = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::location(this),
        _Internal::location(this).GetCachedSize(), target, stream);
  }

  // optional bytes game_data2 = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_game_data2(), target);
  }

  // optional uint32 rtime32_gc_welcome_timestamp = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_rtime32_gc_welcome_timestamp(), target);
  }

  // optional uint32 currency = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_currency(), target);
  }

  // optional uint32 balance = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_balance(), target);
  }

  // optional string balance_url = 10;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_balance_url(), target);
  }

  // optional string txn_country_code = 11;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_txn_country_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientWelcome)
  return target;
}

size_t CMsgClientWelcome::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientWelcome)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgSOCacheSubscribed outofdate_subscribed_caches = 3;
  total_size += 1UL * this->_internal_outofdate_subscribed_caches_size();
  for (const auto& msg : this->_impl_.outofdate_subscribed_caches_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgSOCacheSubscriptionCheck uptodate_subscribed_caches = 4;
  total_size += 1UL * this->_internal_uptodate_subscribed_caches_size();
  for (const auto& msg : this->_impl_.uptodate_subscribed_caches_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes game_data = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_game_data());
    }

    // optional bytes game_data2 = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_game_data2());
    }

    // optional string balance_url = 10;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_balance_url());
    }

    // optional string txn_country_code = 11;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_txn_country_code());
    }

    // optional .CMsgClientWelcome.Location location = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.location_);
    }

    // optional uint32 version = 1;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
    }

    // optional uint32 rtime32_gc_welcome_timestamp = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rtime32_gc_welcome_timestamp());
    }

    // optional uint32 currency = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_currency());
    }

  }
  // optional uint32 balance = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_balance());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgClientWelcome::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgClientWelcome*>(
      &from));
}

void CMsgClientWelcome::MergeFrom(const CMsgClientWelcome& from) {
  CMsgClientWelcome* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientWelcome)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.outofdate_subscribed_caches_.MergeFrom(from._impl_.outofdate_subscribed_caches_);
  _this->_impl_.uptodate_subscribed_caches_.MergeFrom(from._impl_.uptodate_subscribed_caches_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_game_data(from._internal_game_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_game_data2(from._internal_game_data2());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_balance_url(from._internal_balance_url());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_txn_country_code(from._internal_txn_country_code());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_location()->::CMsgClientWelcome_Location::MergeFrom(
          from._internal_location());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.rtime32_gc_welcome_timestamp_ = from._impl_.rtime32_gc_welcome_timestamp_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.currency_ = from._impl_.currency_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_balance(from._internal_balance());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgClientWelcome::CopyFrom(const CMsgClientWelcome& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientWelcome)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientWelcome::IsInitialized() const {
  return true;
}

void CMsgClientWelcome::InternalSwap(CMsgClientWelcome* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.outofdate_subscribed_caches_.InternalSwap(&other->_impl_.outofdate_subscribed_caches_);
  _impl_.uptodate_subscribed_caches_.InternalSwap(&other->_impl_.uptodate_subscribed_caches_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.game_data_, lhs_arena,
      &other->_impl_.game_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.game_data2_, lhs_arena,
      &other->_impl_.game_data2_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.balance_url_, lhs_arena,
      &other->_impl_.balance_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.txn_country_code_, lhs_arena,
      &other->_impl_.txn_country_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgClientWelcome, _impl_.balance_)
      + sizeof(CMsgClientWelcome::_impl_.balance_)
      - PROTOBUF_FIELD_OFFSET(CMsgClientWelcome, _impl_.location_)>(
          reinterpret_cast<char*>(&_impl_.location_),
          reinterpret_cast<char*>(&other->_impl_.location_));
}

std::string CMsgClientWelcome::GetTypeName() const {
  return "CMsgClientWelcome";
}


// ===================================================================

class CMsgConnectionStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgConnectionStatus>()._impl_._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_client_session_need(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_queue_position(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_queue_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_wait_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_estimated_wait_seconds_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

CMsgConnectionStatus::CMsgConnectionStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgConnectionStatus)
}
CMsgConnectionStatus::CMsgConnectionStatus(const CMsgConnectionStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CMsgConnectionStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.status_){}
    , decltype(_impl_.client_session_need_){}
    , decltype(_impl_.queue_position_){}
    , decltype(_impl_.queue_size_){}
    , decltype(_impl_.wait_seconds_){}
    , decltype(_impl_.estimated_wait_seconds_remaining_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.status_, &from._impl_.status_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.estimated_wait_seconds_remaining_) -
    reinterpret_cast<char*>(&_impl_.status_)) + sizeof(_impl_.estimated_wait_seconds_remaining_));
  // @@protoc_insertion_point(copy_constructor:CMsgConnectionStatus)
}

inline void CMsgConnectionStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.status_){0}
    , decltype(_impl_.client_session_need_){0u}
    , decltype(_impl_.queue_position_){0}
    , decltype(_impl_.queue_size_){0}
    , decltype(_impl_.wait_seconds_){0}
    , decltype(_impl_.estimated_wait_seconds_remaining_){0}
  };
}

CMsgConnectionStatus::~CMsgConnectionStatus() {
  // @@protoc_insertion_point(destructor:CMsgConnectionStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgConnectionStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgConnectionStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgConnectionStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgConnectionStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.status_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.estimated_wait_seconds_remaining_) -
        reinterpret_cast<char*>(&_impl_.status_)) + sizeof(_impl_.estimated_wait_seconds_remaining_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CMsgConnectionStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .GCConnectionStatus status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::GCConnectionStatus_IsValid(val))) {
            _internal_set_status(static_cast<::GCConnectionStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_session_need = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_client_session_need(&has_bits);
          _impl_.client_session_need_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 queue_position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_queue_position(&has_bits);
          _impl_.queue_position_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 queue_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_queue_size(&has_bits);
          _impl_.queue_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 wait_seconds = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_wait_seconds(&has_bits);
          _impl_.wait_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 estimated_wait_seconds_remaining = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_estimated_wait_seconds_remaining(&has_bits);
          _impl_.estimated_wait_seconds_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgConnectionStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgConnectionStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .GCConnectionStatus status = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_status(), target);
  }

  // optional uint32 client_session_need = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_client_session_need(), target);
  }

  // optional int32 queue_position = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_queue_position(), target);
  }

  // optional int32 queue_size = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_queue_size(), target);
  }

  // optional int32 wait_seconds = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_wait_seconds(), target);
  }

  // optional int32 estimated_wait_seconds_remaining = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_estimated_wait_seconds_remaining(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgConnectionStatus)
  return target;
}

size_t CMsgConnectionStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgConnectionStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .GCConnectionStatus status = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
    }

    // optional uint32 client_session_need = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_session_need());
    }

    // optional int32 queue_position = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_queue_position());
    }

    // optional int32 queue_size = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_queue_size());
    }

    // optional int32 wait_seconds = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_wait_seconds());
    }

    // optional int32 estimated_wait_seconds_remaining = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_estimated_wait_seconds_remaining());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgConnectionStatus::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CMsgConnectionStatus*>(
      &from));
}

void CMsgConnectionStatus::MergeFrom(const CMsgConnectionStatus& from) {
  CMsgConnectionStatus* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgConnectionStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.client_session_need_ = from._impl_.client_session_need_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.queue_position_ = from._impl_.queue_position_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.queue_size_ = from._impl_.queue_size_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.wait_seconds_ = from._impl_.wait_seconds_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.estimated_wait_seconds_remaining_ = from._impl_.estimated_wait_seconds_remaining_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CMsgConnectionStatus::CopyFrom(const CMsgConnectionStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgConnectionStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgConnectionStatus::IsInitialized() const {
  return true;
}

void CMsgConnectionStatus::InternalSwap(CMsgConnectionStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgConnectionStatus, _impl_.estimated_wait_seconds_remaining_)
      + sizeof(CMsgConnectionStatus::_impl_.estimated_wait_seconds_remaining_)
      - PROTOBUF_FIELD_OFFSET(CMsgConnectionStatus, _impl_.status_)>(
          reinterpret_cast<char*>(&_impl_.status_),
          reinterpret_cast<char*>(&other->_impl_.status_));
}

std::string CMsgConnectionStatus::GetTypeName() const {
  return "CMsgConnectionStatus";
}


// ===================================================================

class CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::_Internal {
 public:
  using HasBits = decltype(std::declval<CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock>()._impl_._has_bits_);
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock)
}
CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock(const CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.descriptions_){from._impl_.descriptions_}
    , decltype(_impl_.language_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_language()) {
    _this->_impl_.language_.Set(from._internal_language(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock)
}

inline void CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.descriptions_){arena}
    , decltype(_impl_.language_){}
  };
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::~CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock() {
  // @@protoc_insertion_point(destructor:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.descriptions_.~RepeatedPtrField();
  _impl_.language_.Destroy();
}

void CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::Clear() {
// @@protoc_insertion_point(message_clear_start:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.descriptions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.language_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string language = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_language();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription descriptions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_descriptions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string language = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_language(), target);
  }

  // repeated .CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription descriptions = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_descriptions_size()); i < n; i++) {
    const auto& repfield = this->_internal_descriptions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock)
  return target;
}

size_t CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription descriptions = 2;
  total_size += 1UL * this->_internal_descriptions_size();
  for (const auto& msg : this->_impl_.descriptions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string language = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_language());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock*>(
      &from));
}

void CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::MergeFrom(const CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock& from) {
  CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.descriptions_.MergeFrom(from._impl_.descriptions_);
  if (from._internal_has_language()) {
    _this->_internal_set_language(from._internal_language());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::CopyFrom(const CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::IsInitialized() const {
  return true;
}

void CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::InternalSwap(CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.descriptions_.InternalSwap(&other->_impl_.descriptions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.language_, lhs_arena,
      &other->_impl_.language_, rhs_arena
  );
}

std::string CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::GetTypeName() const {
  return "CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock";
}


// ===================================================================

class CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::_Internal {
 public:
  using HasBits = decltype(std::declval<CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription>()._impl_._has_bits_);
  static void set_has_gameitemid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_item_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_one_per_account(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription)
}
CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription(const CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_description_){}
    , decltype(_impl_.gameitemid_){}
    , decltype(_impl_.one_per_account_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.item_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.item_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_item_description()) {
    _this->_impl_.item_description_.Set(from._internal_item_description(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.gameitemid_, &from._impl_.gameitemid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.one_per_account_) -
    reinterpret_cast<char*>(&_impl_.gameitemid_)) + sizeof(_impl_.one_per_account_));
  // @@protoc_insertion_point(copy_constructor:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription)
}

inline void CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_description_){}
    , decltype(_impl_.gameitemid_){0u}
    , decltype(_impl_.one_per_account_){false}
  };
  _impl_.item_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.item_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::~CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription() {
  // @@protoc_insertion_point(destructor:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.item_description_.Destroy();
}

void CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::Clear() {
// @@protoc_insertion_point(message_clear_start:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.item_description_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.gameitemid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.one_per_account_) -
        reinterpret_cast<char*>(&_impl_.gameitemid_)) + sizeof(_impl_.one_per_account_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 gameitemid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameitemid(&has_bits);
          _impl_.gameitemid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string item_description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_item_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool one_per_account = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_one_per_account(&has_bits);
          _impl_.one_per_account_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 gameitemid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameitemid(), target);
  }

  // optional string item_description = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_item_description(), target);
  }

  // optional bool one_per_account = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_one_per_account(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription)
  return target;
}

size_t CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string item_description = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_item_description());
    }

    // optional uint32 gameitemid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gameitemid());
    }

    // optional bool one_per_account = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription*>(
      &from));
}

void CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::MergeFrom(const CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription& from) {
  CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_item_description(from._internal_item_description());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.gameitemid_ = from._impl_.gameitemid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.one_per_account_ = from._impl_.one_per_account_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::CopyFrom(const CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::IsInitialized() const {
  return true;
}

void CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::InternalSwap(CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.item_description_, lhs_arena,
      &other->_impl_.item_description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription, _impl_.one_per_account_)
      + sizeof(CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::_impl_.one_per_account_)
      - PROTOBUF_FIELD_OFFSET(CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription, _impl_.gameitemid_)>(
          reinterpret_cast<char*>(&_impl_.gameitemid_),
          reinterpret_cast<char*>(&other->_impl_.gameitemid_));
}

std::string CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::GetTypeName() const {
  return "CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription";
}


// ===================================================================

class CWorkshop_PopulateItemDescriptions_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CWorkshop_PopulateItemDescriptions_Request>()._impl_._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CWorkshop_PopulateItemDescriptions_Request::CWorkshop_PopulateItemDescriptions_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CWorkshop_PopulateItemDescriptions_Request)
}
CWorkshop_PopulateItemDescriptions_Request::CWorkshop_PopulateItemDescriptions_Request(const CWorkshop_PopulateItemDescriptions_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CWorkshop_PopulateItemDescriptions_Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.languages_){from._impl_.languages_}
    , decltype(_impl_.appid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.appid_ = from._impl_.appid_;
  // @@protoc_insertion_point(copy_constructor:CWorkshop_PopulateItemDescriptions_Request)
}

inline void CWorkshop_PopulateItemDescriptions_Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.languages_){arena}
    , decltype(_impl_.appid_){0u}
  };
}

CWorkshop_PopulateItemDescriptions_Request::~CWorkshop_PopulateItemDescriptions_Request() {
  // @@protoc_insertion_point(destructor:CWorkshop_PopulateItemDescriptions_Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CWorkshop_PopulateItemDescriptions_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.languages_.~RepeatedPtrField();
}

void CWorkshop_PopulateItemDescriptions_Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CWorkshop_PopulateItemDescriptions_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CWorkshop_PopulateItemDescriptions_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.languages_.Clear();
  _impl_.appid_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CWorkshop_PopulateItemDescriptions_Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          _impl_.appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock languages = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_languages(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CWorkshop_PopulateItemDescriptions_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CWorkshop_PopulateItemDescriptions_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // repeated .CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock languages = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_languages_size()); i < n; i++) {
    const auto& repfield = this->_internal_languages(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CWorkshop_PopulateItemDescriptions_Request)
  return target;
}

size_t CWorkshop_PopulateItemDescriptions_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CWorkshop_PopulateItemDescriptions_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock languages = 2;
  total_size += 1UL * this->_internal_languages_size();
  for (const auto& msg : this->_impl_.languages_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint32 appid = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CWorkshop_PopulateItemDescriptions_Request::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CWorkshop_PopulateItemDescriptions_Request*>(
      &from));
}

void CWorkshop_PopulateItemDescriptions_Request::MergeFrom(const CWorkshop_PopulateItemDescriptions_Request& from) {
  CWorkshop_PopulateItemDescriptions_Request* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CWorkshop_PopulateItemDescriptions_Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.languages_.MergeFrom(from._impl_.languages_);
  if (from._internal_has_appid()) {
    _this->_internal_set_appid(from._internal_appid());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CWorkshop_PopulateItemDescriptions_Request::CopyFrom(const CWorkshop_PopulateItemDescriptions_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CWorkshop_PopulateItemDescriptions_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CWorkshop_PopulateItemDescriptions_Request::IsInitialized() const {
  return true;
}

void CWorkshop_PopulateItemDescriptions_Request::InternalSwap(CWorkshop_PopulateItemDescriptions_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.languages_.InternalSwap(&other->_impl_.languages_);
  swap(_impl_.appid_, other->_impl_.appid_);
}

std::string CWorkshop_PopulateItemDescriptions_Request::GetTypeName() const {
  return "CWorkshop_PopulateItemDescriptions_Request";
}


// ===================================================================

class CWorkshop_GetContributors_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CWorkshop_GetContributors_Request>()._impl_._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_gameitemid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CWorkshop_GetContributors_Request::CWorkshop_GetContributors_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CWorkshop_GetContributors_Request)
}
CWorkshop_GetContributors_Request::CWorkshop_GetContributors_Request(const CWorkshop_GetContributors_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CWorkshop_GetContributors_Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.appid_){}
    , decltype(_impl_.gameitemid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.appid_, &from._impl_.appid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.gameitemid_) -
    reinterpret_cast<char*>(&_impl_.appid_)) + sizeof(_impl_.gameitemid_));
  // @@protoc_insertion_point(copy_constructor:CWorkshop_GetContributors_Request)
}

inline void CWorkshop_GetContributors_Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.appid_){0u}
    , decltype(_impl_.gameitemid_){0u}
  };
}

CWorkshop_GetContributors_Request::~CWorkshop_GetContributors_Request() {
  // @@protoc_insertion_point(destructor:CWorkshop_GetContributors_Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CWorkshop_GetContributors_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CWorkshop_GetContributors_Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CWorkshop_GetContributors_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CWorkshop_GetContributors_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.gameitemid_) -
        reinterpret_cast<char*>(&_impl_.appid_)) + sizeof(_impl_.gameitemid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CWorkshop_GetContributors_Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          _impl_.appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gameitemid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_gameitemid(&has_bits);
          _impl_.gameitemid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CWorkshop_GetContributors_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CWorkshop_GetContributors_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional uint32 gameitemid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_gameitemid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CWorkshop_GetContributors_Request)
  return target;
}

size_t CWorkshop_GetContributors_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CWorkshop_GetContributors_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional uint32 gameitemid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gameitemid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CWorkshop_GetContributors_Request::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CWorkshop_GetContributors_Request*>(
      &from));
}

void CWorkshop_GetContributors_Request::MergeFrom(const CWorkshop_GetContributors_Request& from) {
  CWorkshop_GetContributors_Request* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CWorkshop_GetContributors_Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.appid_ = from._impl_.appid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.gameitemid_ = from._impl_.gameitemid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CWorkshop_GetContributors_Request::CopyFrom(const CWorkshop_GetContributors_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CWorkshop_GetContributors_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CWorkshop_GetContributors_Request::IsInitialized() const {
  return true;
}

void CWorkshop_GetContributors_Request::InternalSwap(CWorkshop_GetContributors_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CWorkshop_GetContributors_Request, _impl_.gameitemid_)
      + sizeof(CWorkshop_GetContributors_Request::_impl_.gameitemid_)
      - PROTOBUF_FIELD_OFFSET(CWorkshop_GetContributors_Request, _impl_.appid_)>(
          reinterpret_cast<char*>(&_impl_.appid_),
          reinterpret_cast<char*>(&other->_impl_.appid_));
}

std::string CWorkshop_GetContributors_Request::GetTypeName() const {
  return "CWorkshop_GetContributors_Request";
}


// ===================================================================

class CWorkshop_GetContributors_Response::_Internal {
 public:
};

CWorkshop_GetContributors_Response::CWorkshop_GetContributors_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CWorkshop_GetContributors_Response)
}
CWorkshop_GetContributors_Response::CWorkshop_GetContributors_Response(const CWorkshop_GetContributors_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CWorkshop_GetContributors_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.contributors_){from._impl_.contributors_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CWorkshop_GetContributors_Response)
}

inline void CWorkshop_GetContributors_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.contributors_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CWorkshop_GetContributors_Response::~CWorkshop_GetContributors_Response() {
  // @@protoc_insertion_point(destructor:CWorkshop_GetContributors_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CWorkshop_GetContributors_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contributors_.~RepeatedField();
}

void CWorkshop_GetContributors_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CWorkshop_GetContributors_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CWorkshop_GetContributors_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.contributors_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CWorkshop_GetContributors_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated fixed64 contributors = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_contributors(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr));
            ptr += sizeof(uint64_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<9>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed64Parser(_internal_mutable_contributors(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CWorkshop_GetContributors_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CWorkshop_GetContributors_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated fixed64 contributors = 1;
  for (int i = 0, n = this->_internal_contributors_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_contributors(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CWorkshop_GetContributors_Response)
  return target;
}

size_t CWorkshop_GetContributors_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CWorkshop_GetContributors_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed64 contributors = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_contributors_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_contributors_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CWorkshop_GetContributors_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CWorkshop_GetContributors_Response*>(
      &from));
}

void CWorkshop_GetContributors_Response::MergeFrom(const CWorkshop_GetContributors_Response& from) {
  CWorkshop_GetContributors_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CWorkshop_GetContributors_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.contributors_.MergeFrom(from._impl_.contributors_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CWorkshop_GetContributors_Response::CopyFrom(const CWorkshop_GetContributors_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CWorkshop_GetContributors_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CWorkshop_GetContributors_Response::IsInitialized() const {
  return true;
}

void CWorkshop_GetContributors_Response::InternalSwap(CWorkshop_GetContributors_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.contributors_.InternalSwap(&other->_impl_.contributors_);
}

std::string CWorkshop_GetContributors_Response::GetTypeName() const {
  return "CWorkshop_GetContributors_Response";
}


// ===================================================================

class CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::_Internal {
 public:
  using HasBits = decltype(std::declval<CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule>()._impl_._has_bits_);
  static void set_has_workshop_file_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_revenue_percentage(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rule_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rule_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule)
}
CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule(const CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rule_description_){}
    , decltype(_impl_.workshop_file_id_){}
    , decltype(_impl_.revenue_percentage_){}
    , decltype(_impl_.rule_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.rule_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rule_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_rule_description()) {
    _this->_impl_.rule_description_.Set(from._internal_rule_description(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.workshop_file_id_, &from._impl_.workshop_file_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.rule_type_) -
    reinterpret_cast<char*>(&_impl_.workshop_file_id_)) + sizeof(_impl_.rule_type_));
  // @@protoc_insertion_point(copy_constructor:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule)
}

inline void CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rule_description_){}
    , decltype(_impl_.workshop_file_id_){uint64_t{0u}}
    , decltype(_impl_.revenue_percentage_){0}
    , decltype(_impl_.rule_type_){1u}
  };
  _impl_.rule_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rule_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::~CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule() {
  // @@protoc_insertion_point(destructor:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.rule_description_.Destroy();
}

void CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::Clear() {
// @@protoc_insertion_point(message_clear_start:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.rule_description_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.workshop_file_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.revenue_percentage_) -
        reinterpret_cast<char*>(&_impl_.workshop_file_id_)) + sizeof(_impl_.revenue_percentage_));
    _impl_.rule_type_ = 1u;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 workshop_file_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_workshop_file_id(&has_bits);
          _impl_.workshop_file_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float revenue_percentage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_revenue_percentage(&has_bits);
          _impl_.revenue_percentage_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional string rule_description = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_rule_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rule_type = 4 [default = 1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_rule_type(&has_bits);
          _impl_.rule_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 workshop_file_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_workshop_file_id(), target);
  }

  // optional float revenue_percentage = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_revenue_percentage(), target);
  }

  // optional string rule_description = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_rule_description(), target);
  }

  // optional uint32 rule_type = 4 [default = 1];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_rule_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule)
  return target;
}

size_t CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string rule_description = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_rule_description());
    }

    // optional uint64 workshop_file_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_workshop_file_id());
    }

    // optional float revenue_percentage = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 rule_type = 4 [default = 1];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rule_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule*>(
      &from));
}

void CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::MergeFrom(const CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule& from) {
  CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_rule_description(from._internal_rule_description());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.workshop_file_id_ = from._impl_.workshop_file_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.revenue_percentage_ = from._impl_.revenue_percentage_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.rule_type_ = from._impl_.rule_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::CopyFrom(const CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::IsInitialized() const {
  return true;
}

void CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::InternalSwap(CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.rule_description_, lhs_arena,
      &other->_impl_.rule_description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule, _impl_.revenue_percentage_)
      + sizeof(CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::_impl_.revenue_percentage_)
      - PROTOBUF_FIELD_OFFSET(CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule, _impl_.workshop_file_id_)>(
          reinterpret_cast<char*>(&_impl_.workshop_file_id_),
          reinterpret_cast<char*>(&other->_impl_.workshop_file_id_));
  swap(_impl_.rule_type_, other->_impl_.rule_type_);
}

std::string CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::GetTypeName() const {
  return "CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule";
}


// ===================================================================

class CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::_Internal {
 public:
  using HasBits = decltype(std::declval<CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_revenue_percentage(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rule_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule)
}
CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule(const CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rule_description_){}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.revenue_percentage_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.rule_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rule_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_rule_description()) {
    _this->_impl_.rule_description_.Set(from._internal_rule_description(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.revenue_percentage_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.revenue_percentage_));
  // @@protoc_insertion_point(copy_constructor:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule)
}

inline void CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rule_description_){}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.revenue_percentage_){0}
  };
  _impl_.rule_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rule_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::~CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule() {
  // @@protoc_insertion_point(destructor:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.rule_description_.Destroy();
}

void CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::Clear() {
// @@protoc_insertion_point(message_clear_start:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.rule_description_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.revenue_percentage_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.revenue_percentage_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float revenue_percentage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_revenue_percentage(&has_bits);
          _impl_.revenue_percentage_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional string rule_description = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_rule_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional float revenue_percentage = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_revenue_percentage(), target);
  }

  // optional string rule_description = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_rule_description(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule)
  return target;
}

size_t CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string rule_description = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_rule_description());
    }

    // optional uint32 account_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional float revenue_percentage = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule*>(
      &from));
}

void CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::MergeFrom(const CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule& from) {
  CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_rule_description(from._internal_rule_description());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.revenue_percentage_ = from._impl_.revenue_percentage_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::CopyFrom(const CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::IsInitialized() const {
  return true;
}

void CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::InternalSwap(CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.rule_description_, lhs_arena,
      &other->_impl_.rule_description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule, _impl_.revenue_percentage_)
      + sizeof(CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::_impl_.revenue_percentage_)
      - PROTOBUF_FIELD_OFFSET(CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

std::string CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::GetTypeName() const {
  return "CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule";
}


// ===================================================================

class CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::_Internal {
 public:
  using HasBits = decltype(std::declval<CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule>()._impl_._has_bits_);
  static void set_has_workshop_file_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rule_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule)
}
CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule(const CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rule_description_){}
    , decltype(_impl_.workshop_file_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.rule_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rule_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_rule_description()) {
    _this->_impl_.rule_description_.Set(from._internal_rule_description(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.workshop_file_id_ = from._impl_.workshop_file_id_;
  // @@protoc_insertion_point(copy_constructor:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule)
}

inline void CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rule_description_){}
    , decltype(_impl_.workshop_file_id_){uint64_t{0u}}
  };
  _impl_.rule_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rule_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::~CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule() {
  // @@protoc_insertion_point(destructor:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.rule_description_.Destroy();
}

void CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::Clear() {
// @@protoc_insertion_point(message_clear_start:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.rule_description_.ClearNonDefaultToEmpty();
  }
  _impl_.workshop_file_id_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 workshop_file_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_workshop_file_id(&has_bits);
          _impl_.workshop_file_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string rule_description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_rule_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 workshop_file_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_workshop_file_id(), target);
  }

  // optional string rule_description = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_rule_description(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule)
  return target;
}

size_t CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string rule_description = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_rule_description());
    }

    // optional uint64 workshop_file_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_workshop_file_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule*>(
      &from));
}

void CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::MergeFrom(const CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule& from) {
  CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_rule_description(from._internal_rule_description());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.workshop_file_id_ = from._impl_.workshop_file_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::CopyFrom(const CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::IsInitialized() const {
  return true;
}

void CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::InternalSwap(CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.rule_description_, lhs_arena,
      &other->_impl_.rule_description_, rhs_arena
  );
  swap(_impl_.workshop_file_id_, other->_impl_.workshop_file_id_);
}

std::string CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::GetTypeName() const {
  return "CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule";
}


// ===================================================================

class CWorkshop_SetItemPaymentRules_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CWorkshop_SetItemPaymentRules_Request>()._impl_._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_gameitemid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_validate_only(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_make_workshop_files_subscribable(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule& associated_workshop_file_for_direct_payments(const CWorkshop_SetItemPaymentRules_Request* msg);
  static void set_has_associated_workshop_file_for_direct_payments(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule&
CWorkshop_SetItemPaymentRules_Request::_Internal::associated_workshop_file_for_direct_payments(const CWorkshop_SetItemPaymentRules_Request* msg) {
  return *msg->_impl_.associated_workshop_file_for_direct_payments_;
}
CWorkshop_SetItemPaymentRules_Request::CWorkshop_SetItemPaymentRules_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CWorkshop_SetItemPaymentRules_Request)
}
CWorkshop_SetItemPaymentRules_Request::CWorkshop_SetItemPaymentRules_Request(const CWorkshop_SetItemPaymentRules_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CWorkshop_SetItemPaymentRules_Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.associated_workshop_files_){from._impl_.associated_workshop_files_}
    , decltype(_impl_.partner_accounts_){from._impl_.partner_accounts_}
    , decltype(_impl_.associated_workshop_file_for_direct_payments_){nullptr}
    , decltype(_impl_.appid_){}
    , decltype(_impl_.gameitemid_){}
    , decltype(_impl_.validate_only_){}
    , decltype(_impl_.make_workshop_files_subscribable_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_associated_workshop_file_for_direct_payments()) {
    _this->_impl_.associated_workshop_file_for_direct_payments_ = new ::CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule(*from._impl_.associated_workshop_file_for_direct_payments_);
  }
  ::memcpy(&_impl_.appid_, &from._impl_.appid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.make_workshop_files_subscribable_) -
    reinterpret_cast<char*>(&_impl_.appid_)) + sizeof(_impl_.make_workshop_files_subscribable_));
  // @@protoc_insertion_point(copy_constructor:CWorkshop_SetItemPaymentRules_Request)
}

inline void CWorkshop_SetItemPaymentRules_Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.associated_workshop_files_){arena}
    , decltype(_impl_.partner_accounts_){arena}
    , decltype(_impl_.associated_workshop_file_for_direct_payments_){nullptr}
    , decltype(_impl_.appid_){0u}
    , decltype(_impl_.gameitemid_){0u}
    , decltype(_impl_.validate_only_){false}
    , decltype(_impl_.make_workshop_files_subscribable_){false}
  };
}

CWorkshop_SetItemPaymentRules_Request::~CWorkshop_SetItemPaymentRules_Request() {
  // @@protoc_insertion_point(destructor:CWorkshop_SetItemPaymentRules_Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CWorkshop_SetItemPaymentRules_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.associated_workshop_files_.~RepeatedPtrField();
  _impl_.partner_accounts_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.associated_workshop_file_for_direct_payments_;
}

void CWorkshop_SetItemPaymentRules_Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CWorkshop_SetItemPaymentRules_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CWorkshop_SetItemPaymentRules_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.associated_workshop_files_.Clear();
  _impl_.partner_accounts_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.associated_workshop_file_for_direct_payments_ != nullptr);
    _impl_.associated_workshop_file_for_direct_payments_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.make_workshop_files_subscribable_) -
        reinterpret_cast<char*>(&_impl_.appid_)) + sizeof(_impl_.make_workshop_files_subscribable_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CWorkshop_SetItemPaymentRules_Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          _impl_.appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gameitemid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_gameitemid(&has_bits);
          _impl_.gameitemid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule associated_workshop_files = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_associated_workshop_files(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule partner_accounts = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_partner_accounts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool validate_only = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_validate_only(&has_bits);
          _impl_.validate_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool make_workshop_files_subscribable = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_make_workshop_files_subscribable(&has_bits);
          _impl_.make_workshop_files_subscribable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule associated_workshop_file_for_direct_payments = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_associated_workshop_file_for_direct_payments(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CWorkshop_SetItemPaymentRules_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CWorkshop_SetItemPaymentRules_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional uint32 gameitemid = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_gameitemid(), target);
  }

  // repeated .CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule associated_workshop_files = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_associated_workshop_files_size()); i < n; i++) {
    const auto& repfield = this->_internal_associated_workshop_files(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule partner_accounts = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_partner_accounts_size()); i < n; i++) {
    const auto& repfield = this->_internal_partner_accounts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool validate_only = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_validate_only(), target);
  }

  // optional bool make_workshop_files_subscribable = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_make_workshop_files_subscribable(), target);
  }

  // optional .CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule associated_workshop_file_for_direct_payments = 7;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::associated_workshop_file_for_direct_payments(this),
        _Internal::associated_workshop_file_for_direct_payments(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CWorkshop_SetItemPaymentRules_Request)
  return target;
}

size_t CWorkshop_SetItemPaymentRules_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CWorkshop_SetItemPaymentRules_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule associated_workshop_files = 3;
  total_size += 1UL * this->_internal_associated_workshop_files_size();
  for (const auto& msg : this->_impl_.associated_workshop_files_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule partner_accounts = 4;
  total_size += 1UL * this->_internal_partner_accounts_size();
  for (const auto& msg : this->_impl_.partner_accounts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule associated_workshop_file_for_direct_payments = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.associated_workshop_file_for_direct_payments_);
    }

    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional uint32 gameitemid = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gameitemid());
    }

    // optional bool validate_only = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool make_workshop_files_subscribable = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CWorkshop_SetItemPaymentRules_Request::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CWorkshop_SetItemPaymentRules_Request*>(
      &from));
}

void CWorkshop_SetItemPaymentRules_Request::MergeFrom(const CWorkshop_SetItemPaymentRules_Request& from) {
  CWorkshop_SetItemPaymentRules_Request* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CWorkshop_SetItemPaymentRules_Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.associated_workshop_files_.MergeFrom(from._impl_.associated_workshop_files_);
  _this->_impl_.partner_accounts_.MergeFrom(from._impl_.partner_accounts_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_associated_workshop_file_for_direct_payments()->::CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::MergeFrom(
          from._internal_associated_workshop_file_for_direct_payments());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.appid_ = from._impl_.appid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.gameitemid_ = from._impl_.gameitemid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.validate_only_ = from._impl_.validate_only_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.make_workshop_files_subscribable_ = from._impl_.make_workshop_files_subscribable_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CWorkshop_SetItemPaymentRules_Request::CopyFrom(const CWorkshop_SetItemPaymentRules_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CWorkshop_SetItemPaymentRules_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CWorkshop_SetItemPaymentRules_Request::IsInitialized() const {
  return true;
}

void CWorkshop_SetItemPaymentRules_Request::InternalSwap(CWorkshop_SetItemPaymentRules_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.associated_workshop_files_.InternalSwap(&other->_impl_.associated_workshop_files_);
  _impl_.partner_accounts_.InternalSwap(&other->_impl_.partner_accounts_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CWorkshop_SetItemPaymentRules_Request, _impl_.make_workshop_files_subscribable_)
      + sizeof(CWorkshop_SetItemPaymentRules_Request::_impl_.make_workshop_files_subscribable_)
      - PROTOBUF_FIELD_OFFSET(CWorkshop_SetItemPaymentRules_Request, _impl_.associated_workshop_file_for_direct_payments_)>(
          reinterpret_cast<char*>(&_impl_.associated_workshop_file_for_direct_payments_),
          reinterpret_cast<char*>(&other->_impl_.associated_workshop_file_for_direct_payments_));
}

std::string CWorkshop_SetItemPaymentRules_Request::GetTypeName() const {
  return "CWorkshop_SetItemPaymentRules_Request";
}


// ===================================================================

class CWorkshop_SetItemPaymentRules_Response::_Internal {
 public:
};

CWorkshop_SetItemPaymentRules_Response::CWorkshop_SetItemPaymentRules_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CWorkshop_SetItemPaymentRules_Response)
}
CWorkshop_SetItemPaymentRules_Response::CWorkshop_SetItemPaymentRules_Response(const CWorkshop_SetItemPaymentRules_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CWorkshop_SetItemPaymentRules_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CWorkshop_SetItemPaymentRules_Response)
}

inline void CWorkshop_SetItemPaymentRules_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

CWorkshop_SetItemPaymentRules_Response::~CWorkshop_SetItemPaymentRules_Response() {
  // @@protoc_insertion_point(destructor:CWorkshop_SetItemPaymentRules_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CWorkshop_SetItemPaymentRules_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CWorkshop_SetItemPaymentRules_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CWorkshop_SetItemPaymentRules_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CWorkshop_SetItemPaymentRules_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* CWorkshop_SetItemPaymentRules_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CWorkshop_SetItemPaymentRules_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CWorkshop_SetItemPaymentRules_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CWorkshop_SetItemPaymentRules_Response)
  return target;
}

size_t CWorkshop_SetItemPaymentRules_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CWorkshop_SetItemPaymentRules_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CWorkshop_SetItemPaymentRules_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CWorkshop_SetItemPaymentRules_Response*>(
      &from));
}

void CWorkshop_SetItemPaymentRules_Response::MergeFrom(const CWorkshop_SetItemPaymentRules_Response& from) {
  CWorkshop_SetItemPaymentRules_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CWorkshop_SetItemPaymentRules_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CWorkshop_SetItemPaymentRules_Response::CopyFrom(const CWorkshop_SetItemPaymentRules_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CWorkshop_SetItemPaymentRules_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CWorkshop_SetItemPaymentRules_Response::IsInitialized() const {
  return true;
}

void CWorkshop_SetItemPaymentRules_Response::InternalSwap(CWorkshop_SetItemPaymentRules_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string CWorkshop_SetItemPaymentRules_Response::GetTypeName() const {
  return "CWorkshop_SetItemPaymentRules_Response";
}


// ===================================================================

class CGameServers_AggregationQuery_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CGameServers_AggregationQuery_Request>()._impl_._has_bits_);
  static void set_has_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CGameServers_AggregationQuery_Request::CGameServers_AggregationQuery_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGameServers_AggregationQuery_Request)
}
CGameServers_AggregationQuery_Request::CGameServers_AggregationQuery_Request(const CGameServers_AggregationQuery_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGameServers_AggregationQuery_Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.group_fields_){from._impl_.group_fields_}
    , decltype(_impl_.filter_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.filter_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filter_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_filter()) {
    _this->_impl_.filter_.Set(from._internal_filter(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CGameServers_AggregationQuery_Request)
}

inline void CGameServers_AggregationQuery_Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.group_fields_){arena}
    , decltype(_impl_.filter_){}
  };
  _impl_.filter_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filter_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CGameServers_AggregationQuery_Request::~CGameServers_AggregationQuery_Request() {
  // @@protoc_insertion_point(destructor:CGameServers_AggregationQuery_Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGameServers_AggregationQuery_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.group_fields_.~RepeatedPtrField();
  _impl_.filter_.Destroy();
}

void CGameServers_AggregationQuery_Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGameServers_AggregationQuery_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CGameServers_AggregationQuery_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.group_fields_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.filter_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CGameServers_AggregationQuery_Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string filter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_filter();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string group_fields = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_group_fields();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGameServers_AggregationQuery_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGameServers_AggregationQuery_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string filter = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_filter(), target);
  }

  // repeated string group_fields = 3;
  for (int i = 0, n = this->_internal_group_fields_size(); i < n; i++) {
    const auto& s = this->_internal_group_fields(i);
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGameServers_AggregationQuery_Request)
  return target;
}

size_t CGameServers_AggregationQuery_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGameServers_AggregationQuery_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string group_fields = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.group_fields_.size());
  for (int i = 0, n = _impl_.group_fields_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.group_fields_.Get(i));
  }

  // optional string filter = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_filter());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGameServers_AggregationQuery_Request::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGameServers_AggregationQuery_Request*>(
      &from));
}

void CGameServers_AggregationQuery_Request::MergeFrom(const CGameServers_AggregationQuery_Request& from) {
  CGameServers_AggregationQuery_Request* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGameServers_AggregationQuery_Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.group_fields_.MergeFrom(from._impl_.group_fields_);
  if (from._internal_has_filter()) {
    _this->_internal_set_filter(from._internal_filter());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGameServers_AggregationQuery_Request::CopyFrom(const CGameServers_AggregationQuery_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGameServers_AggregationQuery_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameServers_AggregationQuery_Request::IsInitialized() const {
  return true;
}

void CGameServers_AggregationQuery_Request::InternalSwap(CGameServers_AggregationQuery_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.group_fields_.InternalSwap(&other->_impl_.group_fields_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.filter_, lhs_arena,
      &other->_impl_.filter_, rhs_arena
  );
}

std::string CGameServers_AggregationQuery_Request::GetTypeName() const {
  return "CGameServers_AggregationQuery_Request";
}


// ===================================================================

class CGameServers_AggregationQuery_Response_Group::_Internal {
 public:
  using HasBits = decltype(std::declval<CGameServers_AggregationQuery_Response_Group>()._impl_._has_bits_);
  static void set_has_servers_empty(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_servers_full(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_servers_total(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_players_humans(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_players_bots(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_player_capacity(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

CGameServers_AggregationQuery_Response_Group::CGameServers_AggregationQuery_Response_Group(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGameServers_AggregationQuery_Response.Group)
}
CGameServers_AggregationQuery_Response_Group::CGameServers_AggregationQuery_Response_Group(const CGameServers_AggregationQuery_Response_Group& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGameServers_AggregationQuery_Response_Group* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.group_values_){from._impl_.group_values_}
    , decltype(_impl_.servers_empty_){}
    , decltype(_impl_.servers_full_){}
    , decltype(_impl_.servers_total_){}
    , decltype(_impl_.players_humans_){}
    , decltype(_impl_.players_bots_){}
    , decltype(_impl_.player_capacity_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.servers_empty_, &from._impl_.servers_empty_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.player_capacity_) -
    reinterpret_cast<char*>(&_impl_.servers_empty_)) + sizeof(_impl_.player_capacity_));
  // @@protoc_insertion_point(copy_constructor:CGameServers_AggregationQuery_Response.Group)
}

inline void CGameServers_AggregationQuery_Response_Group::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.group_values_){arena}
    , decltype(_impl_.servers_empty_){0u}
    , decltype(_impl_.servers_full_){0u}
    , decltype(_impl_.servers_total_){0u}
    , decltype(_impl_.players_humans_){0u}
    , decltype(_impl_.players_bots_){0u}
    , decltype(_impl_.player_capacity_){0u}
  };
}

CGameServers_AggregationQuery_Response_Group::~CGameServers_AggregationQuery_Response_Group() {
  // @@protoc_insertion_point(destructor:CGameServers_AggregationQuery_Response.Group)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGameServers_AggregationQuery_Response_Group::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.group_values_.~RepeatedPtrField();
}

void CGameServers_AggregationQuery_Response_Group::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGameServers_AggregationQuery_Response_Group::Clear() {
// @@protoc_insertion_point(message_clear_start:CGameServers_AggregationQuery_Response.Group)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.group_values_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.servers_empty_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.player_capacity_) -
        reinterpret_cast<char*>(&_impl_.servers_empty_)) + sizeof(_impl_.player_capacity_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CGameServers_AggregationQuery_Response_Group::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string group_values = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_group_values();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 servers_empty = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_servers_empty(&has_bits);
          _impl_.servers_empty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 servers_full = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_servers_full(&has_bits);
          _impl_.servers_full_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 servers_total = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_servers_total(&has_bits);
          _impl_.servers_total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 players_humans = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_players_humans(&has_bits);
          _impl_.players_humans_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 players_bots = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_players_bots(&has_bits);
          _impl_.players_bots_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 player_capacity = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_player_capacity(&has_bits);
          _impl_.player_capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGameServers_AggregationQuery_Response_Group::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGameServers_AggregationQuery_Response.Group)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string group_values = 1;
  for (int i = 0, n = this->_internal_group_values_size(); i < n; i++) {
    const auto& s = this->_internal_group_values(i);
    target = stream->WriteString(1, s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 servers_empty = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_servers_empty(), target);
  }

  // optional uint32 servers_full = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_servers_full(), target);
  }

  // optional uint32 servers_total = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_servers_total(), target);
  }

  // optional uint32 players_humans = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_players_humans(), target);
  }

  // optional uint32 players_bots = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_players_bots(), target);
  }

  // optional uint32 player_capacity = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_player_capacity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGameServers_AggregationQuery_Response.Group)
  return target;
}

size_t CGameServers_AggregationQuery_Response_Group::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGameServers_AggregationQuery_Response.Group)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string group_values = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.group_values_.size());
  for (int i = 0, n = _impl_.group_values_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.group_values_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint32 servers_empty = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_servers_empty());
    }

    // optional uint32 servers_full = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_servers_full());
    }

    // optional uint32 servers_total = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_servers_total());
    }

    // optional uint32 players_humans = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_players_humans());
    }

    // optional uint32 players_bots = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_players_bots());
    }

    // optional uint32 player_capacity = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_player_capacity());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGameServers_AggregationQuery_Response_Group::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGameServers_AggregationQuery_Response_Group*>(
      &from));
}

void CGameServers_AggregationQuery_Response_Group::MergeFrom(const CGameServers_AggregationQuery_Response_Group& from) {
  CGameServers_AggregationQuery_Response_Group* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGameServers_AggregationQuery_Response.Group)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.group_values_.MergeFrom(from._impl_.group_values_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.servers_empty_ = from._impl_.servers_empty_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.servers_full_ = from._impl_.servers_full_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.servers_total_ = from._impl_.servers_total_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.players_humans_ = from._impl_.players_humans_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.players_bots_ = from._impl_.players_bots_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.player_capacity_ = from._impl_.player_capacity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGameServers_AggregationQuery_Response_Group::CopyFrom(const CGameServers_AggregationQuery_Response_Group& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGameServers_AggregationQuery_Response.Group)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameServers_AggregationQuery_Response_Group::IsInitialized() const {
  return true;
}

void CGameServers_AggregationQuery_Response_Group::InternalSwap(CGameServers_AggregationQuery_Response_Group* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.group_values_.InternalSwap(&other->_impl_.group_values_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CGameServers_AggregationQuery_Response_Group, _impl_.player_capacity_)
      + sizeof(CGameServers_AggregationQuery_Response_Group::_impl_.player_capacity_)
      - PROTOBUF_FIELD_OFFSET(CGameServers_AggregationQuery_Response_Group, _impl_.servers_empty_)>(
          reinterpret_cast<char*>(&_impl_.servers_empty_),
          reinterpret_cast<char*>(&other->_impl_.servers_empty_));
}

std::string CGameServers_AggregationQuery_Response_Group::GetTypeName() const {
  return "CGameServers_AggregationQuery_Response.Group";
}


// ===================================================================

class CGameServers_AggregationQuery_Response::_Internal {
 public:
};

CGameServers_AggregationQuery_Response::CGameServers_AggregationQuery_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGameServers_AggregationQuery_Response)
}
CGameServers_AggregationQuery_Response::CGameServers_AggregationQuery_Response(const CGameServers_AggregationQuery_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CGameServers_AggregationQuery_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.groups_){from._impl_.groups_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CGameServers_AggregationQuery_Response)
}

inline void CGameServers_AggregationQuery_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.groups_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CGameServers_AggregationQuery_Response::~CGameServers_AggregationQuery_Response() {
  // @@protoc_insertion_point(destructor:CGameServers_AggregationQuery_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGameServers_AggregationQuery_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.groups_.~RepeatedPtrField();
}

void CGameServers_AggregationQuery_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGameServers_AggregationQuery_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CGameServers_AggregationQuery_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.groups_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CGameServers_AggregationQuery_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CGameServers_AggregationQuery_Response.Group groups = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_groups(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGameServers_AggregationQuery_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGameServers_AggregationQuery_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CGameServers_AggregationQuery_Response.Group groups = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_groups_size()); i < n; i++) {
    const auto& repfield = this->_internal_groups(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGameServers_AggregationQuery_Response)
  return target;
}

size_t CGameServers_AggregationQuery_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGameServers_AggregationQuery_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CGameServers_AggregationQuery_Response.Group groups = 1;
  total_size += 1UL * this->_internal_groups_size();
  for (const auto& msg : this->_impl_.groups_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGameServers_AggregationQuery_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CGameServers_AggregationQuery_Response*>(
      &from));
}

void CGameServers_AggregationQuery_Response::MergeFrom(const CGameServers_AggregationQuery_Response& from) {
  CGameServers_AggregationQuery_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CGameServers_AggregationQuery_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.groups_.MergeFrom(from._impl_.groups_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CGameServers_AggregationQuery_Response::CopyFrom(const CGameServers_AggregationQuery_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGameServers_AggregationQuery_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameServers_AggregationQuery_Response::IsInitialized() const {
  return true;
}

void CGameServers_AggregationQuery_Response::InternalSwap(CGameServers_AggregationQuery_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.groups_.InternalSwap(&other->_impl_.groups_);
}

std::string CGameServers_AggregationQuery_Response::GetTypeName() const {
  return "CGameServers_AggregationQuery_Response";
}


// ===================================================================

class CWorkshop_AddSpecialPayment_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CWorkshop_AddSpecialPayment_Request>()._impl_._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_gameitemid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_date(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_payment_us_usd(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_payment_row_usd(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CWorkshop_AddSpecialPayment_Request::CWorkshop_AddSpecialPayment_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CWorkshop_AddSpecialPayment_Request)
}
CWorkshop_AddSpecialPayment_Request::CWorkshop_AddSpecialPayment_Request(const CWorkshop_AddSpecialPayment_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CWorkshop_AddSpecialPayment_Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.date_){}
    , decltype(_impl_.appid_){}
    , decltype(_impl_.gameitemid_){}
    , decltype(_impl_.payment_us_usd_){}
    , decltype(_impl_.payment_row_usd_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.date_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_date()) {
    _this->_impl_.date_.Set(from._internal_date(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.appid_, &from._impl_.appid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.payment_row_usd_) -
    reinterpret_cast<char*>(&_impl_.appid_)) + sizeof(_impl_.payment_row_usd_));
  // @@protoc_insertion_point(copy_constructor:CWorkshop_AddSpecialPayment_Request)
}

inline void CWorkshop_AddSpecialPayment_Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.date_){}
    , decltype(_impl_.appid_){0u}
    , decltype(_impl_.gameitemid_){0u}
    , decltype(_impl_.payment_us_usd_){uint64_t{0u}}
    , decltype(_impl_.payment_row_usd_){uint64_t{0u}}
  };
  _impl_.date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.date_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CWorkshop_AddSpecialPayment_Request::~CWorkshop_AddSpecialPayment_Request() {
  // @@protoc_insertion_point(destructor:CWorkshop_AddSpecialPayment_Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CWorkshop_AddSpecialPayment_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.date_.Destroy();
}

void CWorkshop_AddSpecialPayment_Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CWorkshop_AddSpecialPayment_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CWorkshop_AddSpecialPayment_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.date_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.payment_row_usd_) -
        reinterpret_cast<char*>(&_impl_.appid_)) + sizeof(_impl_.payment_row_usd_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CWorkshop_AddSpecialPayment_Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          _impl_.appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gameitemid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_gameitemid(&has_bits);
          _impl_.gameitemid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string date = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_date();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 payment_us_usd = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_payment_us_usd(&has_bits);
          _impl_.payment_us_usd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 payment_row_usd = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_payment_row_usd(&has_bits);
          _impl_.payment_row_usd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CWorkshop_AddSpecialPayment_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CWorkshop_AddSpecialPayment_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional uint32 gameitemid = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_gameitemid(), target);
  }

  // optional string date = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_date(), target);
  }

  // optional uint64 payment_us_usd = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_payment_us_usd(), target);
  }

  // optional uint64 payment_row_usd = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_payment_row_usd(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CWorkshop_AddSpecialPayment_Request)
  return target;
}

size_t CWorkshop_AddSpecialPayment_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CWorkshop_AddSpecialPayment_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string date = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_date());
    }

    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional uint32 gameitemid = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gameitemid());
    }

    // optional uint64 payment_us_usd = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_payment_us_usd());
    }

    // optional uint64 payment_row_usd = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_payment_row_usd());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CWorkshop_AddSpecialPayment_Request::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CWorkshop_AddSpecialPayment_Request*>(
      &from));
}

void CWorkshop_AddSpecialPayment_Request::MergeFrom(const CWorkshop_AddSpecialPayment_Request& from) {
  CWorkshop_AddSpecialPayment_Request* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CWorkshop_AddSpecialPayment_Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_date(from._internal_date());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.appid_ = from._impl_.appid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.gameitemid_ = from._impl_.gameitemid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.payment_us_usd_ = from._impl_.payment_us_usd_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.payment_row_usd_ = from._impl_.payment_row_usd_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CWorkshop_AddSpecialPayment_Request::CopyFrom(const CWorkshop_AddSpecialPayment_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CWorkshop_AddSpecialPayment_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CWorkshop_AddSpecialPayment_Request::IsInitialized() const {
  return true;
}

void CWorkshop_AddSpecialPayment_Request::InternalSwap(CWorkshop_AddSpecialPayment_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.date_, lhs_arena,
      &other->_impl_.date_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CWorkshop_AddSpecialPayment_Request, _impl_.payment_row_usd_)
      + sizeof(CWorkshop_AddSpecialPayment_Request::_impl_.payment_row_usd_)
      - PROTOBUF_FIELD_OFFSET(CWorkshop_AddSpecialPayment_Request, _impl_.appid_)>(
          reinterpret_cast<char*>(&_impl_.appid_),
          reinterpret_cast<char*>(&other->_impl_.appid_));
}

std::string CWorkshop_AddSpecialPayment_Request::GetTypeName() const {
  return "CWorkshop_AddSpecialPayment_Request";
}


// ===================================================================

class CWorkshop_AddSpecialPayment_Response::_Internal {
 public:
};

CWorkshop_AddSpecialPayment_Response::CWorkshop_AddSpecialPayment_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CWorkshop_AddSpecialPayment_Response)
}
CWorkshop_AddSpecialPayment_Response::CWorkshop_AddSpecialPayment_Response(const CWorkshop_AddSpecialPayment_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CWorkshop_AddSpecialPayment_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CWorkshop_AddSpecialPayment_Response)
}

inline void CWorkshop_AddSpecialPayment_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

CWorkshop_AddSpecialPayment_Response::~CWorkshop_AddSpecialPayment_Response() {
  // @@protoc_insertion_point(destructor:CWorkshop_AddSpecialPayment_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CWorkshop_AddSpecialPayment_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CWorkshop_AddSpecialPayment_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CWorkshop_AddSpecialPayment_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CWorkshop_AddSpecialPayment_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* CWorkshop_AddSpecialPayment_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CWorkshop_AddSpecialPayment_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CWorkshop_AddSpecialPayment_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CWorkshop_AddSpecialPayment_Response)
  return target;
}

size_t CWorkshop_AddSpecialPayment_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CWorkshop_AddSpecialPayment_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CWorkshop_AddSpecialPayment_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CWorkshop_AddSpecialPayment_Response*>(
      &from));
}

void CWorkshop_AddSpecialPayment_Response::MergeFrom(const CWorkshop_AddSpecialPayment_Response& from) {
  CWorkshop_AddSpecialPayment_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CWorkshop_AddSpecialPayment_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CWorkshop_AddSpecialPayment_Response::CopyFrom(const CWorkshop_AddSpecialPayment_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CWorkshop_AddSpecialPayment_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CWorkshop_AddSpecialPayment_Response::IsInitialized() const {
  return true;
}

void CWorkshop_AddSpecialPayment_Response::InternalSwap(CWorkshop_AddSpecialPayment_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string CWorkshop_AddSpecialPayment_Response::GetTypeName() const {
  return "CWorkshop_AddSpecialPayment_Response";
}


// ===================================================================

class CProductInfo_SetRichPresenceLocalization_Request_LanguageSection::_Internal {
 public:
  using HasBits = decltype(std::declval<CProductInfo_SetRichPresenceLocalization_Request_LanguageSection>()._impl_._has_bits_);
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CProductInfo_SetRichPresenceLocalization_Request_LanguageSection::CProductInfo_SetRichPresenceLocalization_Request_LanguageSection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CProductInfo_SetRichPresenceLocalization_Request.LanguageSection)
}
CProductInfo_SetRichPresenceLocalization_Request_LanguageSection::CProductInfo_SetRichPresenceLocalization_Request_LanguageSection(const CProductInfo_SetRichPresenceLocalization_Request_LanguageSection& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CProductInfo_SetRichPresenceLocalization_Request_LanguageSection* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tokens_){from._impl_.tokens_}
    , decltype(_impl_.language_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_language()) {
    _this->_impl_.language_.Set(from._internal_language(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CProductInfo_SetRichPresenceLocalization_Request.LanguageSection)
}

inline void CProductInfo_SetRichPresenceLocalization_Request_LanguageSection::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tokens_){arena}
    , decltype(_impl_.language_){}
  };
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CProductInfo_SetRichPresenceLocalization_Request_LanguageSection::~CProductInfo_SetRichPresenceLocalization_Request_LanguageSection() {
  // @@protoc_insertion_point(destructor:CProductInfo_SetRichPresenceLocalization_Request.LanguageSection)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CProductInfo_SetRichPresenceLocalization_Request_LanguageSection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tokens_.~RepeatedPtrField();
  _impl_.language_.Destroy();
}

void CProductInfo_SetRichPresenceLocalization_Request_LanguageSection::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CProductInfo_SetRichPresenceLocalization_Request_LanguageSection::Clear() {
// @@protoc_insertion_point(message_clear_start:CProductInfo_SetRichPresenceLocalization_Request.LanguageSection)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tokens_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.language_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CProductInfo_SetRichPresenceLocalization_Request_LanguageSection::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string language = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_language();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CProductInfo_SetRichPresenceLocalization_Request.Token tokens = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tokens(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CProductInfo_SetRichPresenceLocalization_Request_LanguageSection::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CProductInfo_SetRichPresenceLocalization_Request.LanguageSection)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string language = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_language(), target);
  }

  // repeated .CProductInfo_SetRichPresenceLocalization_Request.Token tokens = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tokens_size()); i < n; i++) {
    const auto& repfield = this->_internal_tokens(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CProductInfo_SetRichPresenceLocalization_Request.LanguageSection)
  return target;
}

size_t CProductInfo_SetRichPresenceLocalization_Request_LanguageSection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CProductInfo_SetRichPresenceLocalization_Request.LanguageSection)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CProductInfo_SetRichPresenceLocalization_Request.Token tokens = 2;
  total_size += 1UL * this->_internal_tokens_size();
  for (const auto& msg : this->_impl_.tokens_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string language = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_language());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CProductInfo_SetRichPresenceLocalization_Request_LanguageSection::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CProductInfo_SetRichPresenceLocalization_Request_LanguageSection*>(
      &from));
}

void CProductInfo_SetRichPresenceLocalization_Request_LanguageSection::MergeFrom(const CProductInfo_SetRichPresenceLocalization_Request_LanguageSection& from) {
  CProductInfo_SetRichPresenceLocalization_Request_LanguageSection* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CProductInfo_SetRichPresenceLocalization_Request.LanguageSection)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tokens_.MergeFrom(from._impl_.tokens_);
  if (from._internal_has_language()) {
    _this->_internal_set_language(from._internal_language());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CProductInfo_SetRichPresenceLocalization_Request_LanguageSection::CopyFrom(const CProductInfo_SetRichPresenceLocalization_Request_LanguageSection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CProductInfo_SetRichPresenceLocalization_Request.LanguageSection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CProductInfo_SetRichPresenceLocalization_Request_LanguageSection::IsInitialized() const {
  return true;
}

void CProductInfo_SetRichPresenceLocalization_Request_LanguageSection::InternalSwap(CProductInfo_SetRichPresenceLocalization_Request_LanguageSection* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.tokens_.InternalSwap(&other->_impl_.tokens_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.language_, lhs_arena,
      &other->_impl_.language_, rhs_arena
  );
}

std::string CProductInfo_SetRichPresenceLocalization_Request_LanguageSection::GetTypeName() const {
  return "CProductInfo_SetRichPresenceLocalization_Request.LanguageSection";
}


// ===================================================================

class CProductInfo_SetRichPresenceLocalization_Request_Token::_Internal {
 public:
  using HasBits = decltype(std::declval<CProductInfo_SetRichPresenceLocalization_Request_Token>()._impl_._has_bits_);
  static void set_has_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CProductInfo_SetRichPresenceLocalization_Request_Token::CProductInfo_SetRichPresenceLocalization_Request_Token(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CProductInfo_SetRichPresenceLocalization_Request.Token)
}
CProductInfo_SetRichPresenceLocalization_Request_Token::CProductInfo_SetRichPresenceLocalization_Request_Token(const CProductInfo_SetRichPresenceLocalization_Request_Token& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CProductInfo_SetRichPresenceLocalization_Request_Token* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_token()) {
    _this->_impl_.token_.Set(from._internal_token(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CProductInfo_SetRichPresenceLocalization_Request.Token)
}

inline void CProductInfo_SetRichPresenceLocalization_Request_Token::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_){}
    , decltype(_impl_.value_){}
  };
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CProductInfo_SetRichPresenceLocalization_Request_Token::~CProductInfo_SetRichPresenceLocalization_Request_Token() {
  // @@protoc_insertion_point(destructor:CProductInfo_SetRichPresenceLocalization_Request.Token)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CProductInfo_SetRichPresenceLocalization_Request_Token::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.token_.Destroy();
  _impl_.value_.Destroy();
}

void CProductInfo_SetRichPresenceLocalization_Request_Token::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CProductInfo_SetRichPresenceLocalization_Request_Token::Clear() {
// @@protoc_insertion_point(message_clear_start:CProductInfo_SetRichPresenceLocalization_Request.Token)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CProductInfo_SetRichPresenceLocalization_Request_Token::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CProductInfo_SetRichPresenceLocalization_Request_Token::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CProductInfo_SetRichPresenceLocalization_Request.Token)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string token = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_token(), target);
  }

  // optional string value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CProductInfo_SetRichPresenceLocalization_Request.Token)
  return target;
}

size_t CProductInfo_SetRichPresenceLocalization_Request_Token::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CProductInfo_SetRichPresenceLocalization_Request.Token)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string token = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_token());
    }

    // optional string value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CProductInfo_SetRichPresenceLocalization_Request_Token::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CProductInfo_SetRichPresenceLocalization_Request_Token*>(
      &from));
}

void CProductInfo_SetRichPresenceLocalization_Request_Token::MergeFrom(const CProductInfo_SetRichPresenceLocalization_Request_Token& from) {
  CProductInfo_SetRichPresenceLocalization_Request_Token* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CProductInfo_SetRichPresenceLocalization_Request.Token)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_token(from._internal_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CProductInfo_SetRichPresenceLocalization_Request_Token::CopyFrom(const CProductInfo_SetRichPresenceLocalization_Request_Token& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CProductInfo_SetRichPresenceLocalization_Request.Token)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CProductInfo_SetRichPresenceLocalization_Request_Token::IsInitialized() const {
  return true;
}

void CProductInfo_SetRichPresenceLocalization_Request_Token::InternalSwap(CProductInfo_SetRichPresenceLocalization_Request_Token* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.token_, lhs_arena,
      &other->_impl_.token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

std::string CProductInfo_SetRichPresenceLocalization_Request_Token::GetTypeName() const {
  return "CProductInfo_SetRichPresenceLocalization_Request.Token";
}


// ===================================================================

class CProductInfo_SetRichPresenceLocalization_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CProductInfo_SetRichPresenceLocalization_Request>()._impl_._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CProductInfo_SetRichPresenceLocalization_Request::CProductInfo_SetRichPresenceLocalization_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CProductInfo_SetRichPresenceLocalization_Request)
}
CProductInfo_SetRichPresenceLocalization_Request::CProductInfo_SetRichPresenceLocalization_Request(const CProductInfo_SetRichPresenceLocalization_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CProductInfo_SetRichPresenceLocalization_Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.languages_){from._impl_.languages_}
    , decltype(_impl_.steamid_){}
    , decltype(_impl_.appid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.steamid_, &from._impl_.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.appid_) -
    reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.appid_));
  // @@protoc_insertion_point(copy_constructor:CProductInfo_SetRichPresenceLocalization_Request)
}

inline void CProductInfo_SetRichPresenceLocalization_Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.languages_){arena}
    , decltype(_impl_.steamid_){uint64_t{0u}}
    , decltype(_impl_.appid_){0u}
  };
}

CProductInfo_SetRichPresenceLocalization_Request::~CProductInfo_SetRichPresenceLocalization_Request() {
  // @@protoc_insertion_point(destructor:CProductInfo_SetRichPresenceLocalization_Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CProductInfo_SetRichPresenceLocalization_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.languages_.~RepeatedPtrField();
}

void CProductInfo_SetRichPresenceLocalization_Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CProductInfo_SetRichPresenceLocalization_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CProductInfo_SetRichPresenceLocalization_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.languages_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.appid_) -
        reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.appid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CProductInfo_SetRichPresenceLocalization_Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          _impl_.appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CProductInfo_SetRichPresenceLocalization_Request.LanguageSection languages = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_languages(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 steamid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_steamid(&has_bits);
          _impl_.steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CProductInfo_SetRichPresenceLocalization_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CProductInfo_SetRichPresenceLocalization_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // repeated .CProductInfo_SetRichPresenceLocalization_Request.LanguageSection languages = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_languages_size()); i < n; i++) {
    const auto& repfield = this->_internal_languages(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint64 steamid = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_steamid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CProductInfo_SetRichPresenceLocalization_Request)
  return target;
}

size_t CProductInfo_SetRichPresenceLocalization_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CProductInfo_SetRichPresenceLocalization_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CProductInfo_SetRichPresenceLocalization_Request.LanguageSection languages = 2;
  total_size += 1UL * this->_internal_languages_size();
  for (const auto& msg : this->_impl_.languages_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 steamid = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_steamid());
    }

    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CProductInfo_SetRichPresenceLocalization_Request::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CProductInfo_SetRichPresenceLocalization_Request*>(
      &from));
}

void CProductInfo_SetRichPresenceLocalization_Request::MergeFrom(const CProductInfo_SetRichPresenceLocalization_Request& from) {
  CProductInfo_SetRichPresenceLocalization_Request* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CProductInfo_SetRichPresenceLocalization_Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.languages_.MergeFrom(from._impl_.languages_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.steamid_ = from._impl_.steamid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.appid_ = from._impl_.appid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CProductInfo_SetRichPresenceLocalization_Request::CopyFrom(const CProductInfo_SetRichPresenceLocalization_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CProductInfo_SetRichPresenceLocalization_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CProductInfo_SetRichPresenceLocalization_Request::IsInitialized() const {
  return true;
}

void CProductInfo_SetRichPresenceLocalization_Request::InternalSwap(CProductInfo_SetRichPresenceLocalization_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.languages_.InternalSwap(&other->_impl_.languages_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CProductInfo_SetRichPresenceLocalization_Request, _impl_.appid_)
      + sizeof(CProductInfo_SetRichPresenceLocalization_Request::_impl_.appid_)
      - PROTOBUF_FIELD_OFFSET(CProductInfo_SetRichPresenceLocalization_Request, _impl_.steamid_)>(
          reinterpret_cast<char*>(&_impl_.steamid_),
          reinterpret_cast<char*>(&other->_impl_.steamid_));
}

std::string CProductInfo_SetRichPresenceLocalization_Request::GetTypeName() const {
  return "CProductInfo_SetRichPresenceLocalization_Request";
}


// ===================================================================

class CProductInfo_SetRichPresenceLocalization_Response::_Internal {
 public:
};

CProductInfo_SetRichPresenceLocalization_Response::CProductInfo_SetRichPresenceLocalization_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CProductInfo_SetRichPresenceLocalization_Response)
}
CProductInfo_SetRichPresenceLocalization_Response::CProductInfo_SetRichPresenceLocalization_Response(const CProductInfo_SetRichPresenceLocalization_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CProductInfo_SetRichPresenceLocalization_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CProductInfo_SetRichPresenceLocalization_Response)
}

inline void CProductInfo_SetRichPresenceLocalization_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

CProductInfo_SetRichPresenceLocalization_Response::~CProductInfo_SetRichPresenceLocalization_Response() {
  // @@protoc_insertion_point(destructor:CProductInfo_SetRichPresenceLocalization_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CProductInfo_SetRichPresenceLocalization_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CProductInfo_SetRichPresenceLocalization_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CProductInfo_SetRichPresenceLocalization_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CProductInfo_SetRichPresenceLocalization_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* CProductInfo_SetRichPresenceLocalization_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CProductInfo_SetRichPresenceLocalization_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CProductInfo_SetRichPresenceLocalization_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CProductInfo_SetRichPresenceLocalization_Response)
  return target;
}

size_t CProductInfo_SetRichPresenceLocalization_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CProductInfo_SetRichPresenceLocalization_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CProductInfo_SetRichPresenceLocalization_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CProductInfo_SetRichPresenceLocalization_Response*>(
      &from));
}

void CProductInfo_SetRichPresenceLocalization_Response::MergeFrom(const CProductInfo_SetRichPresenceLocalization_Response& from) {
  CProductInfo_SetRichPresenceLocalization_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:CProductInfo_SetRichPresenceLocalization_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CProductInfo_SetRichPresenceLocalization_Response::CopyFrom(const CProductInfo_SetRichPresenceLocalization_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CProductInfo_SetRichPresenceLocalization_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CProductInfo_SetRichPresenceLocalization_Response::IsInitialized() const {
  return true;
}

void CProductInfo_SetRichPresenceLocalization_Response::InternalSwap(CProductInfo_SetRichPresenceLocalization_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string CProductInfo_SetRichPresenceLocalization_Response::GetTypeName() const {
  return "CProductInfo_SetRichPresenceLocalization_Response";
}


// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CMsgSOIDOwner*
Arena::CreateMaybeMessage< ::CMsgSOIDOwner >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSOIDOwner >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSOSingleObject*
Arena::CreateMaybeMessage< ::CMsgSOSingleObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSOSingleObject >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSOMultipleObjects_SingleObject*
Arena::CreateMaybeMessage< ::CMsgSOMultipleObjects_SingleObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSOMultipleObjects_SingleObject >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSOMultipleObjects*
Arena::CreateMaybeMessage< ::CMsgSOMultipleObjects >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSOMultipleObjects >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSOCacheSubscribed_SubscribedType*
Arena::CreateMaybeMessage< ::CMsgSOCacheSubscribed_SubscribedType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSOCacheSubscribed_SubscribedType >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSOCacheSubscribed*
Arena::CreateMaybeMessage< ::CMsgSOCacheSubscribed >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSOCacheSubscribed >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSOCacheUnsubscribed*
Arena::CreateMaybeMessage< ::CMsgSOCacheUnsubscribed >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSOCacheUnsubscribed >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSOCacheSubscriptionCheck*
Arena::CreateMaybeMessage< ::CMsgSOCacheSubscriptionCheck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSOCacheSubscriptionCheck >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSOCacheSubscriptionRefresh*
Arena::CreateMaybeMessage< ::CMsgSOCacheSubscriptionRefresh >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSOCacheSubscriptionRefresh >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSOCacheVersion*
Arena::CreateMaybeMessage< ::CMsgSOCacheVersion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSOCacheVersion >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgAccountDetails*
Arena::CreateMaybeMessage< ::CMsgAccountDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgAccountDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCMultiplexMessage*
Arena::CreateMaybeMessage< ::CMsgGCMultiplexMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCMultiplexMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCMultiplexMessage_Response*
Arena::CreateMaybeMessage< ::CMsgGCMultiplexMessage_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCMultiplexMessage_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCToGCMsgMasterAck*
Arena::CreateMaybeMessage< ::CGCToGCMsgMasterAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCToGCMsgMasterAck >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCToGCMsgMasterAck_Response*
Arena::CreateMaybeMessage< ::CGCToGCMsgMasterAck_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCToGCMsgMasterAck_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCToGCMsgMasterStartupComplete*
Arena::CreateMaybeMessage< ::CGCToGCMsgMasterStartupComplete >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCToGCMsgMasterStartupComplete >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCToGCMsgRouted*
Arena::CreateMaybeMessage< ::CGCToGCMsgRouted >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCToGCMsgRouted >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCToGCMsgRoutedReply*
Arena::CreateMaybeMessage< ::CGCToGCMsgRoutedReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCToGCMsgRoutedReply >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCUpdateSessionIP*
Arena::CreateMaybeMessage< ::CMsgGCUpdateSessionIP >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCUpdateSessionIP >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCRequestSessionIP*
Arena::CreateMaybeMessage< ::CMsgGCRequestSessionIP >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCRequestSessionIP >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCRequestSessionIPResponse*
Arena::CreateMaybeMessage< ::CMsgGCRequestSessionIPResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCRequestSessionIPResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSOCacheHaveVersion*
Arena::CreateMaybeMessage< ::CMsgSOCacheHaveVersion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSOCacheHaveVersion >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientHello*
Arena::CreateMaybeMessage< ::CMsgClientHello >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientHello >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgServerHello*
Arena::CreateMaybeMessage< ::CMsgServerHello >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgServerHello >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientWelcome_Location*
Arena::CreateMaybeMessage< ::CMsgClientWelcome_Location >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientWelcome_Location >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientWelcome*
Arena::CreateMaybeMessage< ::CMsgClientWelcome >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientWelcome >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgConnectionStatus*
Arena::CreateMaybeMessage< ::CMsgConnectionStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgConnectionStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock*
Arena::CreateMaybeMessage< ::CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock >(arena);
}
template<> PROTOBUF_NOINLINE ::CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription*
Arena::CreateMaybeMessage< ::CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription >(arena);
}
template<> PROTOBUF_NOINLINE ::CWorkshop_PopulateItemDescriptions_Request*
Arena::CreateMaybeMessage< ::CWorkshop_PopulateItemDescriptions_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CWorkshop_PopulateItemDescriptions_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CWorkshop_GetContributors_Request*
Arena::CreateMaybeMessage< ::CWorkshop_GetContributors_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CWorkshop_GetContributors_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CWorkshop_GetContributors_Response*
Arena::CreateMaybeMessage< ::CWorkshop_GetContributors_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CWorkshop_GetContributors_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule*
Arena::CreateMaybeMessage< ::CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule >(arena);
}
template<> PROTOBUF_NOINLINE ::CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule*
Arena::CreateMaybeMessage< ::CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule >(arena);
}
template<> PROTOBUF_NOINLINE ::CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule*
Arena::CreateMaybeMessage< ::CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule >(arena);
}
template<> PROTOBUF_NOINLINE ::CWorkshop_SetItemPaymentRules_Request*
Arena::CreateMaybeMessage< ::CWorkshop_SetItemPaymentRules_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CWorkshop_SetItemPaymentRules_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CWorkshop_SetItemPaymentRules_Response*
Arena::CreateMaybeMessage< ::CWorkshop_SetItemPaymentRules_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CWorkshop_SetItemPaymentRules_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CGameServers_AggregationQuery_Request*
Arena::CreateMaybeMessage< ::CGameServers_AggregationQuery_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGameServers_AggregationQuery_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CGameServers_AggregationQuery_Response_Group*
Arena::CreateMaybeMessage< ::CGameServers_AggregationQuery_Response_Group >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGameServers_AggregationQuery_Response_Group >(arena);
}
template<> PROTOBUF_NOINLINE ::CGameServers_AggregationQuery_Response*
Arena::CreateMaybeMessage< ::CGameServers_AggregationQuery_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGameServers_AggregationQuery_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CWorkshop_AddSpecialPayment_Request*
Arena::CreateMaybeMessage< ::CWorkshop_AddSpecialPayment_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CWorkshop_AddSpecialPayment_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CWorkshop_AddSpecialPayment_Response*
Arena::CreateMaybeMessage< ::CWorkshop_AddSpecialPayment_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CWorkshop_AddSpecialPayment_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CProductInfo_SetRichPresenceLocalization_Request_LanguageSection*
Arena::CreateMaybeMessage< ::CProductInfo_SetRichPresenceLocalization_Request_LanguageSection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CProductInfo_SetRichPresenceLocalization_Request_LanguageSection >(arena);
}
template<> PROTOBUF_NOINLINE ::CProductInfo_SetRichPresenceLocalization_Request_Token*
Arena::CreateMaybeMessage< ::CProductInfo_SetRichPresenceLocalization_Request_Token >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CProductInfo_SetRichPresenceLocalization_Request_Token >(arena);
}
template<> PROTOBUF_NOINLINE ::CProductInfo_SetRichPresenceLocalization_Request*
Arena::CreateMaybeMessage< ::CProductInfo_SetRichPresenceLocalization_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CProductInfo_SetRichPresenceLocalization_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CProductInfo_SetRichPresenceLocalization_Response*
Arena::CreateMaybeMessage< ::CProductInfo_SetRichPresenceLocalization_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CProductInfo_SetRichPresenceLocalization_Response >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
